From bc50fdad18d1f36e366b4f8b7141021c6d19cbfd Mon Sep 17 00:00:00 2001
From: sirati97 <TheSirati97@gmail.com>
Date: Fri, 18 Jan 2019 03:19:17 +0000
Subject: [PATCH] Merged OilSpigot1.12.2 with PaperMC1.12.2 to OilyPaper. yay
 awesome name

---
 ImportedNMSClasses.md                              |  67 ++
 README.md                                          |  68 +-
 TODO                                               |  14 +
 pom.xml                                            |  69 +-
 .../spigot/optimisation/ItemStackFreeze.java       |  64 ++
 src/main/java/nbt/YBase.java                       |  51 ++
 src/main/java/nbt/YByte.java                       |  27 +
 src/main/java/nbt/YByteArray.java                  |  31 +
 src/main/java/nbt/YCtor.java                       |   8 +
 src/main/java/nbt/YDouble.java                     |  27 +
 src/main/java/nbt/YFloat.java                      |  27 +
 src/main/java/nbt/YInt.java                        |  27 +
 src/main/java/nbt/YIntArray.java                   |  33 +
 src/main/java/nbt/YList.java                       |  42 ++
 src/main/java/nbt/YLong.java                       |  27 +
 src/main/java/nbt/YShort.java                      |  27 +
 src/main/java/nbt/YUtil.java                       |  91 +++
 .../net/minecraft/server/AdvancementRewards.java   |   8 +-
 src/main/java/net/minecraft/server/AutoRecipe.java | 241 ++++++
 .../minecraft/server/AutoRecipeStackManager.java   | 323 ++++++++
 src/main/java/net/minecraft/server/Block.java      |  63 ++
 .../java/net/minecraft/server/BlockJukeBox.java    |   3 +-
 .../java/net/minecraft/server/BlockPackedIce.java  |  16 +
 src/main/java/net/minecraft/server/BlockSnow.java  |   2 +-
 .../java/net/minecraft/server/BlockTallPlant.java  |   8 +-
 .../java/net/minecraft/server/BlockTripwire.java   |   4 +-
 src/main/java/net/minecraft/server/BlockVine.java  |   4 +-
 .../net/minecraft/server/BukkitIInventory.java     |  10 +
 .../java/net/minecraft/server/CommandGamemode.java |  81 +-
 .../java/net/minecraft/server/CommandGive.java     |  93 +++
 .../java/net/minecraft/server/CommandRecipe.java   | 104 +++
 src/main/java/net/minecraft/server/CommandTp.java  |   4 +
 src/main/java/net/minecraft/server/Container.java  | 738 +++++++++++-------
 .../java/net/minecraft/server/ContainerAnvil.java  | 169 ++++-
 .../java/net/minecraft/server/ContainerBeacon.java |  10 +-
 .../minecraft/server/ContainerBrewingStand.java    |  57 +-
 .../java/net/minecraft/server/ContainerChest.java  |  14 +-
 .../net/minecraft/server/ContainerDispenser.java   |   4 +-
 .../minecraft/server/ContainerEnchantTable.java    |  64 +-
 .../net/minecraft/server/ContainerFurnace.java     |  36 +-
 .../java/net/minecraft/server/ContainerHopper.java |  14 +-
 .../java/net/minecraft/server/ContainerHorse.java  |   8 +-
 .../net/minecraft/server/ContainerMerchant.java    |  14 +-
 .../java/net/minecraft/server/ContainerPlayer.java |  49 +-
 .../net/minecraft/server/ContainerShulkerBox.java  |   6 +-
 .../java/net/minecraft/server/ContainerUtil.java   |  56 ++
 .../net/minecraft/server/ContainerWorkbench.java   |  73 +-
 .../java/net/minecraft/server/CraftingManager.java | 316 +++++++-
 .../server/CriterionTriggerRecipeUnlocked.java     | 142 ++++
 .../java/net/minecraft/server/DedicatedServer.java |  19 +-
 .../net/minecraft/server/EnchantmentManager.java   |  13 +-
 src/main/java/net/minecraft/server/Entity.java     |  14 +-
 .../net/minecraft/server/EntityArmorStand.java     |  16 +-
 .../java/net/minecraft/server/EntityFireworks.java |   3 +-
 .../net/minecraft/server/EntityHorseAbstract.java  |   3 +-
 .../server/EntityHorseChestedAbstract.java         |   3 +-
 .../net/minecraft/server/EntityInsentient.java     |   6 +-
 src/main/java/net/minecraft/server/EntityItem.java |  12 +-
 .../java/net/minecraft/server/EntityItemFrame.java |   3 +-
 .../java/net/minecraft/server/EntityLiving.java    |  40 +-
 .../net/minecraft/server/EntityMushroomCow.java    |   4 +-
 .../java/net/minecraft/server/EntityPlayer.java    |  26 +-
 .../java/net/minecraft/server/EntityPotion.java    |   3 +-
 .../java/net/minecraft/server/EntitySheep.java     |  13 +-
 .../java/net/minecraft/server/EntitySnowman.java   |   5 +-
 .../java/net/minecraft/server/EntityVillager.java  |   2 +-
 src/main/java/net/minecraft/server/IRecipe.java    |  24 +-
 .../net/minecraft/server/InventoryCraftResult.java |   3 +-
 .../net/minecraft/server/InventoryCrafting.java    |  94 ++-
 .../net/minecraft/server/InventoryEnderChest.java  |   2 +-
 .../java/net/minecraft/server/InventoryUtils.java  |  62 ++
 src/main/java/net/minecraft/server/Item.java       | 831 +++++++++++++++++++++
 src/main/java/net/minecraft/server/ItemAxe.java    |  36 +
 .../net/minecraft/server/ItemKnowledgeBook.java    |  55 ++
 .../java/net/minecraft/server/ItemPickaxe.java     |  39 +
 src/main/java/net/minecraft/server/ItemShears.java |  46 ++
 src/main/java/net/minecraft/server/ItemSpade.java  |  65 ++
 src/main/java/net/minecraft/server/ItemStack.java  | 314 ++++++--
 src/main/java/net/minecraft/server/ItemSword.java  |  73 ++
 src/main/java/net/minecraft/server/Material.java   | 159 ++++
 .../java/net/minecraft/server/MerchantRecipe.java  |   9 +-
 .../java/net/minecraft/server/MinecraftKey.java    | 112 +++
 .../java/net/minecraft/server/MinecraftServer.java |   2 +-
 .../net/minecraft/server/PacketDataSerializer.java |  90 ++-
 .../minecraft/server/PacketPlayInAutoRecipe.java   |  42 ++
 .../server/PacketPlayInRecipeDisplayed.java        |  69 ++
 .../minecraft/server/PacketPlayOutAutoRecipe.java  |  32 +
 .../net/minecraft/server/PacketPlayOutRecipes.java |  92 +++
 .../net/minecraft/server/PlayerConnection.java     |  55 +-
 .../minecraft/server/PlayerInteractManager.java    |  69 +-
 .../java/net/minecraft/server/PlayerInventory.java |   7 +-
 src/main/java/net/minecraft/server/PlayerList.java |   8 +
 .../java/net/minecraft/server/RecipeArmorDye.java  |  13 +
 src/main/java/net/minecraft/server/RecipeBook.java |  61 ++
 .../java/net/minecraft/server/RecipeBookClone.java |  22 +-
 .../net/minecraft/server/RecipeBookServer.java     |  32 +-
 .../java/net/minecraft/server/RecipeFireworks.java |   8 +-
 .../java/net/minecraft/server/RecipeItemStack.java | 111 +++
 .../java/net/minecraft/server/RecipeMapClone.java  |  24 +-
 .../java/net/minecraft/server/RecipeMapExtend.java |  78 ++
 .../java/net/minecraft/server/RecipeRepair.java    |  31 +-
 .../net/minecraft/server/RecipeTippedArrow.java    |  19 +-
 .../java/net/minecraft/server/RecipiesShield.java  |  19 +-
 .../java/net/minecraft/server/ShapedRecipes.java   |  79 +-
 .../net/minecraft/server/ShapelessRecipes.java     |  69 +-
 src/main/java/net/minecraft/server/Slot.java       |  84 +++
 .../net/minecraft/server/SlotFurnaceResult.java    |   7 +-
 src/main/java/net/minecraft/server/SlotResult.java |  85 +++
 .../java/net/minecraft/server/StatisticList.java   | 288 +++++++
 .../net/minecraft/server/TileEntityBanner.java     |   8 +
 .../net/minecraft/server/TileEntityFurnace.java    |  20 +-
 .../java/net/minecraft/server/TileEntitySkull.java |   2 +-
 src/main/java/net/minecraft/server/World.java      |   1 +
 .../java/net/minecraft/server/WorldManager.java    |  20 +-
 .../server/oilmod/ICraftingContainer.java          |   6 +
 .../server/oilmod/IInventoryCraftResult.java       |  11 +
 .../server/oilmod/IInventoryCrafting.java          |  42 ++
 .../java/org/bukkit/craftbukkit/CraftServer.java   |   8 +-
 .../org/bukkit/craftbukkit/block/CraftBlock.java   |   4 +-
 .../bukkit/craftbukkit/block/CraftFlowerPot.java   |   3 +-
 .../craftbukkit/entity/CraftAbstractHorse.java     |   1 +
 .../org/bukkit/craftbukkit/entity/CraftEntity.java |   1 +
 .../craftbukkit/entity/CraftHumanEntity.java       |  20 +-
 .../bukkit/craftbukkit/entity/CraftItemFrame.java  |   2 +-
 .../craftbukkit/entity/CraftThrownPotion.java      |  12 +-
 .../craftbukkit/event/CraftEventFactory.java       |  38 +-
 .../inventory/CraftEntityEquipment.java            |   2 +-
 .../inventory/CraftInventoryCrafting.java          |  26 +-
 .../craftbukkit/inventory/CraftItemStack.java      |  57 +-
 .../craftbukkit/inventory/CraftMerchantRecipe.java |  11 +-
 .../craftbukkit/inventory/CraftShapedRecipe.java   |   5 +-
 .../inventory/CraftShapelessRecipe.java            |   6 +-
 .../craftbukkit/inventory/InventoryWrapper.java    |   2 +-
 .../craftbukkit/inventory/RecipeIterator.java      |  19 +-
 src/main/java/org/oilmod/ApiOilMod.java            |  16 +
 .../org/oilmod/oilclient/ConnectionManager.java    |  51 ++
 .../java/org/oilmod/oilclient/IOHandlerPlayer.java |  40 +
 .../java/org/oilmod/oilclient/OilConnection.java   |  13 +
 src/main/java/org/oilmod/spigot/OilMain.java       | 102 +++
 .../org/oilmod/spigot/block/RealBlockType.java     | 150 ++++
 .../oilmod/spigot/block/RealBlockTypeHelper.java   |  94 +++
 .../org/oilmod/spigot/block/RealNMSMaterial.java   |  53 ++
 .../org/oilmod/spigot/block/RealOilBlockState.java |  38 +
 .../oilmod/spigot/bukkit/stubs/OilBlockStub.java   | 265 +++++++
 .../spigot/bukkit/stubs/OilStubMetadatable.java    |  30 +
 .../java/org/oilmod/spigot/config/ConfigUtil.java  |  63 ++
 .../spigot/config/DeserializationMethod.java       |  15 +
 .../spigot/config/MappedMemoryConfiguration.java   |  34 +
 .../oilmod/spigot/config/nbttag/NBTCompound.java   | 303 ++++++++
 .../oilmod/spigot/config/nbttag/NBTDataList.java   | 166 ++++
 .../oilmod/spigot/config/yaml/YamlCompound.java    | 465 ++++++++++++
 .../oilmod/spigot/config/yaml/YamlDataList.java    | 155 ++++
 .../enchantments/CustomCraftBukkitEnchantment.java |  20 +
 .../spigot/enchantments/CustomEnchantment.java     |  55 ++
 .../org/oilmod/spigot/inventory/ApiItemFilter.java |  21 +
 .../oilmod/spigot/inventory/FilteredInventory.java |  10 +
 .../org/oilmod/spigot/inventory/IItemFilter.java   |  10 +
 .../oilmod/spigot/inventory/ItemStackDataImpl.java |  56 ++
 .../org/oilmod/spigot/inventory/NoItemFilter.java  |  13 +
 .../inventory/OilBukkitCraftInventoryFurnace.java  |  50 ++
 .../OilBukkitCraftInventoryPortableCrafting.java   |  29 +
 .../oilmod/spigot/inventory/OilContainerChest.java |  38 +
 .../spigot/inventory/OilContainerFurnace.java      |  43 ++
 .../spigot/inventory/OilContainerHopper.java       |  39 +
 .../inventory/OilContainerPortableCrafting.java    |  61 ++
 .../spigot/inventory/OilCraftResultInventory.java  | 156 ++++
 .../org/oilmod/spigot/inventory/OilIInventory.java |  15 +
 .../oilmod/spigot/inventory/OilInventoryBase.java  | 284 +++++++
 .../oilmod/spigot/inventory/OilInventoryChest.java |  44 ++
 .../spigot/inventory/OilInventoryFurnace.java      | 350 +++++++++
 .../inventory/OilInventoryPortableCrafting.java    | 237 ++++++
 .../java/org/oilmod/spigot/inventory/OilSlot.java  |  21 +
 .../spigot/inventory/OilSlotFurnaceFuel.java       |  21 +
 .../spigot/inventory/OilSlotFurnaceResult.java     |  74 ++
 .../inventory/OilSlotPortableCraftingResult.java   |  14 +
 .../spigot/inventory/RealInventoryFactory.java     |  57 ++
 .../inventory/creative/OilContainerCreative.java   | 198 +++++
 .../inventory/creative/OilCreativeActionSlot.java  |  63 ++
 .../creative/OilCreativeEmptyActionSlot.java       |  26 +
 .../inventory/creative/OilCreativeInventory.java   | 123 +++
 .../creative/OilCreativeModInventoryCommand.java   |  28 +
 .../creative/OilCreativeMoveActionSlot.java        |  35 +
 .../spigot/inventory/creative/OilCreativeSlot.java |  19 +
 .../inventory/creative/OilInvCreativeSlot.java     |  51 ++
 .../spigot/inventory/custom/ClickExtraData.java    |  37 +
 .../spigot/inventory/custom/ISingleSlot.java       |  22 +
 .../custom/api/NMSFixedSizePanelImpl.java          |  39 +
 .../inventory/custom/api/OilElementWrapper.java    |  96 +++
 .../custom/api/OilInteractableElementWrapper.java  |  70 ++
 .../inventory/custom/api/OilPanelWrapper.java      |  54 ++
 .../spigot/inventory/custom/api/RealUIHelper.java  |  77 ++
 .../inventory/custom/api/UIChestContainer.java     |  75 ++
 .../spigot/inventory/custom/api/WrappedPanel.java  |  10 +
 .../custom/bukkit/BukkitInventoryView.java         |  78 ++
 .../spigot/inventory/custom/nms/MultiSlot.java     |  83 ++
 .../custom/nms/SettableSlotInventorySnapshot.java  | 187 +++++
 .../spigot/inventory/custom/nms/ViewContainer.java | 783 +++++++++++++++++++
 .../spigot/inventory/custom/nms/ViewInventory.java | 100 +++
 .../spigot/inventory/custom/slot/IViewSlot.java    |  16 +
 .../custom/slot/OilInventoryViewSlot.java          |  47 ++
 .../inventory/custom/slot/SettableViewSlot.java    |  17 +
 .../custom/slot/SettableViewSlotBase.java          |  53 ++
 .../spigot/inventory/custom/slot/ViewSlotBase.java |  55 ++
 .../inventory/custom/slot/ViewSlotResult.java      | 151 ++++
 .../custom/view/HumanInventorySlotView.java        |  99 +++
 .../spigot/inventory/custom/view/ISlotView.java    |  13 +
 .../spigot/inventory/custom/view/NullSlotView.java |  24 +
 .../inventory/custom/view/ScalableSlotView.java    |  33 +
 .../inventory/custom/view/ScrollableSlotView.java  | 117 +++
 .../spigot/inventory/custom/view/SlotView.java     |  40 +
 .../spigot/inventory/custom/view/SlotViewBase.java |  18 +
 .../inventory/custom/view/SplittedSlotView.java    |  26 +
 .../custom/view/StaticSplittedSlotView.java        |  32 +
 .../org/oilmod/spigot/items/ItemStackCreator.java  |  18 +
 .../org/oilmod/spigot/items/ItemStackRegistry.java |  42 ++
 .../java/org/oilmod/spigot/items/ItemUtil.java     |  34 +
 .../oilmod/spigot/items/RealCraftItemStack.java    |  94 +++
 .../java/org/oilmod/spigot/items/RealItem.java     | 145 ++++
 .../org/oilmod/spigot/items/RealItemClassMap.java  |  35 +
 .../org/oilmod/spigot/items/RealItemFactory.java   |  20 +
 .../spigot/items/RealItemRegistryHelper.java       |  35 +
 .../org/oilmod/spigot/items/RealItemStack.java     | 317 ++++++++
 .../oilmod/spigot/items/RealItemStackFreeze.java   |  23 +
 .../oilmod/spigot/items/RealItemTypeHelper.java    |  18 +
 .../spigot/items/RealSpecificItemStackFactory.java |  21 +
 .../spigot/items/SpecificItemStackFactory.java     |  10 +
 .../crafting/BukkitCraftingIngredient.java         |  39 +
 .../crafting/BukkitCraftingResultFactory.java      |  28 +
 .../ItemStackCraftingInventoryReference.java       |  27 +
 .../crafting/NMSCraftingIngredient.java            |  16 +
 .../crafting/NMSCraftingResultFactory.java         |  13 +
 .../items/itemstackimpl/crafting/OilRecipe.java    | 128 ++++
 .../itemstackimpl/crafting/OilShapedRecipe.java    | 167 +++++
 .../itemstackimpl/crafting/OilShapelessRecipe.java | 137 ++++
 .../crafting/RealItemCraftingFactory.java          |  50 ++
 .../itemstackimpl/crafting/help/CHCollection.java  |  25 +
 .../itemstackimpl/crafting/help/CHCommand.java     |  57 ++
 .../itemstackimpl/crafting/help/CHContainer.java   |  24 +
 .../crafting/help/CHDisplaySlotView.java           | 163 ++++
 .../crafting/help/CHSelectorSlotView.java          |  34 +
 .../items/itemstackimpl/crafting/help/CHView.java  |  54 ++
 .../itemstackimpl/crafting/help/OilCHView.java     |  30 +
 .../itemstackimpl/crafting/help/ShapedCHView.java  |  47 ++
 .../crafting/help/ShapelessCHView.java             |  45 ++
 .../crafting/help/VanillaArmorDyeChView.java       |  97 +++
 .../crafting/help/VanillaBannerAddCHView.java      | 129 ++++
 .../help/VanillaBannerDuplicateCHView.java         |  62 ++
 .../itemstackimpl/crafting/help/VanillaCHView.java |  55 ++
 .../crafting/help/VanillaFireworksCHView.java      |  26 +
 .../crafting/help/VanillaRepairCHView.java         |  54 ++
 .../crafting/help/VanillaShapedCHView.java         |  24 +
 .../crafting/help/VanillaShapelessCHView.java      |  24 +
 .../crafting/help/VanillaShieldBannerCHView.java   |  51 ++
 .../crafting/help/VanillaTippedArrowCHView.java    |  62 ++
 .../itemstackimpl/crafting/nms/NMS_OilRecipe.java  |  11 +
 .../crafting/nms/NMS_OilShapedRecipe.java          |  24 +
 .../crafting/nms/NMS_OilShapelessRecipe.java       |  33 +
 .../internal/ItemStackDescription.java             |  57 ++
 .../itemstackimpl/internal/ModCraftItemStack.java  |  89 +++
 .../items/itemstackimpl/internal/ModItem.java      |  20 +
 .../items/itemstackimpl/internal/ModItemStack.java | 257 +++++++
 .../itemstackimpl/internal/ModItemStackFreeze.java |  38 +
 .../itemstackimpl/internal/RealItemClassMap.java   |  35 +
 .../itemstackimpl/internal/RealItemFactory.java    |  20 +
 .../org/oilmod/spigot/items/itemtype/RealAxe.java  |  40 +
 .../oilmod/spigot/items/itemtype/RealPickaxe.java  |  47 ++
 .../oilmod/spigot/items/itemtype/RealShears.java   |  59 ++
 .../oilmod/spigot/items/itemtype/RealShovel.java   |  52 ++
 .../oilmod/spigot/items/itemtype/RealSword.java    |  46 ++
 .../spigot/items/itemtype/RealTBBHelper.java       |  43 ++
 .../oilmod/spigot/items/itemtype/RealTBBTool.java  |  52 ++
 src/main/java/org/oilmod/spigot/ui/SlotState.java  |  43 ++
 .../org/oilmod/spigot/ui/StorageSlotBehaviour.java |   5 +
 .../oilmod/spigot/ui/UIInventoryGenericBukkit.java |  37 +
 src/main/java/org/oilmod/spigot/ui/UIManager.java  |  31 +
 .../org/oilmod/spigot/util/BetterNonNullList.java  |  32 +
 .../java/org/oilmod/spigot/util/OilSpigotUtil.java | 219 ++++++
 .../java/org/oilmod/spigot/util/RealOilUtil.java   | 470 ++++++++++++
 src/main/java/org/spigotmc/Metrics.java            |   7 +-
 src/main/java/org/spigotmc/SpigotConfig.java       |   7 +-
 src/main/java/org/spigotmc/WatchdogThread.java     |   6 +-
 .../org/oilmod/spigot/blocks/MaterialToolTest.java | 108 +++
 .../org/oilmod/spigot/config/yaml/NBTYamlTest.java |  21 +
 283 files changed, 17734 insertions(+), 787 deletions(-)
 create mode 100644 ImportedNMSClasses.md
 create mode 100644 TODO
 create mode 100644 src/main/java/de/sirati97/spigot/optimisation/ItemStackFreeze.java
 create mode 100644 src/main/java/nbt/YBase.java
 create mode 100644 src/main/java/nbt/YByte.java
 create mode 100644 src/main/java/nbt/YByteArray.java
 create mode 100644 src/main/java/nbt/YCtor.java
 create mode 100644 src/main/java/nbt/YDouble.java
 create mode 100644 src/main/java/nbt/YFloat.java
 create mode 100644 src/main/java/nbt/YInt.java
 create mode 100644 src/main/java/nbt/YIntArray.java
 create mode 100644 src/main/java/nbt/YList.java
 create mode 100644 src/main/java/nbt/YLong.java
 create mode 100644 src/main/java/nbt/YShort.java
 create mode 100644 src/main/java/nbt/YUtil.java
 create mode 100644 src/main/java/net/minecraft/server/AutoRecipe.java
 create mode 100644 src/main/java/net/minecraft/server/AutoRecipeStackManager.java
 create mode 100644 src/main/java/net/minecraft/server/BlockPackedIce.java
 create mode 100644 src/main/java/net/minecraft/server/BukkitIInventory.java
 create mode 100644 src/main/java/net/minecraft/server/CommandGive.java
 create mode 100644 src/main/java/net/minecraft/server/CommandRecipe.java
 create mode 100644 src/main/java/net/minecraft/server/ContainerUtil.java
 create mode 100644 src/main/java/net/minecraft/server/CriterionTriggerRecipeUnlocked.java
 create mode 100644 src/main/java/net/minecraft/server/InventoryUtils.java
 create mode 100644 src/main/java/net/minecraft/server/Item.java
 create mode 100644 src/main/java/net/minecraft/server/ItemAxe.java
 create mode 100644 src/main/java/net/minecraft/server/ItemKnowledgeBook.java
 create mode 100644 src/main/java/net/minecraft/server/ItemPickaxe.java
 create mode 100644 src/main/java/net/minecraft/server/ItemShears.java
 create mode 100644 src/main/java/net/minecraft/server/ItemSpade.java
 create mode 100644 src/main/java/net/minecraft/server/ItemSword.java
 create mode 100644 src/main/java/net/minecraft/server/Material.java
 create mode 100644 src/main/java/net/minecraft/server/MinecraftKey.java
 create mode 100644 src/main/java/net/minecraft/server/PacketPlayInAutoRecipe.java
 create mode 100644 src/main/java/net/minecraft/server/PacketPlayInRecipeDisplayed.java
 create mode 100644 src/main/java/net/minecraft/server/PacketPlayOutAutoRecipe.java
 create mode 100644 src/main/java/net/minecraft/server/PacketPlayOutRecipes.java
 create mode 100644 src/main/java/net/minecraft/server/RecipeBook.java
 create mode 100644 src/main/java/net/minecraft/server/RecipeItemStack.java
 create mode 100644 src/main/java/net/minecraft/server/RecipeMapExtend.java
 create mode 100644 src/main/java/net/minecraft/server/Slot.java
 create mode 100644 src/main/java/net/minecraft/server/SlotResult.java
 create mode 100644 src/main/java/net/minecraft/server/StatisticList.java
 create mode 100644 src/main/java/net/minecraft/server/oilmod/ICraftingContainer.java
 create mode 100644 src/main/java/net/minecraft/server/oilmod/IInventoryCraftResult.java
 create mode 100644 src/main/java/net/minecraft/server/oilmod/IInventoryCrafting.java
 create mode 100644 src/main/java/org/oilmod/ApiOilMod.java
 create mode 100644 src/main/java/org/oilmod/oilclient/ConnectionManager.java
 create mode 100644 src/main/java/org/oilmod/oilclient/IOHandlerPlayer.java
 create mode 100644 src/main/java/org/oilmod/oilclient/OilConnection.java
 create mode 100644 src/main/java/org/oilmod/spigot/OilMain.java
 create mode 100644 src/main/java/org/oilmod/spigot/block/RealBlockType.java
 create mode 100644 src/main/java/org/oilmod/spigot/block/RealBlockTypeHelper.java
 create mode 100644 src/main/java/org/oilmod/spigot/block/RealNMSMaterial.java
 create mode 100644 src/main/java/org/oilmod/spigot/block/RealOilBlockState.java
 create mode 100644 src/main/java/org/oilmod/spigot/bukkit/stubs/OilBlockStub.java
 create mode 100644 src/main/java/org/oilmod/spigot/bukkit/stubs/OilStubMetadatable.java
 create mode 100644 src/main/java/org/oilmod/spigot/config/ConfigUtil.java
 create mode 100644 src/main/java/org/oilmod/spigot/config/DeserializationMethod.java
 create mode 100644 src/main/java/org/oilmod/spigot/config/MappedMemoryConfiguration.java
 create mode 100644 src/main/java/org/oilmod/spigot/config/nbttag/NBTCompound.java
 create mode 100644 src/main/java/org/oilmod/spigot/config/nbttag/NBTDataList.java
 create mode 100644 src/main/java/org/oilmod/spigot/config/yaml/YamlCompound.java
 create mode 100644 src/main/java/org/oilmod/spigot/config/yaml/YamlDataList.java
 create mode 100644 src/main/java/org/oilmod/spigot/enchantments/CustomCraftBukkitEnchantment.java
 create mode 100644 src/main/java/org/oilmod/spigot/enchantments/CustomEnchantment.java
 create mode 100644 src/main/java/org/oilmod/spigot/inventory/ApiItemFilter.java
 create mode 100644 src/main/java/org/oilmod/spigot/inventory/FilteredInventory.java
 create mode 100644 src/main/java/org/oilmod/spigot/inventory/IItemFilter.java
 create mode 100644 src/main/java/org/oilmod/spigot/inventory/ItemStackDataImpl.java
 create mode 100644 src/main/java/org/oilmod/spigot/inventory/NoItemFilter.java
 create mode 100644 src/main/java/org/oilmod/spigot/inventory/OilBukkitCraftInventoryFurnace.java
 create mode 100644 src/main/java/org/oilmod/spigot/inventory/OilBukkitCraftInventoryPortableCrafting.java
 create mode 100644 src/main/java/org/oilmod/spigot/inventory/OilContainerChest.java
 create mode 100644 src/main/java/org/oilmod/spigot/inventory/OilContainerFurnace.java
 create mode 100644 src/main/java/org/oilmod/spigot/inventory/OilContainerHopper.java
 create mode 100644 src/main/java/org/oilmod/spigot/inventory/OilContainerPortableCrafting.java
 create mode 100644 src/main/java/org/oilmod/spigot/inventory/OilCraftResultInventory.java
 create mode 100644 src/main/java/org/oilmod/spigot/inventory/OilIInventory.java
 create mode 100644 src/main/java/org/oilmod/spigot/inventory/OilInventoryBase.java
 create mode 100644 src/main/java/org/oilmod/spigot/inventory/OilInventoryChest.java
 create mode 100644 src/main/java/org/oilmod/spigot/inventory/OilInventoryFurnace.java
 create mode 100644 src/main/java/org/oilmod/spigot/inventory/OilInventoryPortableCrafting.java
 create mode 100644 src/main/java/org/oilmod/spigot/inventory/OilSlot.java
 create mode 100644 src/main/java/org/oilmod/spigot/inventory/OilSlotFurnaceFuel.java
 create mode 100644 src/main/java/org/oilmod/spigot/inventory/OilSlotFurnaceResult.java
 create mode 100644 src/main/java/org/oilmod/spigot/inventory/OilSlotPortableCraftingResult.java
 create mode 100644 src/main/java/org/oilmod/spigot/inventory/RealInventoryFactory.java
 create mode 100644 src/main/java/org/oilmod/spigot/inventory/creative/OilContainerCreative.java
 create mode 100644 src/main/java/org/oilmod/spigot/inventory/creative/OilCreativeActionSlot.java
 create mode 100644 src/main/java/org/oilmod/spigot/inventory/creative/OilCreativeEmptyActionSlot.java
 create mode 100644 src/main/java/org/oilmod/spigot/inventory/creative/OilCreativeInventory.java
 create mode 100644 src/main/java/org/oilmod/spigot/inventory/creative/OilCreativeModInventoryCommand.java
 create mode 100644 src/main/java/org/oilmod/spigot/inventory/creative/OilCreativeMoveActionSlot.java
 create mode 100644 src/main/java/org/oilmod/spigot/inventory/creative/OilCreativeSlot.java
 create mode 100644 src/main/java/org/oilmod/spigot/inventory/creative/OilInvCreativeSlot.java
 create mode 100644 src/main/java/org/oilmod/spigot/inventory/custom/ClickExtraData.java
 create mode 100644 src/main/java/org/oilmod/spigot/inventory/custom/ISingleSlot.java
 create mode 100644 src/main/java/org/oilmod/spigot/inventory/custom/api/NMSFixedSizePanelImpl.java
 create mode 100644 src/main/java/org/oilmod/spigot/inventory/custom/api/OilElementWrapper.java
 create mode 100644 src/main/java/org/oilmod/spigot/inventory/custom/api/OilInteractableElementWrapper.java
 create mode 100644 src/main/java/org/oilmod/spigot/inventory/custom/api/OilPanelWrapper.java
 create mode 100644 src/main/java/org/oilmod/spigot/inventory/custom/api/RealUIHelper.java
 create mode 100644 src/main/java/org/oilmod/spigot/inventory/custom/api/UIChestContainer.java
 create mode 100644 src/main/java/org/oilmod/spigot/inventory/custom/api/WrappedPanel.java
 create mode 100644 src/main/java/org/oilmod/spigot/inventory/custom/bukkit/BukkitInventoryView.java
 create mode 100644 src/main/java/org/oilmod/spigot/inventory/custom/nms/MultiSlot.java
 create mode 100644 src/main/java/org/oilmod/spigot/inventory/custom/nms/SettableSlotInventorySnapshot.java
 create mode 100644 src/main/java/org/oilmod/spigot/inventory/custom/nms/ViewContainer.java
 create mode 100644 src/main/java/org/oilmod/spigot/inventory/custom/nms/ViewInventory.java
 create mode 100644 src/main/java/org/oilmod/spigot/inventory/custom/slot/IViewSlot.java
 create mode 100644 src/main/java/org/oilmod/spigot/inventory/custom/slot/OilInventoryViewSlot.java
 create mode 100644 src/main/java/org/oilmod/spigot/inventory/custom/slot/SettableViewSlot.java
 create mode 100644 src/main/java/org/oilmod/spigot/inventory/custom/slot/SettableViewSlotBase.java
 create mode 100644 src/main/java/org/oilmod/spigot/inventory/custom/slot/ViewSlotBase.java
 create mode 100644 src/main/java/org/oilmod/spigot/inventory/custom/slot/ViewSlotResult.java
 create mode 100644 src/main/java/org/oilmod/spigot/inventory/custom/view/HumanInventorySlotView.java
 create mode 100644 src/main/java/org/oilmod/spigot/inventory/custom/view/ISlotView.java
 create mode 100644 src/main/java/org/oilmod/spigot/inventory/custom/view/NullSlotView.java
 create mode 100644 src/main/java/org/oilmod/spigot/inventory/custom/view/ScalableSlotView.java
 create mode 100644 src/main/java/org/oilmod/spigot/inventory/custom/view/ScrollableSlotView.java
 create mode 100644 src/main/java/org/oilmod/spigot/inventory/custom/view/SlotView.java
 create mode 100644 src/main/java/org/oilmod/spigot/inventory/custom/view/SlotViewBase.java
 create mode 100644 src/main/java/org/oilmod/spigot/inventory/custom/view/SplittedSlotView.java
 create mode 100644 src/main/java/org/oilmod/spigot/inventory/custom/view/StaticSplittedSlotView.java
 create mode 100644 src/main/java/org/oilmod/spigot/items/ItemStackCreator.java
 create mode 100644 src/main/java/org/oilmod/spigot/items/ItemStackRegistry.java
 create mode 100644 src/main/java/org/oilmod/spigot/items/ItemUtil.java
 create mode 100644 src/main/java/org/oilmod/spigot/items/RealCraftItemStack.java
 create mode 100644 src/main/java/org/oilmod/spigot/items/RealItem.java
 create mode 100644 src/main/java/org/oilmod/spigot/items/RealItemClassMap.java
 create mode 100644 src/main/java/org/oilmod/spigot/items/RealItemFactory.java
 create mode 100644 src/main/java/org/oilmod/spigot/items/RealItemRegistryHelper.java
 create mode 100644 src/main/java/org/oilmod/spigot/items/RealItemStack.java
 create mode 100644 src/main/java/org/oilmod/spigot/items/RealItemStackFreeze.java
 create mode 100644 src/main/java/org/oilmod/spigot/items/RealItemTypeHelper.java
 create mode 100644 src/main/java/org/oilmod/spigot/items/RealSpecificItemStackFactory.java
 create mode 100644 src/main/java/org/oilmod/spigot/items/SpecificItemStackFactory.java
 create mode 100644 src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/BukkitCraftingIngredient.java
 create mode 100644 src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/BukkitCraftingResultFactory.java
 create mode 100644 src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/ItemStackCraftingInventoryReference.java
 create mode 100644 src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/NMSCraftingIngredient.java
 create mode 100644 src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/NMSCraftingResultFactory.java
 create mode 100644 src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/OilRecipe.java
 create mode 100644 src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/OilShapedRecipe.java
 create mode 100644 src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/OilShapelessRecipe.java
 create mode 100644 src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/RealItemCraftingFactory.java
 create mode 100644 src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/CHCollection.java
 create mode 100644 src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/CHCommand.java
 create mode 100644 src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/CHContainer.java
 create mode 100644 src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/CHDisplaySlotView.java
 create mode 100644 src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/CHSelectorSlotView.java
 create mode 100644 src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/CHView.java
 create mode 100644 src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/OilCHView.java
 create mode 100644 src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/ShapedCHView.java
 create mode 100644 src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/ShapelessCHView.java
 create mode 100644 src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/VanillaArmorDyeChView.java
 create mode 100644 src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/VanillaBannerAddCHView.java
 create mode 100644 src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/VanillaBannerDuplicateCHView.java
 create mode 100644 src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/VanillaCHView.java
 create mode 100644 src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/VanillaFireworksCHView.java
 create mode 100644 src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/VanillaRepairCHView.java
 create mode 100644 src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/VanillaShapedCHView.java
 create mode 100644 src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/VanillaShapelessCHView.java
 create mode 100644 src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/VanillaShieldBannerCHView.java
 create mode 100644 src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/VanillaTippedArrowCHView.java
 create mode 100644 src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/nms/NMS_OilRecipe.java
 create mode 100644 src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/nms/NMS_OilShapedRecipe.java
 create mode 100644 src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/nms/NMS_OilShapelessRecipe.java
 create mode 100644 src/main/java/org/oilmod/spigot/items/itemstackimpl/internal/ItemStackDescription.java
 create mode 100644 src/main/java/org/oilmod/spigot/items/itemstackimpl/internal/ModCraftItemStack.java
 create mode 100644 src/main/java/org/oilmod/spigot/items/itemstackimpl/internal/ModItem.java
 create mode 100644 src/main/java/org/oilmod/spigot/items/itemstackimpl/internal/ModItemStack.java
 create mode 100644 src/main/java/org/oilmod/spigot/items/itemstackimpl/internal/ModItemStackFreeze.java
 create mode 100644 src/main/java/org/oilmod/spigot/items/itemstackimpl/internal/RealItemClassMap.java
 create mode 100644 src/main/java/org/oilmod/spigot/items/itemstackimpl/internal/RealItemFactory.java
 create mode 100644 src/main/java/org/oilmod/spigot/items/itemtype/RealAxe.java
 create mode 100644 src/main/java/org/oilmod/spigot/items/itemtype/RealPickaxe.java
 create mode 100644 src/main/java/org/oilmod/spigot/items/itemtype/RealShears.java
 create mode 100644 src/main/java/org/oilmod/spigot/items/itemtype/RealShovel.java
 create mode 100644 src/main/java/org/oilmod/spigot/items/itemtype/RealSword.java
 create mode 100644 src/main/java/org/oilmod/spigot/items/itemtype/RealTBBHelper.java
 create mode 100644 src/main/java/org/oilmod/spigot/items/itemtype/RealTBBTool.java
 create mode 100644 src/main/java/org/oilmod/spigot/ui/SlotState.java
 create mode 100644 src/main/java/org/oilmod/spigot/ui/StorageSlotBehaviour.java
 create mode 100644 src/main/java/org/oilmod/spigot/ui/UIInventoryGenericBukkit.java
 create mode 100644 src/main/java/org/oilmod/spigot/ui/UIManager.java
 create mode 100644 src/main/java/org/oilmod/spigot/util/BetterNonNullList.java
 create mode 100644 src/main/java/org/oilmod/spigot/util/OilSpigotUtil.java
 create mode 100644 src/main/java/org/oilmod/spigot/util/RealOilUtil.java
 create mode 100644 src/test/java/org/oilmod/spigot/blocks/MaterialToolTest.java
 create mode 100644 src/test/java/org/oilmod/spigot/config/yaml/NBTYamlTest.java

diff --git a/ImportedNMSClasses.md b/ImportedNMSClasses.md
new file mode 100644
index 00000000..1e16d504
--- /dev/null
+++ b/ImportedNMSClasses.md
@@ -0,0 +1,67 @@
+Imported Class from NMS and other code dependencies
+=====
+Some classes and methods are derived, do the opposite or are in other ways related to NMS or CraftBukkit code.
+If you add any new instance of this happing add a comment including KEEPSYNC as well with what
+
+Imported Classes from NMS
+----------------------- 
+The following classes may change when updating to a newer version and need to be manually compared the up to date NMS code. This occurs because Spigot does not change those classes and thus a merge will not affect them. Please keep also in mind that sometimes Spigot no longer modfies NMS classes which can also lead to problems. 
+* RecipeItemStack
+* Slot
+* InventoryUtils
+* SlotResult
+* MinecraftKey
+* Registry
+* CriterionTriggerRecipeUnlocked
+* RecipeBook
+* PacketPlayOutRecipes
+* PacketPlayInRecipeDisplayed
+* AutoRecipeStackManager
+* CommandRecipe
+* ItemKnowledgeBook
+* AutoRecipeStackManager
+* AutoRecipe
++ ContainerUtil
+* PacketPlayOutAutoRecipe
+* Item
+* Material
+* ItemPickaxe TODO: check for material.breakablePickaxe
+* ItemShears
+* ItemSword
+* ItemAxe
+* ItemSpade
+* BlockPackedIce (fixed spigot mapping error)
+* CommandGive
+
+
+Classes depended on NMS
+----------------------- 
+The following classes are derived or abstractions of NMS classes and thus also need to be synced. Some of them may only partly depend on the NMS class and their parent instead implements this code.
+* IInventoryCrafting from InventoryCrafting
+* ItemStackFreeze from ItemStack
+* OilInventoryFurnace from TileEntityFurnace, TileEntityChest
+* OilInventoryChest from TileEntityChest
+* OilInventoryBase from TileEntityChest
+* OilRecipe on ShapedRecipes, ShapelessRecipes
+* OilShapedRecipe on ShapedRecipes,
+* OilShapelessRecipe on ShapelessRecipes
+* OilSlotFurnaceResult on SlotFurnaceResult
+
+
+
+Classes depended on CraftBukkit
+----------------------- 
+currently none
+
+
+
+
+Methods depended on NMS
+----------------------- 
+
+currently none
+
+
+Methods depended on CraftBukkit
+----------------------- 
+* OilUtilImpl.mapToNMS() from CraftEntity.getEntity()
\ No newline at end of file
diff --git a/README.md b/README.md
index 761988b7..872c2f5b 100644
--- a/README.md
+++ b/README.md
@@ -1,7 +1,11 @@
-CraftBukkit
+CraftBukkit-MCN-sirati97-Fork named OilSpigot
 ======
 An implementation of the [Bukkit](https://hub.spigotmc.org/stash/projects/SPIGOT/repos/bukkit) plugin API for [Minecraft](https://minecraft.net/) servers, currently maintained by [SpigotMC](http://www.spigotmc.org/).
 
+As well as an implementation of the [OilMod](https://github.com/OilMod/OldMod-API) server-side modding API for [Minecraft](https://minecraft.net/) servers, currently maintained by [sirati97](http://t.me/sirati97/).
+
+So far this file is merely a copy of Spigots and not all text is adjusted correctly. 
+
 Bug Reporting
 -------------
 The development team is very open to both bug and feature requests / suggestions. You can submit these on the [JIRA Issue Tracker](http://hub.spigotmc.org/jira/).
@@ -13,7 +17,7 @@ CraftBukkit is a Java program which uses [Maven 3](http://maven.apache.org/) for
 * Install Git using your preferred installation methods.
 * Download and run [BuildTools](https://www.spigotmc.org/wiki/buildtools/)
 
-Some IDEs such as [NetBeans](https://netbeans.org/) can perform these steps for you. Any Maven capable Java IDE can be used to develop with CraftBukkit, however the current team's personal preference is to use NetBeans.
+Some IDEs such as [IntelliJ IDEA](https://www.jetbrains.com/idea/) can perform these steps for you. Any Maven capable Java IDE can be used to develop with OilSpigot, however the current team's personal preference is to use IntelliJ IDEA.
 
 Contributing
 ------------
@@ -25,13 +29,13 @@ Contributions of all sorts are welcome. To manage community contributions, we us
 
 Once you have performed these steps you can create a fork, push your code changes, and then submit it for review.
 
-If you submit a PR involving both Bukkit and CraftBukkit, each PR should link the other.
+If you submit a PR involving both OilMod and OilSpigot, each PR should link the other.
 
 Although the minimum requirement for compilation & usage is Java 8, we prefer all contributions to be written in Java 7 style code unless there is a compelling reason otherwise.
 
 Code Requirements
 -----------------
-* For the most part, CraftBukkit and Bukkit use the [Sun/Oracle coding standards](http://www.oracle.com/technetwork/java/javase/documentation/codeconvtoc-136057.html).
+* For the most part, OilSpigot and OilMod use the [Sun/Oracle coding standards](http://www.oracle.com/technetwork/java/javase/documentation/codeconvtoc-136057.html).
 * No tabs; use 4 spaces instead.
     * Empty lines should contain no spaces.
 * No trailing whitespaces.
@@ -47,14 +51,14 @@ Code Requirements
 * Do not submit your personal changes to configuration files.
 * Avoid moving or renaming classes.
 
-Bukkit/CraftBukkit employs [JUnit 4](http://www.vogella.com/articles/JUnit/article.html) for testing. Pull Requests(PR) should attempt to integrate within that framework as appropriate.
-Bukkit is a large project and what seems simple to a PR author at the time of writing may easily be overlooked by other authors and updates. Including unit tests with your PR
+OilMod/OilSpigot employs [JUnit 4](http://www.vogella.com/articles/JUnit/article.html) for testing. Pull Requests(PR) should attempt to integrate within that framework as appropriate.
+OilMod is a large project and what seems simple to a PR author at the time of writing may easily be overlooked by other authors and updates. Including unit tests with your PR
 will help to ensure the PR can be easily maintained over time and encourage the Spigot team to pull the PR.
 
 * There needs to be a new line at the end of every file.
 * Imports should be organised in a logical manner.
     * Do not group packages unless already grouped.
-    * All new imports should be within existing CraftBukkit comments if any are present. If not, make them.
+    * All new imports should be within existing OilSpigot comments if any are present. If not, make them.
     * __Absolutely no wildcard imports.__
     * If you only use an import once, don't import it. Use the fully qualified name.
 
@@ -79,23 +83,23 @@ Any questions about these requirements can be asked in #spigot-dev in IRC.
 
 Making Changes to Minecraft
 ---------------------------
-Importing new NMS classes to CraftBukkit is actually very simple.
+Importing new NMS classes to OilSpigot is actually very simple.
 
 1. Find the `work/decompile-XXXXXX` folder in your BuildTools folder.
 2. Find the class you want to add in the `net/minecraft/server` folder and copy it.
-3. Copy the selected file to the `src/main/java/net/minecraft/server` folder in CraftBukkit.
+3. Copy the selected file to the `src/main/java/net/minecraft/server` folder in OilSpigot.
 4. Implement changes.
 5. Run `makePatches.sh` to create a new patch for the new class.
     * _Be sure that Git recognizes the new file. This might require manually adding the file._
 6. Commit new patch.
 
-Done! You have added a new patch for CraftBukkit!
+Done! You have added a new patch for OilSpigot!
 
 **Making Changes to NMS Classes**
 
 Bukkit/CB employs a Minimal Diff policy to help guide when changes should be changed to Minecraft and what those changes should be.
 This is to ensure that any changes have the smallest impact possible on the update process whenever a new Minecraft version is released.
-As well as the Minimal Diff Policy, *every* change made to a Minecraft class must be marked with the appropriate CraftBukkit comment.
+As well as the Minimal Diff Policy, *every* change made to a Minecraft class must be marked with the appropriate OilSpigot comment.
 At no point should you rename an existing/obfuscated field or method. All references to existing/obfusacted fields/methods should be marked with the `// PAIL rename` comment.
 Mapping of new fields/methods are done when there are enough changes to warrant the work. (Any questions can be asked in #spigot-dev in [IRC](https://www.spigotmc.org/wiki/irc-guide/))
 
@@ -105,7 +109,7 @@ __*Key Points*__:
   * If you *have* to add a method to a patch, please explain why in the Pull Request description.
 * __Never__ rename an existing field or method. If you want something renamed, include a ```PAIL rename``` comment
 * Converting a method/class from one access level to another (i.e. private to public) is fine as long as that method is not overridden in subclasses.
-  * If a method is overridden in its' subclasses, create a new method that calls that method instead (along with appropriate CraftBukkit comments).
+  * If a method is overridden in its' subclasses, create a new method that calls that method instead (along with appropriate OilSpigot comments).
 
 **Minimal Diff Policy**
 
@@ -120,7 +124,7 @@ Here are a few tips you should keep in mind, or common areas you should focus on
 
 * Try to avoid duplicating logic or code when making changes.
 * Try to keep your changes easily discernible - don't nest or group several unrelated changes together.
-    * All changes must be surrounded by [CraftBukkit comments](#craftbukkit-comments).
+    * All changes must be surrounded by [OilSpigot comments](#oilspigot-comments).
 * If you only use an import once within a class, don't import it and use a fully qualified name instead.
 * Try to employ "short-circuiting" of logic if at all possible. This means you should force a conditional to be the value needed to side step the code block to achieve your desired effect.
 
@@ -157,7 +161,7 @@ if (sender == null) {
 
 __For example:__
 ```java
-// CraftBukkit start - special case dropping so we can get info from the tile entity
+//OilSpigot start - special case dropping so we can get info from the tile entity
 public void dropNaturally(World world, int i, int j, int k, int l, float f, int i1) {
     if (world.random.nextFloat() < f) {
         ItemStack itemstack = new ItemStack(Item.SKULL, 1, this.getDropData(world, i, j, k));
@@ -171,11 +175,11 @@ public void dropNaturally(World world, int i, int j, int k, int l, float f, int
         this.b(world, i, j, k, itemstack);
     }
 }
-// CraftBukkit end
+//OilSpigot end
 
 public void remove(World world, int i, int j, int k, int l, int i1) {
     if (!world.isStatic) {
-        /* CraftBukkit start - drop item in code above, not here
+        //OilSpigot start - drop item in code above, not here
         if ((i1 & 8) == 0) {
             ItemStack itemstack = new ItemStack(Item.SKULL, 1, this.getDropData(world, i, j, k));
             TileEntitySkull tileentityskull = (TileEntitySkull) world.getTileEntity(i, j, k);
@@ -187,25 +191,25 @@ public void remove(World world, int i, int j, int k, int l, int i1) {
 
             this.b(world, i, j, k, itemstack);
         }
-        // CraftBukkit end */
+        //OilSpigot end
 
         super.remove(world, i, j, k, l, i1);
     }
 }
 ```
 
-#### CraftBukkit Comments
+#### OilSpigot Comments
 
-Changes to a Minecraft class should be clearly marked using CraftBukkit comments.
+Changes to a Minecraft or CraftBukkit class should be clearly marked using OilSpigot comments.
 
-* All CraftBukkit comments should be capitalised appropriately. (i.e. CraftBukkit, not CB/craftBukkit, etc.)
-* If the change only affects one line of code, use an end of line CraftBukkit comment
+* All OilSpigot comments should be capitalised appropriately. (i.e. OilSpigot, not OilMod/oilspigot, etc.)
+* If the change only affects one line of code, use an end of line OilSpigot comment
 
 __Examples:__
 
 If the change is obvious, then you need a simple end of line comment.
 ```java
-if (true || minecraftserver.getAllowNether()) { // CraftBukkit
+if (true || minecraftserver.getAllowNether()) { // OilSpigot
 ```
 
 Every reference to an obfuscated field/method in NMS should be marked with:
@@ -220,20 +224,20 @@ public int fireTicks; // PAIL private -> public
 ```
 Changing access levels must include a PAIL comment indicating the previous access level and the new access level.
 
-If adding the CraftBukkit comment negatively affects the readability of the code, then you should place the comment on a new line *above* the change you made.
+If adding the OilSpigot comment negatively affects the readability of the code, then you should place the comment on a new line *above* the change you made.
 ```java
-// CraftBukkit
+// OilSpigot
 if (!isEffect && !world.isStatic && world.difficulty >= 2 && world.areChunksLoaded(MathHelper.floor(d0), MathHelper.floor(d1), MathHelper.floor(d2), 10)) {
 ```
 
-* If the change affects more than one line, you should use a multi-line CraftBukkit comment.
+* If the change affects more than one line, you should use a multi-line OilSpigot comment.
 
 __Example:__
 
 The majority of the time, multi-line changes should be accompanied by a reason since they're usually much more complicated than a single line change.
-*If the change is something important to note or difficult to discern, you should include a reason at the end of line CraftBukkit comment.*
+*If the change is something important to note or difficult to discern, you should include a reason at the end of line OilSpigot comment.*
 ```java
-// CraftBukkit start - special case dropping so we can get info from the tile entity
+//OilSpigot start - special case dropping so we can get info from the tile entity
 public void dropNaturally(World world, int i, int j, int k, int l, float f, int i1) {
     if (world.random.nextFloat() < f) {
         ItemStack itemstack = new ItemStack(Item.SKULL, 1, this.getDropData(world, i, j, k));
@@ -247,23 +251,23 @@ public void dropNaturally(World world, int i, int j, int k, int l, float f, int
         this.b(world, i, j, k, itemstack);
     }
 }
-// CraftBukkit end
+//OilSpigot end
 ```
 Otherwise, if the change is obvious, such as firing an event, then you can simply use a multi-line comment.
 ```java
-    // CraftBukkit start
+    //OilSpigot start
     BlockIgniteEvent event = new BlockIgniteEvent(this.cworld.getBlockAt(i, j, k), BlockIgniteEvent.IgniteCause.LIGHTNING, null);
     world.getServer().getPluginManager().callEvent(event);
 
     if (!event.isCancelled()) {
         world.setTypeIdUpdate(i, j, k, Block.FIRE);
     }
-    // CraftBukkit end
+    //OilSpigot end
 ```
-* All CraftBukkit comments should be on the same indentation level the code block it is in.
+* All OilSpigot comments should be on the same indentation level the code block it is in.
 
 __Imports in Minecraft Classes__
-* Do not remove unused imports if they are not marked by CraftBukkit comments.
+* Do not remove unused imports if they are not marked by OilSpigot comments.
 
 
 Creating a Pull Request
diff --git a/TODO b/TODO
new file mode 100644
index 00000000..a4b0e53d
--- /dev/null
+++ b/TODO
@@ -0,0 +1,14 @@
+Done:
+- Renamed item
+
+
+
+TODO:
+- Durability
+- Axe
+- Shovel
+- Shears
+- Food
+- Throwable
+- Dispenser
+- Anvil Rename
diff --git a/pom.xml b/pom.xml
index 13284388..e158005a 100644
--- a/pom.xml
+++ b/pom.xml
@@ -1,12 +1,11 @@
 <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
     <modelVersion>4.0.0</modelVersion>
-    <groupId>com.destroystokyo.paper</groupId>
-    <artifactId>paper</artifactId>
+    <artifactId>OilyPaper-Server</artifactId>
     <packaging>jar</packaging>
     <version>1.12.2-R0.1-SNAPSHOT</version>
-    <name>Paper</name>
-    <url>https://github.com/PaperMC/Paper</url>
+    <name>OilyPaper</name>
+    <url>https://github.com/OilMod/OilyPaper</url>
 
     <properties>
         <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
@@ -21,8 +20,8 @@
     </properties>
 
     <parent>
-        <groupId>com.destroystokyo.paper</groupId>
-        <artifactId>paper-parent</artifactId>
+        <groupId>org.oilmod</groupId>
+        <artifactId>oilmod-parent</artifactId>
         <version>dev-SNAPSHOT</version>
         <relativePath>../pom.xml</relativePath>
     </parent>
@@ -36,8 +35,8 @@
             <scope>compile</scope>
         </dependency>
         <dependency>
-            <groupId>com.destroystokyo.paper</groupId>
-            <artifactId>paper-api</artifactId>
+            <groupId>org.oilmod</groupId>
+            <artifactId>OilyPaper-Bukkit-api</artifactId>
             <version>${project.version}</version>
             <scope>compile</scope>
         </dependency>
@@ -71,6 +70,11 @@
             <version>3.0.3</version>
             <scope>compile</scope>
         </dependency>
+        <dependency>
+            <groupId>org.oilmod</groupId>
+            <artifactId>oilmod-api</artifactId>
+            <version>1.0-SNAPSHOT</version>
+        </dependency>
 
         <dependency>
             <groupId>net.minecrell</groupId>
@@ -133,13 +137,7 @@
         </dependency>
     </dependencies>
 
-    <repositories>
-        <repository>
-            <id>spigotmc-public</id>
-            <url>https://hub.spigotmc.org/nexus/content/groups/public/</url>
-        </repository>
-    </repositories>
-
+    <!-- required until fixed plexus-compiler-eclipse is deployed -->
     <pluginRepositories>
         <pluginRepository>
             <id>spigotmc-public</id>
@@ -157,7 +155,7 @@
                 <artifactId>gitdescribe-maven-plugin</artifactId>
                 <version>1.3</version>
                 <configuration>
-                    <outputPrefix>git-Paper-</outputPrefix>
+                    <outputPrefix>git-OilMod-OilyPaper-</outputPrefix>
                     <scmDirectory>..</scmDirectory>
                 </configuration>
                 <executions>
@@ -178,12 +176,12 @@
                     <archive>
                         <manifestEntries>
                             <Main-Class>org.bukkit.craftbukkit.Main</Main-Class>
-                            <Implementation-Title>CraftBukkit</Implementation-Title>
+                            <Implementation-Title>OilSpigot</Implementation-Title>
                             <Implementation-Version>${describe}</Implementation-Version>
                             <Implementation-Vendor>${maven.build.timestamp}</Implementation-Vendor>
-                            <Specification-Title>Bukkit</Specification-Title>
+                            <Specification-Title>Bukkit/OilMod</Specification-Title>
                             <Specification-Version>${api.version}</Specification-Version>
-                            <Specification-Vendor>Bukkit Team</Specification-Vendor>
+                            <Specification-Vendor>OilMod Team</Specification-Vendor>
                         </manifestEntries>
                         <manifestSections>
                             <manifestSection>
@@ -253,6 +251,22 @@
                                 </transformer>
                                 <transformer implementation="com.github.edwgiz.mavenShadePlugin.log4j2CacheTransformer.PluginsCacheFileTransformer" />
                             </transformers>
+                            <filters>
+                                <filter>
+                                    <artifact>*:*</artifact>
+                                    <excludes>
+                                        <exclude>META-INF/*.SF</exclude>
+                                        <exclude>META-INF/*.DSA</exclude>
+                                        <exclude>META-INF/*.RSA</exclude>
+                                    </excludes>
+                                </filter>
+                            </filters>
+
+                            <artifactSet>
+                                <excludes>
+                                    <exclude>org.bouncycastle:bcprov-jdk16</exclude>
+                                </excludes>
+                            </artifactSet>
                         </configuration>
                     </execution>
                 </executions>
@@ -281,6 +295,23 @@
                     </excludes>
                 </configuration>
             </plugin>
+
+            <plugin>
+                <artifactId>maven-antrun-plugin</artifactId>
+                <executions>
+                    <execution>
+                        <phase>install</phase>
+                        <configuration>
+                            <tasks>
+                                <copy file="${project.build.directory}/${project.build.finalName}.jar" todir="${project.build.directory}/../../Test"/>
+                            </tasks>
+                        </configuration>
+                        <goals>
+                            <goal>run</goal>
+                        </goals>
+                    </execution>
+                </executions>
+            </plugin>
         </plugins>
     </build>
 
diff --git a/src/main/java/de/sirati97/spigot/optimisation/ItemStackFreeze.java b/src/main/java/de/sirati97/spigot/optimisation/ItemStackFreeze.java
new file mode 100644
index 00000000..5b17b52a
--- /dev/null
+++ b/src/main/java/de/sirati97/spigot/optimisation/ItemStackFreeze.java
@@ -0,0 +1,64 @@
+package de.sirati97.spigot.optimisation;
+
+import net.minecraft.server.Blocks;
+import net.minecraft.server.Item;
+import net.minecraft.server.ItemStack;
+import net.minecraft.server.NBTTagCompound;
+
+/**
+ * Created by sirati97 on 14.03.2016.
+ */
+public class ItemStackFreeze { //TODO get this into oilmod
+    public final NBTTagCompound tag;
+    public final Item item;
+    public final int count;
+    public final int damage;
+    public static final ItemStackFreeze EMPTY = new ItemStackFreeze();
+
+    private ItemStackFreeze() {
+        this(null, null, 0,0);
+
+    }
+
+    public ItemStackFreeze(NBTTagCompound tag, Item item, int count, int damage) {
+        this.tag = tag==null?null:(NBTTagCompound) tag.clone();
+        this.item = item;
+        this.count = count;
+        this.damage = damage;
+    }
+
+    public static boolean fastMatches(ItemStackFreeze freeze, ItemStack itemstack) {
+        boolean empty1 = freeze.isEmpty();
+        boolean empty2 = itemstack.isEmpty();
+        if (empty1 || empty2) {
+            return empty1 && empty2;
+        }
+        return freeze.fastMatchTo(itemstack);
+    }
+
+    public boolean fastMatchTo(ItemStack itemstack) {
+        return this.count == itemstack.getCount() && this.item == itemstack.getItem() && this.damage == itemstack.getData();
+    }
+
+    public static boolean matches(ItemStackFreeze freeze, ItemStack itemstack) {
+        boolean empty1 = freeze.isEmpty();
+        boolean empty2 = itemstack.isEmpty();
+        return empty1 || empty2 ? empty1 && empty2 : (freeze.matchTo(itemstack));
+    }
+
+    private boolean matchTo(ItemStack itemstack) {
+        return fastMatchTo(itemstack) && (((this.tag != null) || (itemstack.getTag() == null)) && ((this.tag == null) || this.tag.equals(itemstack.getTag())));
+    }
+
+    private static final Item itemAIR= Item.getItemOf(Blocks.AIR);
+    public boolean isEmpty() {
+        //Taken from ItemStack class
+        return this == EMPTY || (this.item == null || this.item == itemAIR || (this.count <= 0 || (this.damage < -32768 || this.damage > '\uffff')));
+    }
+
+
+    public String toString() {
+        return isEmpty() ? "EmptyItemFreeze" : "Freeze: " + this.count + "x" + this.item.getName() + "@" + this.damage;
+    }
+
+}
diff --git a/src/main/java/nbt/YBase.java b/src/main/java/nbt/YBase.java
new file mode 100644
index 00000000..d8f2e5a0
--- /dev/null
+++ b/src/main/java/nbt/YBase.java
@@ -0,0 +1,51 @@
+package nbt;
+
+import org.oilmod.api.config.DataType;
+import org.bukkit.configuration.serialization.ConfigurationSerializable;
+import org.bukkit.configuration.serialization.ConfigurationSerialization;
+
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * Created by sirati97 on 24.06.2016 for spigot.
+ */
+public abstract class YBase<NBTType extends YBase<NBTType, Type>, Type> implements ConfigurationSerializable {
+    private final Type value;
+
+    public YBase(Type value) {
+        this.value = value;
+    }
+
+    @Override
+    public Map<String, Object> serialize() {
+        Map<String, Object> result = new HashMap<>(1);
+        result.put(".", value);
+        return result;
+    }
+
+
+    public static <NBTType extends YBase<NBTType, Type>, Type> NBTType deserializeImpl(Map<String, Object> args, YCtor<NBTType, Type> ctor) {
+        //noinspection unchecked
+        return ctor.construct(args.get("."));
+    }
+
+    public Type getValue() {
+        return value;
+    }
+
+    public static void registerYAMLClasses() {
+        ConfigurationSerialization.registerClass(YByte.class);
+        ConfigurationSerialization.registerClass(YShort.class);
+        ConfigurationSerialization.registerClass(YInt.class);
+        ConfigurationSerialization.registerClass(YLong.class);
+        ConfigurationSerialization.registerClass(YFloat.class);
+        ConfigurationSerialization.registerClass(YDouble.class);
+        ConfigurationSerialization.registerClass(YByteArray.class);
+        ConfigurationSerialization.registerClass(YIntArray.class);
+        ConfigurationSerialization.registerClass(YList.class);
+    }
+
+
+    public abstract DataType getDataType();
+}
diff --git a/src/main/java/nbt/YByte.java b/src/main/java/nbt/YByte.java
new file mode 100644
index 00000000..1dc03409
--- /dev/null
+++ b/src/main/java/nbt/YByte.java
@@ -0,0 +1,27 @@
+package nbt;
+
+import org.oilmod.api.config.DataType;
+
+import java.util.Map;
+
+/**
+ * Created by sirati97 on 10.02.2016.
+ */
+public class YByte extends YBase<YByte, Byte>{
+    private static final YCtor<YByte, Byte> ctor = arg -> new YByte(((Number)arg).byteValue());
+
+
+    public YByte(Byte value) {
+        super(value);
+    }
+
+    @Override
+    public DataType getDataType() {
+        return DataType.Byte;
+    }
+
+
+    public static YByte deserialize(Map<String, Object> args) {
+        return YBase.deserializeImpl(args, ctor);
+    }
+}
diff --git a/src/main/java/nbt/YByteArray.java b/src/main/java/nbt/YByteArray.java
new file mode 100644
index 00000000..8fab9677
--- /dev/null
+++ b/src/main/java/nbt/YByteArray.java
@@ -0,0 +1,31 @@
+package nbt;
+
+import org.oilmod.api.config.DataType;
+
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * Created by sirati97 on 10.02.2016.
+ */
+public class YByteArray extends YBase<YByteArray, byte[]>{
+    public YByteArray(byte[] value) {
+        super(value);
+    }
+
+    @Override
+    public DataType getDataType() {
+        return DataType.ByteArray;
+    }
+
+    public static YByteArray deserialize(Map<String, Object> args) {
+        return new YByteArray(YUtil.stringToByteArray((String) args.get(".")));
+    }
+
+    @Override
+    public Map<String, Object> serialize() {
+        Map<String, Object> result = new HashMap<>(1);
+        result.put(".", YUtil.byteArrayToString(getValue()));
+        return result;
+    }
+}
diff --git a/src/main/java/nbt/YCtor.java b/src/main/java/nbt/YCtor.java
new file mode 100644
index 00000000..97514143
--- /dev/null
+++ b/src/main/java/nbt/YCtor.java
@@ -0,0 +1,8 @@
+package nbt;
+
+/**
+ * Created by sirati97 on 24.06.2016 for spigot.
+ */
+public interface YCtor<NBTType extends YBase<NBTType, Type>, Type> {
+    NBTType construct(Object arg);
+}
diff --git a/src/main/java/nbt/YDouble.java b/src/main/java/nbt/YDouble.java
new file mode 100644
index 00000000..737dd38d
--- /dev/null
+++ b/src/main/java/nbt/YDouble.java
@@ -0,0 +1,27 @@
+package nbt;
+
+import org.oilmod.api.config.DataType;
+
+import java.util.Map;
+
+/**
+ * Created by sirati97 on 10.02.2016.
+ */
+public class YDouble extends YBase<YDouble, Double>{
+    private static final YCtor<YDouble, Double> ctor = arg -> new YDouble(((Number)arg).doubleValue());
+
+
+    public YDouble(Double value) {
+        super(value);
+    }
+
+    @Override
+    public DataType getDataType() {
+        return DataType.Double;
+    }
+
+
+    public static YDouble deserialize(Map<String, Object> args) {
+        return YBase.deserializeImpl(args, ctor);
+    }
+}
diff --git a/src/main/java/nbt/YFloat.java b/src/main/java/nbt/YFloat.java
new file mode 100644
index 00000000..47435a8a
--- /dev/null
+++ b/src/main/java/nbt/YFloat.java
@@ -0,0 +1,27 @@
+package nbt;
+
+import org.oilmod.api.config.DataType;
+
+import java.util.Map;
+
+/**
+ * Created by sirati97 on 10.02.2016.
+ */
+public class YFloat extends YBase<YFloat, Float>{
+    private static final YCtor<YFloat, Float> ctor = arg -> new YFloat(((Number)arg).floatValue());
+
+
+    public YFloat(Float value) {
+        super(value);
+    }
+
+    @Override
+    public DataType getDataType() {
+        return DataType.Float;
+    }
+
+
+    public static YFloat deserialize(Map<String, Object> args) {
+        return YBase.deserializeImpl(args, ctor);
+    }
+}
diff --git a/src/main/java/nbt/YInt.java b/src/main/java/nbt/YInt.java
new file mode 100644
index 00000000..719dedf8
--- /dev/null
+++ b/src/main/java/nbt/YInt.java
@@ -0,0 +1,27 @@
+package nbt;
+
+import org.oilmod.api.config.DataType;
+
+import java.util.Map;
+
+/**
+ * Created by sirati97 on 10.02.2016.
+ */
+public class YInt extends YBase<YInt, Integer>{
+    private static final YCtor<YInt, Integer> ctor = arg -> new YInt(((Number)arg).intValue());
+
+
+    public YInt(Integer value) {
+        super(value);
+    }
+
+    @Override
+    public DataType getDataType() {
+        return DataType.Int;
+    }
+
+
+    public static YInt deserialize(Map<String, Object> args) {
+        return YBase.deserializeImpl(args, ctor);
+    }
+}
diff --git a/src/main/java/nbt/YIntArray.java b/src/main/java/nbt/YIntArray.java
new file mode 100644
index 00000000..acbaf604
--- /dev/null
+++ b/src/main/java/nbt/YIntArray.java
@@ -0,0 +1,33 @@
+package nbt;
+
+import org.oilmod.api.config.DataType;
+
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * Created by sirati97 on 10.02.2016.
+ */
+public class YIntArray extends YBase<YIntArray, int[]>{
+
+    public YIntArray(int[] value) {
+        super(value);
+    }
+
+    @Override
+    public DataType getDataType() {
+        return DataType.IntArray;
+    }
+
+
+    public static YIntArray deserialize(Map<String, Object> args) {
+        return new YIntArray(YUtil.stringToIntArray((String) args.get(".")));
+    }
+
+    @Override
+    public Map<String, Object> serialize() {
+        Map<String, Object> result = new HashMap<>(1);
+        result.put(".", YUtil.intArrayToString(getValue()));
+        return result;
+    }
+}
diff --git a/src/main/java/nbt/YList.java b/src/main/java/nbt/YList.java
new file mode 100644
index 00000000..605767d6
--- /dev/null
+++ b/src/main/java/nbt/YList.java
@@ -0,0 +1,42 @@
+package nbt;
+
+import org.oilmod.api.config.DataType;
+import org.oilmod.spigot.config.yaml.YamlDataList;
+
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Created by sirati97 on 10.02.2016.
+ */
+public class YList extends YBase<YList, YamlDataList>{
+
+    public YList(YamlDataList value) {
+        super(value);
+    }
+
+    @Override
+    public DataType getDataType() {
+        return DataType.List;
+    }
+
+
+    public static YList deserialize(Map<String, Object> args) {
+        String typeName =(String) args.get("Type");
+        DataType type = DataType.valueOf(typeName);
+        if (type==null || type==DataType.NBTEnd || type==DataType.Undefined || type==DataType.Empty) {
+            throw new IllegalStateException("Cannot create list with the type '" +typeName + "'");
+        }
+        //noinspection unchecked
+        return new YamlDataList((List) args.get("."), type).getYList();
+    }
+
+    @Override
+    public Map<String, Object> serialize() {
+        Map<String, Object> result = new HashMap<>(1);
+        result.put("Type", getValue().getType().toString());
+        result.put(".", getValue().getData());
+        return result;
+    }
+}
diff --git a/src/main/java/nbt/YLong.java b/src/main/java/nbt/YLong.java
new file mode 100644
index 00000000..44a08bf7
--- /dev/null
+++ b/src/main/java/nbt/YLong.java
@@ -0,0 +1,27 @@
+package nbt;
+
+import org.oilmod.api.config.DataType;
+
+import java.util.Map;
+
+/**
+ * Created by sirati97 on 10.02.2016.
+ */
+public class YLong extends YBase<YLong, Long>{
+    private static final YCtor<YLong, Long> ctor = arg -> new YLong(((Number)arg).longValue());
+
+
+    public YLong(Long value) {
+        super(value);
+    }
+
+    @Override
+    public DataType getDataType() {
+        return DataType.Long;
+    }
+
+
+    public static YLong deserialize(Map<String, Object> args) {
+        return YBase.deserializeImpl(args, ctor);
+    }
+}
diff --git a/src/main/java/nbt/YShort.java b/src/main/java/nbt/YShort.java
new file mode 100644
index 00000000..2a5ba997
--- /dev/null
+++ b/src/main/java/nbt/YShort.java
@@ -0,0 +1,27 @@
+package nbt;
+
+import org.oilmod.api.config.DataType;
+
+import java.util.Map;
+
+/**
+ * Created by sirati97 on 10.02.2016.
+ */
+public class YShort extends YBase<YShort, Short>{
+    private static final YCtor<YShort, Short> ctor = arg -> new YShort(((Number)arg).shortValue());
+
+
+    public YShort(Short value) {
+        super(value);
+    }
+
+    @Override
+    public DataType getDataType() {
+        return DataType.Short;
+    }
+
+
+    public static YShort deserialize(Map<String, Object> args) {
+        return YBase.deserializeImpl(args, ctor);
+    }
+}
diff --git a/src/main/java/nbt/YUtil.java b/src/main/java/nbt/YUtil.java
new file mode 100644
index 00000000..929ab959
--- /dev/null
+++ b/src/main/java/nbt/YUtil.java
@@ -0,0 +1,91 @@
+package nbt;
+
+/**
+ * Created by sirati97 on 24.06.2016 for spigot.
+ */
+public final class YUtil {
+    private YUtil() {throw new UnsupportedOperationException();}
+    private final static char[] encoding = "0123456789ABCDEF".toCharArray();
+    private final static long[] binary = {0x1,0x10,0x100,0x1000,0x10000,0x100000,0x1000000,0x10000000};
+
+    public static String intArrayToString(int[] array) {
+        char[] encodedChars = new char[array.length * 4 * 2];
+        for (int i = 0; i < array.length; i++) {
+            int v = array[i];
+            int idx = i * 4 * 2;
+            for (int j = 0; j < 8; j++) {
+                encodedChars[idx + j] = encoding[(v >>> ((7-j)*4)) & 0x0F];
+            }
+        }
+        return new String(encodedChars);
+    }
+
+    public static String byteArrayToString(byte[] array) {
+        char[] encodedChars = new char[array.length * 2];
+        for (int i = 0; i < array.length; i++) {
+            byte v = array[i];
+            int idx = i * 2;
+            encodedChars[idx] = encoding[(v >>> (4)) & 0x0F];
+            encodedChars[idx + 1] = encoding[(v) & 0x0F];
+        }
+        return new String(encodedChars);
+    }
+
+    public static int[] stringToIntArray(String s) {
+        final int len = s.length();
+
+        if (len % 8 != 0) {
+            throw new IllegalArgumentException("Length has to be divisible by 8: " + s);
+        }
+
+        int[] out = new int[len / 8];
+
+        for (int i = 0; i < out.length; i++) {
+            int result = 0;
+            for (int j = 0; j < 8; j++) {
+                int h = hexToBin(s.charAt(i*8+j));
+                if (h == -1) {
+                    throw new IllegalArgumentException("contains illegal character for base16: " + s);
+                }
+                result |= h*binary[7-j];
+            }
+            out[i] = result;
+        }
+        return out;
+    }
+
+    public static byte[] stringToByteArray(String s) {
+        final int len = s.length();
+
+        if (len % 2 != 0) {
+            throw new IllegalArgumentException("Length has to be divisible by 2: " + s);
+        }
+
+        byte[] out = new byte[len / 2];
+
+        for (int i = 0; i < len; i += 2) {
+            int h = hexToBin(s.charAt(i));
+            int l = hexToBin(s.charAt(i + 1));
+            if (h == -1 || l == -1) {
+                throw new IllegalArgumentException("contains illegal character for base16: " + s);
+            }
+
+            out[i / 2] = (byte) (h * 16 + l);
+        }
+
+        return out;
+    }
+
+    private static int hexToBin(char ch) {
+        if ('0' <= ch && ch <= '9') {
+            return ch - '0';
+        }
+        if ('A' <= ch && ch <= 'F') {
+            return ch - 'A' + 10;
+        }
+        if ('a' <= ch && ch <= 'f') {
+            return ch - 'a' + 10;
+        }
+        return -1;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/AdvancementRewards.java b/src/main/java/net/minecraft/server/AdvancementRewards.java
index dc031424..1a85e721 100644
--- a/src/main/java/net/minecraft/server/AdvancementRewards.java
+++ b/src/main/java/net/minecraft/server/AdvancementRewards.java
@@ -11,6 +11,10 @@ import java.lang.reflect.Type;
 import java.util.Arrays;
 import java.util.Iterator;
 
+//OilSpigot start
+import java.util.Set;
+//OilSpigot end
+
 public class AdvancementRewards {
 
     public static final AdvancementRewards a = new AdvancementRewards(0, new MinecraftKey[0], new MinecraftKey[0], CustomFunction.a.a);
@@ -151,9 +155,11 @@ public class AdvancementRewards {
 
             for (int k = 0; k < aminecraftkey1.length; ++k) {
                 aminecraftkey1[k] = new MinecraftKey(ChatDeserializer.a(jsonarray1.get(k), "recipes[" + k + "]"));
-                IRecipe irecipe = CraftingManager.a(aminecraftkey1[k]);
+                //OilSpigot start - use getByKey() as it tests all registered crafting managers
+                IRecipe irecipe = CraftingManager.getByKey(aminecraftkey1[k]);
 
                 if (irecipe == null) {
+                    //OilSpigot end
                     throw new JsonSyntaxException("Unknown recipe \'" + aminecraftkey1[k] + "\'");
                 }
             }
diff --git a/src/main/java/net/minecraft/server/AutoRecipe.java b/src/main/java/net/minecraft/server/AutoRecipe.java
new file mode 100644
index 00000000..4b6a8ae4
--- /dev/null
+++ b/src/main/java/net/minecraft/server/AutoRecipe.java
@@ -0,0 +1,241 @@
+package net.minecraft.server;
+
+import it.unimi.dsi.fastutil.ints.IntArrayList;
+import it.unimi.dsi.fastutil.ints.IntList;
+import it.unimi.dsi.fastutil.ints.IntListIterator;
+import java.util.List;
+import javax.annotation.Nullable;
+
+import net.minecraft.server.oilmod.ICraftingContainer;
+import net.minecraft.server.oilmod.IInventoryCraftResult;
+import net.minecraft.server.oilmod.IInventoryCrafting;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public class AutoRecipe {
+
+    private final Logger a = LogManager.getLogger();
+    private final AutoRecipeStackManager b = new AutoRecipeStackManager();
+    private EntityPlayer c;
+    private IRecipe d;
+    private boolean e;
+    private IInventoryCraftResult f; //OilSpigot InventoryCraftResult -> IInventoryCraftResult
+    private IInventoryCrafting g; //OilSpigot InventoryCrafting -> IInventoryCrafting
+    private List<Slot> h;
+
+    public AutoRecipe() {}
+
+    public void a(EntityPlayer entityplayer, @Nullable IRecipe irecipe, boolean flag) {
+        if (irecipe != null && entityplayer.F().b(irecipe)) {
+            this.c = entityplayer;
+            this.d = irecipe;
+            this.e = flag;
+            this.h = entityplayer.activeContainer.slots;
+            //OilSpigot start just use generalised ICraftingContainer
+            ICraftingContainer container = (ICraftingContainer) entityplayer.activeContainer;
+
+            this.f = container.getResultInventory();
+            this.g = container.getCraftingInventory();
+            //OilSpigot end
+
+            if (this.f != null && this.g != null) {
+                if (this.c() || entityplayer.z()) {
+                    this.b.a();
+                    entityplayer.inventory.a(this.b, false);
+                    this.g.a(this.b);
+                    if (this.b.a(irecipe, (IntList) null)) {
+                        this.b();
+                    } else {
+                        this.a();
+                        entityplayer.playerConnection.sendPacket(new PacketPlayOutAutoRecipe(entityplayer.activeContainer.windowId, irecipe));
+                    }
+
+                    entityplayer.inventory.update();
+                }
+            }
+        }
+    }
+
+    private void a() {
+        PlayerInventory playerinventory = this.c.inventory;
+
+        for (int i = 0; i < this.g.getSize(); ++i) {
+            ItemStack itemstack = this.g.getItem(i);
+
+            if (!itemstack.isEmpty()) {
+                while (itemstack.getCount() > 0) {
+                    int j = playerinventory.firstPartial(itemstack);
+
+                    if (j == -1) {
+                        j = playerinventory.getFirstEmptySlotIndex();
+                    }
+
+                    ItemStack itemstack1 = itemstack.cloneItemStack();
+
+                    itemstack1.setCount(1);
+                    playerinventory.c(j, itemstack1);
+                    this.g.splitStack(i, 1);
+                }
+            }
+        }
+
+        this.g.clear();
+        this.f.clear();
+    }
+
+    private void b() {
+        boolean flag = this.d.a(this.g, this.c.world);
+        int i = this.b.b(this.d, (IntList) null);
+
+        if (flag) {
+            boolean flag1 = true;
+
+            for (int j = 0; j < this.g.getSize(); ++j) {
+                ItemStack itemstack = this.g.getItem(j);
+
+                if (!itemstack.isEmpty() && Math.min(i, itemstack.getMaxStackSize()) > itemstack.getCount()) {
+                    flag1 = false;
+                }
+            }
+
+            if (flag1) {
+                return;
+            }
+        }
+
+        int k = this.a(i, flag);
+        IntArrayList intarraylist = new IntArrayList();
+
+        if (this.b.a(this.d, intarraylist, k)) {
+            int l = k;
+            IntListIterator intlistiterator = intarraylist.iterator();
+
+            while (intlistiterator.hasNext()) {
+                int i1 = ((Integer) intlistiterator.next()).intValue();
+                int j1 = AutoRecipeStackManager.b(i1).getMaxStackSize();
+
+                if (j1 < l) {
+                    l = j1;
+                }
+            }
+
+            if (this.b.a(this.d, intarraylist, l)) {
+                this.a();
+                this.a(l, intarraylist);
+            }
+        }
+    }
+
+    private int a(int i, boolean flag) {
+        int j = 1;
+
+        if (this.e) {
+            j = i;
+        } else if (flag) {
+            j = 64;
+
+            for (int k = 0; k < this.g.getSize(); ++k) {
+                ItemStack itemstack = this.g.getItem(k);
+
+                if (!itemstack.isEmpty() && j > itemstack.getCount()) {
+                    j = itemstack.getCount();
+                }
+            }
+
+            if (j < 64) {
+                ++j;
+            }
+        }
+
+        return j;
+    }
+
+    private void a(int i, IntList intlist) {
+        int j = this.g.j();
+        int k = this.g.i();
+
+        if (this.d instanceof ShapedRecipes) {
+            ShapedRecipes shapedrecipes = (ShapedRecipes) this.d;
+
+            j = shapedrecipes.f();
+            k = shapedrecipes.g();
+        }
+
+        int l = 1;
+        IntListIterator intlistiterator = intlist.iterator();
+
+        for (int i1 = 0; i1 < this.g.j() && k != i1; ++i1) {
+            for (int j1 = 0; j1 < this.g.i(); ++j1) {
+                if (j == j1 || !intlistiterator.hasNext()) {
+                    l += this.g.j() - j1;
+                    break;
+                }
+
+                Slot slot = (Slot) this.h.get(l);
+                ItemStack itemstack = AutoRecipeStackManager.b(((Integer) intlistiterator.next()).intValue());
+
+                if (itemstack.isEmpty()) {
+                    ++l;
+                } else {
+                    for (int k1 = 0; k1 < i; ++k1) {
+                        this.a(slot, itemstack);
+                    }
+
+                    ++l;
+                }
+            }
+
+            if (!intlistiterator.hasNext()) {
+                break;
+            }
+        }
+
+    }
+
+    private void a(Slot slot, ItemStack itemstack) {
+        PlayerInventory playerinventory = this.c.inventory;
+        int i = playerinventory.c(itemstack);
+
+        if (i != -1) {
+            ItemStack itemstack1 = playerinventory.getItem(i).cloneItemStack();
+
+            if (!itemstack1.isEmpty()) {
+                if (itemstack1.getCount() > 1) {
+                    playerinventory.splitStack(i, 1);
+                } else {
+                    playerinventory.splitWithoutUpdate(i);
+                }
+
+                itemstack1.setCount(1);
+                if (slot.getItem().isEmpty()) {
+                    slot.set(itemstack1);
+                } else {
+                    slot.getItem().add(1);
+                }
+
+            }
+        }
+    }
+
+    private boolean c() {
+        PlayerInventory playerinventory = this.c.inventory;
+
+        for (int i = 0; i < this.g.getSize(); ++i) {
+            ItemStack itemstack = this.g.getItem(i);
+
+            if (!itemstack.isEmpty()) {
+                int j = playerinventory.firstPartial(itemstack);
+
+                if (j == -1) {
+                    j = playerinventory.getFirstEmptySlotIndex();
+                }
+
+                if (j == -1) {
+                    return false;
+                }
+            }
+        }
+
+        return true;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/AutoRecipeStackManager.java b/src/main/java/net/minecraft/server/AutoRecipeStackManager.java
new file mode 100644
index 00000000..479f02b8
--- /dev/null
+++ b/src/main/java/net/minecraft/server/AutoRecipeStackManager.java
@@ -0,0 +1,323 @@
+package net.minecraft.server;
+
+import com.google.common.collect.Lists;
+import it.unimi.dsi.fastutil.ints.Int2IntMap;
+import it.unimi.dsi.fastutil.ints.Int2IntOpenHashMap;
+import it.unimi.dsi.fastutil.ints.IntAVLTreeSet;
+import it.unimi.dsi.fastutil.ints.IntArrayList;
+import it.unimi.dsi.fastutil.ints.IntIterator;
+import it.unimi.dsi.fastutil.ints.IntList;
+import it.unimi.dsi.fastutil.ints.IntListIterator;
+import java.util.BitSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.function.Predicate;
+import javax.annotation.Nullable;
+
+public class AutoRecipeStackManager { //OilSpigot TODO: remove doesnt seem to be needed
+
+    public final Int2IntMap a = new Int2IntOpenHashMap();
+
+    public AutoRecipeStackManager() {}
+
+    public void a(ItemStack itemstack) {
+        if (!itemstack.isEmpty() && !itemstack.h() && !itemstack.hasEnchantments() && !itemstack.hasName()) {
+            int i = b(itemstack);
+            int j = itemstack.getCount();
+
+            this.b(i, j);
+        }
+
+    }
+
+    public static int b(ItemStack itemstack) {
+        Item item = itemstack.getItem();
+        int i = item.k() ? itemstack.getData() : 0;
+
+        //OilSpigot fix decompile error
+        return Item.REGISTRY.a(item) << 16 | i & '\uffff';
+    }
+
+    public boolean a(int i) {
+        return this.a.get(i) > 0;
+    }
+
+    public int a(int i, int j) {
+        int k = this.a.get(i);
+
+        if (k >= j) {
+            this.a.put(i, k - j);
+            return i;
+        } else {
+            return 0;
+        }
+    }
+
+    private void b(int i, int j) {
+        this.a.put(i, this.a.get(i) + j);
+    }
+
+    public boolean a(IRecipe irecipe, @Nullable IntList intlist) {
+        return this.a(irecipe, intlist, 1);
+    }
+
+    public boolean a(IRecipe irecipe, @Nullable IntList intlist, int i) {
+        return (new a(irecipe)).a(i, intlist);
+    }
+
+    public int b(IRecipe irecipe, @Nullable IntList intlist) {
+        return this.a(irecipe, Integer.MAX_VALUE, intlist);
+    }
+
+    public int a(IRecipe irecipe, int i, @Nullable IntList intlist) {
+        return (new a(irecipe)).b(i, intlist);
+    }
+
+    public static ItemStack b(int i) {
+        return i == 0 ? ItemStack.a : new ItemStack(Item.getById(i >> 16 & '\uffff'), 1, i & '\uffff');
+    }
+
+    public void a() {
+        this.a.clear();
+    }
+
+    class a {
+
+        private final IRecipe b;
+        private final List<RecipeItemStack> c = Lists.newArrayList();
+        private final int d;
+        private final int[] e;
+        private final int f;
+        private final BitSet g;
+        private IntList h = new IntArrayList();
+
+        public a(IRecipe irecipe) {
+            this.b = irecipe;
+            this.c.addAll(irecipe.d());
+            this.c.removeIf((var0) -> {
+                return var0 == RecipeItemStack.a; //OilSpigot fix decompile error
+            });
+            this.d = this.c.size();
+            this.e = this.a();
+            this.f = this.e.length;
+            this.g = new BitSet(this.d + this.f + this.d + this.d * this.f);
+
+            for (int i = 0; i < this.c.size(); ++i) {
+                IntList intlist = ((RecipeItemStack) this.c.get(i)).b();
+
+                for (int j = 0; j < this.f; ++j) {
+                    if (intlist.contains(this.e[j])) {
+                        this.g.set(this.d(true, j, i));
+                    }
+                }
+            }
+
+        }
+
+        public boolean a(int i, @Nullable IntList intlist) {
+            if (i <= 0) {
+                return true;
+            } else {
+                int j;
+
+                for (j = 0; this.a(i); ++j) {
+                    AutoRecipeStackManager.this.a(this.e[this.h.getInt(0)], i);
+                    int k = this.h.size() - 1;
+
+                    this.c(this.h.getInt(k));
+
+                    for (int l = 0; l < k; ++l) {
+                        this.c((l & 1) == 0, ((Integer) this.h.get(l)).intValue(), ((Integer) this.h.get(l + 1)).intValue());
+                    }
+
+                    this.h.clear();
+                    this.g.clear(0, this.d + this.f);
+                }
+
+                boolean flag = j == this.d;
+                boolean flag1 = flag && intlist != null;
+
+                if (flag1) {
+                    intlist.clear();
+                }
+
+                this.g.clear(0, this.d + this.f + this.d);
+                int i1 = 0;
+                NonNullList nonnulllist = this.b.d();
+
+                for (int j1 = 0; j1 < nonnulllist.size(); ++j1) {
+                    if (flag1 && nonnulllist.get(j1) == RecipeItemStack.a) {
+                        intlist.add(0);
+                    } else {
+                        for (int k1 = 0; k1 < this.f; ++k1) {
+                            if (this.b(false, i1, k1)) {
+                                this.c(true, k1, i1);
+                                AutoRecipeStackManager.this.b(this.e[k1], i);
+                                if (flag1) {
+                                    intlist.add(this.e[k1]);
+                                }
+                            }
+                        }
+
+                        ++i1;
+                    }
+                }
+
+                return flag;
+            }
+        }
+
+        private int[] a() {
+            IntAVLTreeSet intavltreeset = new IntAVLTreeSet();
+            Iterator iterator = this.c.iterator();
+
+            while (iterator.hasNext()) {
+                RecipeItemStack recipeitemstack = (RecipeItemStack) iterator.next();
+
+                intavltreeset.addAll(recipeitemstack.b());
+            }
+
+            IntIterator intiterator = intavltreeset.iterator();
+
+            while (intiterator.hasNext()) {
+                if (!AutoRecipeStackManager.this.a(intiterator.nextInt())) {
+                    intiterator.remove();
+                }
+            }
+
+            return intavltreeset.toIntArray();
+        }
+
+        private boolean a(int i) {
+            int j = this.f;
+
+            for (int k = 0; k < j; ++k) {
+                if (AutoRecipeStackManager.this.a.get(this.e[k]) >= i) {
+                    this.a(false, k);
+
+                    while (!this.h.isEmpty()) {
+                        int l = this.h.size();
+                        boolean flag = (l & 1) == 1;
+                        int i1 = this.h.getInt(l - 1);
+
+                        if (!flag && !this.b(i1)) {
+                            break;
+                        }
+
+                        int j1 = flag ? this.d : j;
+
+                        int k1;
+
+                        for (k1 = 0; k1 < j1; ++k1) {
+                            if (!this.b(flag, k1) && this.a(flag, i1, k1) && this.b(flag, i1, k1)) {
+                                this.a(flag, k1);
+                                break;
+                            }
+                        }
+
+                        k1 = this.h.size();
+                        if (k1 == l) {
+                            this.h.removeInt(k1 - 1);
+                        }
+                    }
+
+                    if (!this.h.isEmpty()) {
+                        return true;
+                    }
+                }
+            }
+
+            return false;
+        }
+
+        private boolean b(int i) {
+            return this.g.get(this.d(i));
+        }
+
+        private void c(int i) {
+            this.g.set(this.d(i));
+        }
+
+        private int d(int i) {
+            return this.d + this.f + i;
+        }
+
+        private boolean a(boolean flag, int i, int j) {
+            return this.g.get(this.d(flag, i, j));
+        }
+
+        private boolean b(boolean flag, int i, int j) {
+            return flag != this.g.get(1 + this.d(flag, i, j));
+        }
+
+        private void c(boolean flag, int i, int j) {
+            this.g.flip(1 + this.d(flag, i, j));
+        }
+
+        private int d(boolean flag, int i, int j) {
+            int k = flag ? i * this.d + j : j * this.d + i;
+
+            return this.d + this.f + this.d + 2 * k;
+        }
+
+        private void a(boolean flag, int i) {
+            this.g.set(this.c(flag, i));
+            this.h.add(i);
+        }
+
+        private boolean b(boolean flag, int i) {
+            return this.g.get(this.c(flag, i));
+        }
+
+        private int c(boolean flag, int i) {
+            return (flag ? 0 : this.d) + i;
+        }
+
+        public int b(int i, @Nullable IntList intlist) {
+            int j = 0;
+            int k = Math.min(i, this.b()) + 1;
+
+            while (true) {
+                while (true) {
+                    int l = (j + k) / 2;
+
+                    if (this.a(l, (IntList) null)) {
+                        if (k - j <= 1) {
+                            if (l > 0) {
+                                this.a(l, intlist);
+                            }
+
+                            return l;
+                        }
+
+                        j = l;
+                    } else {
+                        k = l;
+                    }
+                }
+            }
+        }
+
+        private int b() {
+            int i = Integer.MAX_VALUE;
+            Iterator iterator = this.c.iterator();
+
+            while (iterator.hasNext()) {
+                RecipeItemStack recipeitemstack = (RecipeItemStack) iterator.next();
+                int j = 0;
+
+                int k;
+
+                for (IntListIterator intlistiterator = recipeitemstack.b().iterator(); intlistiterator.hasNext(); j = Math.max(j, AutoRecipeStackManager.this.a.get(k))) {
+                    k = ((Integer) intlistiterator.next()).intValue();
+                }
+
+                if (i > 0) {
+                    i = Math.min(i, j);
+                }
+            }
+
+            return i;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Block.java b/src/main/java/net/minecraft/server/Block.java
index 3e2f5264..448fb687 100644
--- a/src/main/java/net/minecraft/server/Block.java
+++ b/src/main/java/net/minecraft/server/Block.java
@@ -8,6 +8,10 @@ import java.util.List;
 import java.util.Random;
 import javax.annotation.Nullable;
 
+//OilSpigot start
+import java.util.ArrayList;
+//OilSpigot end
+
 public class Block {
 
     private static final MinecraftKey a = new MinecraftKey("air");
@@ -351,6 +355,21 @@ public class Block {
         this.dropNaturally(world, blockposition, iblockdata, 1.0F, i);
     }
 
+
+
+    //OilSpigot start
+    private static List<ItemStack> dropCatcherList;
+    private static  BlockPosition dropCatcherListBlockposition;
+    public ItemStack[] getDrops(World world, BlockPosition blockposition, IBlockData iblockdata, int fortuneLvl) {
+        dropCatcherList = new ArrayList<>();
+        dropCatcherListBlockposition = blockposition;
+        b(world, blockposition, iblockdata, fortuneLvl);
+        ItemStack[] result = dropCatcherList.toArray(new ItemStack[dropCatcherList.size()]);
+        dropCatcherList = null;
+        return result;
+    }
+    //OilSpigot end
+
     public void dropNaturally(World world, BlockPosition blockposition, IBlockData iblockdata, float f, int i) {
         if (!world.isClientSide) {
             int j = this.getDropCount(i, world.random);
@@ -370,6 +389,12 @@ public class Block {
     }
 
     public static void a(World world, BlockPosition blockposition, ItemStack itemstack) {
+        //OilSpigot start
+        if (dropCatcherList != null && blockposition.equals(dropCatcherListBlockposition)) {
+            dropCatcherList.add(itemstack);
+            return;
+        }
+        //OilSpigot end
         if (!world.isClientSide && !itemstack.isEmpty() && world.getGameRules().getBoolean("doTileDrops")) {
             float f = 0.5F;
             double d0 = (double) (world.random.nextFloat() * 0.5F) + 0.25D;
@@ -481,6 +506,13 @@ public class Block {
 
     }
 
+
+
+    //OilSpigot start
+    public ItemStack getDropSilktouch(IBlockData iblockdata) {
+        return u(iblockdata);
+    }
+    //OilSpigot end
     protected boolean n() {
         return this.getBlockData().g() && !this.isTileEntity;
     }
@@ -967,6 +999,23 @@ public class Block {
             }
         }
 
+        //OilSpigot start - set hardness
+        Blocks.COAL_ORE.hardness(0);
+        Blocks.COAL_BLOCK.hardness(0);
+        Blocks.IRON_ORE.hardness(1);
+        Blocks.IRON_BLOCK.hardness(1);
+        Blocks.LAPIS_ORE.hardness(1);
+        Blocks.LAPIS_BLOCK.hardness(1);
+        Blocks.REDSTONE_ORE.hardness(2);
+        Blocks.LIT_REDSTONE_ORE.hardness(2);
+        Blocks.GOLD_ORE.hardness(2);
+        Blocks.GOLD_BLOCK.hardness(2);
+        Blocks.EMERALD_ORE.hardness(2);
+        Blocks.EMERALD_BLOCK.hardness(2);
+        Blocks.DIAMOND_ORE.hardness(2);
+        Blocks.DIAMOND_BLOCK.hardness(2);
+        Blocks.OBSIDIAN.hardness(3);
+        //OilSpigot end
     }
 
     // CraftBukkit start
@@ -995,6 +1044,20 @@ public class Block {
     }
     // Spigot end
 
+    //OilSpigot start
+    public boolean isVanilla() {
+        return true;
+    }
+
+    private int hardness = -1;
+    public int getHardness() {return hardness;}
+
+    public Block hardness(int hardness) {
+        this.hardness = hardness;
+        return this;
+    }
+    //OilSpigot end
+
     public static enum EnumRandomOffset {
 
         NONE, XZ, XYZ;
diff --git a/src/main/java/net/minecraft/server/BlockJukeBox.java b/src/main/java/net/minecraft/server/BlockJukeBox.java
index 59c9a0f5..9bc29718 100644
--- a/src/main/java/net/minecraft/server/BlockJukeBox.java
+++ b/src/main/java/net/minecraft/server/BlockJukeBox.java
@@ -120,7 +120,8 @@ public class BlockJukeBox extends BlockTileEntity {
         public void load(NBTTagCompound nbttagcompound) {
             super.load(nbttagcompound);
             if (nbttagcompound.hasKeyOfType("RecordItem", 10)) {
-                this.setRecord(new ItemStack(nbttagcompound.getCompound("RecordItem")));
+                //OilSpigot use factory method
+                this.setRecord(ItemStack.createStack(nbttagcompound.getCompound("RecordItem")));
             } else if (nbttagcompound.getInt("Record") > 0) {
                 this.setRecord(new ItemStack(Item.getById(nbttagcompound.getInt("Record"))));
             }
diff --git a/src/main/java/net/minecraft/server/BlockPackedIce.java b/src/main/java/net/minecraft/server/BlockPackedIce.java
new file mode 100644
index 00000000..7ef39cec
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BlockPackedIce.java
@@ -0,0 +1,16 @@
+package net.minecraft.server;
+
+import java.util.Random;
+
+public class BlockPackedIce extends Block {
+
+    public BlockPackedIce() {
+        super(Material.PACKED_ICE); //OilSpigot fixed spigot namings
+        this.frictionFactor = 0.98F;
+        this.a(CreativeModeTab.b);
+    }
+
+    public int a(Random random) {
+        return 0;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/BlockSnow.java b/src/main/java/net/minecraft/server/BlockSnow.java
index 04721124..97466324 100644
--- a/src/main/java/net/minecraft/server/BlockSnow.java
+++ b/src/main/java/net/minecraft/server/BlockSnow.java
@@ -9,7 +9,7 @@ public class BlockSnow extends Block {
     protected static final AxisAlignedBB[] b = new AxisAlignedBB[] { new AxisAlignedBB(0.0D, 0.0D, 0.0D, 1.0D, 0.0D, 1.0D), new AxisAlignedBB(0.0D, 0.0D, 0.0D, 1.0D, 0.125D, 1.0D), new AxisAlignedBB(0.0D, 0.0D, 0.0D, 1.0D, 0.25D, 1.0D), new AxisAlignedBB(0.0D, 0.0D, 0.0D, 1.0D, 0.375D, 1.0D), new AxisAlignedBB(0.0D, 0.0D, 0.0D, 1.0D, 0.5D, 1.0D), new AxisAlignedBB(0.0D, 0.0D, 0.0D, 1.0D, 0.625D, 1.0D), new AxisAlignedBB(0.0D, 0.0D, 0.0D, 1.0D, 0.75D, 1.0D), new AxisAlignedBB(0.0D, 0.0D, 0.0D, 1.0D, 0.875D, 1.0D), new AxisAlignedBB(0.0D, 0.0D, 0.0D, 1.0D, 1.0D, 1.0D)};
 
     protected BlockSnow() {
-        super(Material.PACKED_ICE);
+        super(Material.SNOW_LAYER); //OilSpigot fixed spigot namings
         this.w(this.blockStateList.getBlockData().set(BlockSnow.LAYERS, Integer.valueOf(1)));
         this.a(true);
         this.a(CreativeModeTab.c);
diff --git a/src/main/java/net/minecraft/server/BlockTallPlant.java b/src/main/java/net/minecraft/server/BlockTallPlant.java
index e3ebf6fc..7a1cb2a5 100644
--- a/src/main/java/net/minecraft/server/BlockTallPlant.java
+++ b/src/main/java/net/minecraft/server/BlockTallPlant.java
@@ -1,5 +1,7 @@
 package net.minecraft.server;
 
+import org.oilmod.spigot.items.ItemUtil;
+
 import java.util.Random;
 import javax.annotation.Nullable;
 
@@ -107,7 +109,8 @@ public class BlockTallPlant extends BlockPlant implements IBlockFragilePlantElem
     }
 
     public void a(World world, EntityHuman entityhuman, BlockPosition blockposition, IBlockData iblockdata, @Nullable TileEntity tileentity, ItemStack itemstack) {
-        if (world.isClientSide || itemstack.getItem() != Items.SHEARS || iblockdata.get(BlockTallPlant.HALF) != BlockTallPlant.EnumTallPlantHalf.LOWER || !this.b(world, blockposition, iblockdata, entityhuman)) {
+        //OilSpigot allow modded shears
+        if (world.isClientSide || !ItemUtil.isShears(itemstack.getItem()) || iblockdata.get(BlockTallPlant.HALF) != BlockTallPlant.EnumTallPlantHalf.LOWER || !this.b(world, blockposition, iblockdata, entityhuman)) {
             super.a(world, entityhuman, blockposition, iblockdata, tileentity, itemstack);
         }
     }
@@ -125,7 +128,8 @@ public class BlockTallPlant extends BlockPlant implements IBlockFragilePlantElem
                         world.setAir(blockposition.down(), true);
                     } else if (world.isClientSide) {
                         world.setAir(blockposition.down());
-                    } else if (!entityhuman.getItemInMainHand().isEmpty() && entityhuman.getItemInMainHand().getItem() == Items.SHEARS) {
+                        //OilSpigot allow modded shears
+                    } else if (!entityhuman.getItemInMainHand().isEmpty() && ItemUtil.isShears(entityhuman.getItemInMainHand().getItem())) {
                         this.b(world, blockposition, iblockdata1, entityhuman);
                         world.setAir(blockposition.down());
                     } else {
diff --git a/src/main/java/net/minecraft/server/BlockTripwire.java b/src/main/java/net/minecraft/server/BlockTripwire.java
index 92bd3c0e..3d77609e 100644
--- a/src/main/java/net/minecraft/server/BlockTripwire.java
+++ b/src/main/java/net/minecraft/server/BlockTripwire.java
@@ -6,6 +6,7 @@ import java.util.Random;
 import javax.annotation.Nullable;
 
 import org.bukkit.event.entity.EntityInteractEvent; // CraftBukkit
+import org.oilmod.spigot.items.ItemUtil;
 
 public class BlockTripwire extends Block {
 
@@ -65,7 +66,8 @@ public class BlockTripwire extends Block {
 
     public void a(World world, BlockPosition blockposition, IBlockData iblockdata, EntityHuman entityhuman) {
         if (!world.isClientSide) {
-            if (!entityhuman.getItemInMainHand().isEmpty() && entityhuman.getItemInMainHand().getItem() == Items.SHEARS) {
+            //OilSpigot allow modded shears
+            if (!entityhuman.getItemInMainHand().isEmpty() && ItemUtil.isShears(entityhuman.getItemInMainHand().getItem())) {
                 world.setTypeAndData(blockposition, iblockdata.set(BlockTripwire.DISARMED, Boolean.valueOf(true)), 4);
             }
 
diff --git a/src/main/java/net/minecraft/server/BlockVine.java b/src/main/java/net/minecraft/server/BlockVine.java
index ac5b639a..533b411a 100644
--- a/src/main/java/net/minecraft/server/BlockVine.java
+++ b/src/main/java/net/minecraft/server/BlockVine.java
@@ -5,6 +5,7 @@ import java.util.Random;
 import javax.annotation.Nullable;
 
 import org.bukkit.craftbukkit.event.CraftEventFactory; // CraftBukkit
+import org.oilmod.spigot.items.ItemUtil;
 
 public class BlockVine extends Block {
 
@@ -299,7 +300,8 @@ public class BlockVine extends Block {
     }
 
     public void a(World world, EntityHuman entityhuman, BlockPosition blockposition, IBlockData iblockdata, @Nullable TileEntity tileentity, ItemStack itemstack) {
-        if (!world.isClientSide && itemstack.getItem() == Items.SHEARS) {
+        //OilSpigot allow modded shears
+        if (!world.isClientSide && ItemUtil.isShears(itemstack.getItem())) {
             entityhuman.b(StatisticList.a((Block) this));
             a(world, blockposition, new ItemStack(Blocks.VINE, 1, 0));
         } else {
diff --git a/src/main/java/net/minecraft/server/BukkitIInventory.java b/src/main/java/net/minecraft/server/BukkitIInventory.java
new file mode 100644
index 00000000..a850ed4a
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BukkitIInventory.java
@@ -0,0 +1,10 @@
+package net.minecraft.server;
+
+import org.bukkit.craftbukkit.inventory.CraftInventory;
+
+/**
+ * Added by OilSpigot
+ */
+public interface BukkitIInventory extends IInventory {
+    CraftInventory getBukkitInventory();
+}
diff --git a/src/main/java/net/minecraft/server/CommandGamemode.java b/src/main/java/net/minecraft/server/CommandGamemode.java
index 11f05770..3da4baf6 100644
--- a/src/main/java/net/minecraft/server/CommandGamemode.java
+++ b/src/main/java/net/minecraft/server/CommandGamemode.java
@@ -1,5 +1,6 @@
 package net.minecraft.server;
 
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 import javax.annotation.Nullable;
@@ -21,31 +22,61 @@ public class CommandGamemode extends CommandAbstract {
     }
 
     public void execute(MinecraftServer minecraftserver, ICommandListener icommandlistener, String[] astring) throws CommandException {
-        if (astring.length <= 0) {
-            throw new ExceptionUsage("commands.gamemode.usage", new Object[0]);
-        } else {
-            EnumGamemode enumgamemode = this.c(icommandlistener, astring[0]);
-            EntityPlayer entityplayer = astring.length >= 2 ? b(minecraftserver, icommandlistener, astring[1]) : a(icommandlistener);
-
-            entityplayer.a(enumgamemode);
-            // CraftBukkit start - handle event cancelling the change
-            if (entityplayer.playerInteractManager.getGameMode() != enumgamemode) {
-                icommandlistener.sendMessage(new ChatComponentText("Failed to set the gamemode of '" + entityplayer.getName() + "'"));
-                return;
+        //OilSpigot start
+        if (!(icommandlistener instanceof EntityPlayer) && astring.length<1){
+            throw new ExceptionUsage("commands.gamemode.usage");
+        }
+        EntityPlayer entityplayer = null;
+        EnumGamemode enumgamemode = null;
+        if (astring.length == 0) {
+            entityplayer = a(icommandlistener);
+            enumgamemode = entityplayer.playerInteractManager.getGameMode()==EnumGamemode.SURVIVAL?EnumGamemode.CREATIVE: EnumGamemode.SURVIVAL;
+        } else if (astring.length == 1) {
+            try {
+                enumgamemode = this.c(icommandlistener, astring[0]);
+                entityplayer = a(icommandlistener);
+            } catch (CommandException e1) {
+                try {
+                    entityplayer = b(minecraftserver, icommandlistener, astring[0]);
+                    enumgamemode = entityplayer.playerInteractManager.getGameMode()==EnumGamemode.SURVIVAL?EnumGamemode.CREATIVE: EnumGamemode.SURVIVAL;
+                } catch (ExceptionPlayerNotFound e) {
+                    this.c(icommandlistener, astring[0]); //not a valid player -> throw gamemode exception instant
+                }
             }
-            // CraftBukkit end
-            ChatMessage chatmessage = new ChatMessage("gameMode." + enumgamemode.b(), new Object[0]);
+        } else {
+            entityplayer = b(minecraftserver, icommandlistener, astring[1]);
+            enumgamemode = this.c(icommandlistener, astring[0]);
+        }
 
-            if (icommandlistener.getWorld().getGameRules().getBoolean("sendCommandFeedback")) {
-                entityplayer.sendMessage(new ChatMessage("gameMode.changed", new Object[] { chatmessage}));
-            }
+        if (entityplayer == null ||enumgamemode==null) {
+            System.out.println("GamemodeCommand. error! data=" + (entityplayer==null) + ", " + (enumgamemode==null));
+            throw new CommandException("Something went wrong :/");
+        }
+        //OilSpigot end
 
-            if (entityplayer == icommandlistener) {
-                a(icommandlistener, this, 1, "commands.gamemode.success.self", new Object[] { chatmessage});
-            } else {
-                a(icommandlistener, this, 1, "commands.gamemode.success.other", new Object[] { entityplayer.getName(), chatmessage});
-            }
+        entityplayer.a(enumgamemode);
+        // CraftBukkit start - handle event cancelling the change
+        if (entityplayer.playerInteractManager.getGameMode() != enumgamemode) {
+            icommandlistener.sendMessage(new ChatComponentText("Failed to set the gamemode of '" + entityplayer.getName() + "'"));
+            return;
+        }
+        // CraftBukkit end
+
+        //OilSpigot start
+        entityplayer.fallDistance = 0.0F;
+        //OilSpigot end
 
+        ChatMessage chatmessage = new ChatMessage("gameMode." + enumgamemode.b(), new Object[0]);
+
+
+        if (icommandlistener.getWorld().getGameRules().getBoolean("sendCommandFeedback")) {
+            entityplayer.sendMessage(new ChatMessage("gameMode.changed", new Object[] { chatmessage}));
+        }
+
+        if (entityplayer == icommandlistener) {
+            a(icommandlistener, this, 1, "commands.gamemode.success.self", new Object[] { chatmessage});
+        } else {
+            a(icommandlistener, this, 1, "commands.gamemode.success.other", new Object[] { entityplayer.getName(), chatmessage});
         }
     }
 
@@ -69,4 +100,12 @@ public class CommandGamemode extends CommandAbstract {
         return a((ICommand) o);
     }
     // CraftBukkit end
+
+    //OilSpigot start
+    private final List<String> aliases = Arrays.asList("gm"); //added gm alias
+    @Override
+    public List<String> getAliases() {
+        return getClass()==CommandGamemode.class?aliases:super.getAliases(); //needed because of defaultGamemode command
+    }
+    //OilSpigot end
 }
diff --git a/src/main/java/net/minecraft/server/CommandGive.java b/src/main/java/net/minecraft/server/CommandGive.java
new file mode 100644
index 00000000..701470a5
--- /dev/null
+++ b/src/main/java/net/minecraft/server/CommandGive.java
@@ -0,0 +1,93 @@
+package net.minecraft.server;
+
+import org.oilmod.spigot.items.ItemUtil;
+
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+import javax.annotation.Nullable;
+
+//OilSpigot KEEPSYNC
+public class CommandGive extends CommandAbstract {
+
+    public CommandGive() {}
+
+    public String getCommand() {
+        return "give";
+    }
+
+    public int a() {
+        return 2;
+    }
+
+    public String getUsage(ICommandListener icommandlistener) {
+        return "commands.give.usage";
+    }
+
+    public void execute(MinecraftServer minecraftserver, ICommandListener icommandlistener, String[] astring) throws CommandException {
+        if (astring.length < 2) {
+            throw new ExceptionUsage("commands.give.usage", new Object[0]);
+        } else {
+            EntityPlayer entityplayer = b(minecraftserver, icommandlistener, astring[0]);
+            Item item = a(icommandlistener, astring[1]);
+            int i = astring.length >= 3 ? a(astring[2], 1, item.getMaxStackSize()) : 1;
+            int j = astring.length >= 4 ? a(astring[3]) : 0;
+
+            //OilSpigot use ItemUtil
+            ItemStack itemstack = ItemUtil.createNew(entityplayer, item, i, j);
+
+            if (astring.length >= 5) {
+                String s = a(astring, 4);
+
+                try {
+                    itemstack.setTag(MojangsonParser.parse(s));
+                } catch (MojangsonParseException mojangsonparseexception) {
+                    throw new CommandException("commands.give.tagError", new Object[] { mojangsonparseexception.getMessage()});
+                }
+            }
+
+            boolean flag = entityplayer.inventory.pickup(itemstack);
+
+            if (flag) {
+                entityplayer.world.a((EntityHuman) null, entityplayer.locX, entityplayer.locY, entityplayer.locZ, SoundEffects.dx, SoundCategory.PLAYERS, 0.2F, ((entityplayer.getRandom().nextFloat() - entityplayer.getRandom().nextFloat()) * 0.7F + 1.0F) * 2.0F);
+                entityplayer.defaultContainer.b();
+            }
+
+            EntityItem entityitem;
+
+            if (flag && itemstack.isEmpty()) {
+                itemstack.setCount(1);
+                icommandlistener.a(CommandObjectiveExecutor.EnumCommandResult.AFFECTED_ITEMS, i);
+                entityitem = entityplayer.drop(itemstack, false);
+                if (entityitem != null) {
+                    entityitem.w();
+                }
+            } else {
+                icommandlistener.a(CommandObjectiveExecutor.EnumCommandResult.AFFECTED_ITEMS, i - itemstack.getCount());
+                entityitem = entityplayer.drop(itemstack, false);
+                if (entityitem != null) {
+                    entityitem.r();
+                    entityitem.d(entityplayer.getName());
+                }
+            }
+
+            a(icommandlistener, (ICommand) this, "commands.give.success", new Object[] { itemstack.C(), Integer.valueOf(i), entityplayer.getName()});
+        }
+    }
+
+    public List<String> tabComplete(MinecraftServer minecraftserver, ICommandListener icommandlistener, String[] astring, @Nullable BlockPosition blockposition) {
+        return astring.length == 1 ? a(astring, minecraftserver.getPlayers()) : (astring.length == 2 ? a(astring, (Collection) Item.REGISTRY.keySet()) : Collections.emptyList());
+    }
+
+    public boolean isListStart(String[] astring, int i) {
+        return i == 0;
+    }
+
+
+    // OilSpigot start - fix decompiler error
+    @Override
+    public int compareTo(ICommand o) {
+        return a((ICommand) o);
+    }
+    // OilSpigot end
+}
diff --git a/src/main/java/net/minecraft/server/CommandRecipe.java b/src/main/java/net/minecraft/server/CommandRecipe.java
new file mode 100644
index 00000000..ae733a5d
--- /dev/null
+++ b/src/main/java/net/minecraft/server/CommandRecipe.java
@@ -0,0 +1,104 @@
+package net.minecraft.server;
+
+import com.google.common.collect.Lists;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.List;
+import javax.annotation.Nullable;
+
+public class CommandRecipe extends CommandAbstract {
+
+    public CommandRecipe() {}
+
+    public String getCommand() {
+        return "recipe";
+    }
+
+    public int a() {
+        return 2;
+    }
+
+    public String getUsage(ICommandListener icommandlistener) {
+        return "commands.recipe.usage";
+    }
+
+    public void execute(MinecraftServer minecraftserver, ICommandListener icommandlistener, String[] astring) throws CommandException {
+        if (astring.length < 2) {
+            throw new ExceptionUsage("commands.recipe.usage", new Object[0]);
+        } else {
+            boolean flag = "give".equalsIgnoreCase(astring[0]);
+            boolean flag1 = "take".equalsIgnoreCase(astring[0]);
+
+            if (!flag && !flag1) {
+                throw new ExceptionUsage("commands.recipe.usage", new Object[0]);
+            } else {
+                List list = a(minecraftserver, icommandlistener, astring[1]);
+                Iterator iterator = list.iterator();
+
+                while (iterator.hasNext()) {
+                    EntityPlayer entityplayer = (EntityPlayer) iterator.next();
+
+                    if ("*".equals(astring[2])) {
+                        if (flag) {
+                            entityplayer.a(this.d());
+                            a(icommandlistener, (ICommand) this, "commands.recipe.give.success.all", new Object[] { entityplayer.getName()});
+                        } else {
+                            entityplayer.b(this.d());
+                            a(icommandlistener, (ICommand) this, "commands.recipe.take.success.all", new Object[] { entityplayer.getName()});
+                        }
+                    } else {
+                        //OilSpigot use getByKey
+                        IRecipe irecipe = CraftingManager.getByKey(new MinecraftKey(astring[2]));
+
+                        if (irecipe == null) {
+                            throw new CommandException("commands.recipe.unknownrecipe", new Object[] { astring[2]});
+                        }
+
+                        if (irecipe.c()) {
+                            throw new CommandException("commands.recipe.unsupported", new Object[] { astring[2]});
+                        }
+
+                        //OilSpigot add generics
+                        ArrayList<IRecipe> arraylist = Lists.newArrayList(new IRecipe[] { irecipe});
+
+                        if (flag == entityplayer.F().b(irecipe)) {
+                            String s = flag ? "commands.recipe.alreadyHave" : "commands.recipe.dontHave";
+
+                            throw new CommandException(s, new Object[] { entityplayer.getName(), irecipe.b().getName()});
+                        }
+
+                        if (flag) {
+                            //OilSpigot remove unnecessary cast (compile error)
+                            entityplayer.a(arraylist);
+                            a(icommandlistener, (ICommand) this, "commands.recipe.give.success.one", new Object[] { entityplayer.getName(), irecipe.b().getName()});
+                        } else {
+                            entityplayer.b((List) arraylist);
+                            a(icommandlistener, (ICommand) this, "commands.recipe.take.success.one", new Object[] { irecipe.b().getName(), entityplayer.getName()});
+                        }
+                    }
+                }
+
+            }
+        }
+    }
+
+    private List<IRecipe> d() {
+        //OilSpigot use getAllRecipes
+        return Lists.newArrayList(CraftingManager.getAllRecipes());
+    }
+
+    public List<String> tabComplete(MinecraftServer minecraftserver, ICommandListener icommandlistener, String[] astring, @Nullable BlockPosition blockposition) {
+
+        //OilSpigot use getAllKeys
+        return astring.length == 1 ? a(astring, new String[] { "give", "take"}) : (astring.length == 2 ? a(astring, minecraftserver.getPlayers()) : (astring.length == 3 ? a(astring, (Collection) CraftingManager.getAllKeys()) : Collections.emptyList()));
+    }
+
+    //OilSpigot start - fix decompiler error
+    @Override
+    public int compareTo(ICommand o) {
+        return a((ICommand) o);
+    }
+    //OilSpigot end
+}
diff --git a/src/main/java/net/minecraft/server/CommandTp.java b/src/main/java/net/minecraft/server/CommandTp.java
index aa8eb2ea..07549f10 100644
--- a/src/main/java/net/minecraft/server/CommandTp.java
+++ b/src/main/java/net/minecraft/server/CommandTp.java
@@ -5,6 +5,10 @@ import java.util.EnumSet;
 import java.util.List;
 import javax.annotation.Nullable;
 
+//OilSpigot start
+import java.util.Arrays;
+//OilSpigot end
+
 public class CommandTp extends CommandAbstract {
 
     public CommandTp() {}
diff --git a/src/main/java/net/minecraft/server/Container.java b/src/main/java/net/minecraft/server/Container.java
index 3a488ce2..2a86598b 100644
--- a/src/main/java/net/minecraft/server/Container.java
+++ b/src/main/java/net/minecraft/server/Container.java
@@ -10,18 +10,27 @@ import javax.annotation.Nullable;
 // CraftBukkit start
 import java.util.HashMap;
 import java.util.Map;
+
 import org.bukkit.craftbukkit.inventory.CraftInventory;
 import org.bukkit.craftbukkit.inventory.CraftItemStack;
+import org.bukkit.event.Event;
 import org.bukkit.event.Event.Result;
 import org.bukkit.event.inventory.InventoryDragEvent;
 import org.bukkit.event.inventory.InventoryType;
 import org.bukkit.inventory.InventoryView;
 // CraftBukkit end
 
+//OilSpigot start
+import de.sirati97.spigot.optimisation.ItemStackFreeze;
+
+import net.minecraft.server.oilmod.IInventoryCraftResult;
+import net.minecraft.server.oilmod.IInventoryCrafting;
+//OilSpigot end
+
 public abstract class Container {
 
-    public NonNullList<ItemStack> items = NonNullList.a();
-    public List<Slot> slots = Lists.newArrayList();
+    public NonNullList<ItemStackFreeze> items = NonNullList.a(); //OilSpigot  PAIL public -> protected, use ItemStackFreeze
+    public List<Slot> slots = Lists.newArrayList(); //OilSpigot PAIL public -> protected
     public int windowId;
     private int dragType = -1;
     private int g;
@@ -47,7 +56,7 @@ public abstract class Container {
     protected Slot a(Slot slot) {
         slot.rawSlotIndex = this.slots.size();
         this.slots.add(slot);
-        this.items.add(ItemStack.a);
+        this.items.add(ItemStackFreeze.EMPTY);
         return slot;
     }
 
@@ -71,22 +80,34 @@ public abstract class Container {
         return nonnulllist;
     }
 
-    public void b() {
+
+    //OilSpigot b -> update
+    public void b() {//OilSpigot - needed for comparability reasons
+        update();
+    }
+
+    public boolean update() { //OilSpigot changed result to boolean
+        boolean result = false;
         for (int i = 0; i < this.slots.size(); ++i) {
-            ItemStack itemstack = ((Slot) this.slots.get(i)).getItem();
-            ItemStack itemstack1 = (ItemStack) this.items.get(i);
+            //OilSpigot start
+            ItemStack itemstack = this.slots.get(i).getItem();
+            ItemStackFreeze freeze = this.items.get(i);
+
 
-            if (!ItemStack.fastMatches(itemstack1, itemstack) || (tickCount % org.spigotmc.SpigotConfig.itemDirtyTicks == 0 && !ItemStack.matches(itemstack1, itemstack))) { // Spigot
-                itemstack1 = itemstack.isEmpty() ? ItemStack.a : itemstack.cloneItemStack();
-                this.items.set(i, itemstack1);
+            if (!ItemStackFreeze.fastMatches(freeze, itemstack) || (tickCount % org.spigotmc.SpigotConfig.itemDirtyTicks == 0 && !ItemStackFreeze.matches(freeze, itemstack))) { // Spigot
+                result = true; //found something to update
+                freeze = itemstack.isEmpty()?ItemStackFreeze.EMPTY:itemstack.createFreeze();
+                this.items.set(i, freeze);
 
                 for (int j = 0; j < this.listeners.size(); ++j) {
-                    ((ICrafting) this.listeners.get(j)).a(this, i, itemstack1);
+                    ((ICrafting) this.listeners.get(j)).a(this, i, itemstack); //OilSpigot - Experiment: Itemstack isn't getting cloned anymore (This is unsafe because of multitasking)
                 }
             }
+            //OilSpigot end
         }
         tickCount++; // Spigot
 
+        return result;
     }
 
     public boolean a(EntityHuman entityhuman, int i) {
@@ -110,6 +131,12 @@ public abstract class Container {
         return (Slot) this.slots.get(i);
     }
 
+    //OilSpigot start
+    protected int hotbarSlotToPacketSlot(int i) {
+        return slots.size()-9+i;
+    }
+    //OilSpigot end
+
     public ItemStack shiftClick(EntityHuman entityhuman, int i) {
         Slot slot = (Slot) this.slots.get(i);
 
@@ -124,121 +151,35 @@ public abstract class Container {
         ItemStack itemstack2;
         int l;
 
-        if (inventoryclicktype == InventoryClickType.QUICK_CRAFT) {
-            int i1 = this.g;
-
-            this.g = c(j);
-            if ((i1 != 1 || this.g != 2) && i1 != this.g) {
-                this.d();
-            } else if (playerinventory.getCarried().isEmpty()) {
-                this.d();
-            } else if (this.g == 0) {
-                this.dragType = b(j);
-                if (a(this.dragType, entityhuman)) {
-                    this.g = 1;
-                    this.h.clear();
-                } else {
-                    this.d();
-                }
-            } else if (this.g == 1) {
-                Slot slot = i < this.slots.size() ? this.slots.get(i) : null; // Paper - Ensure drag in bounds
-
-                itemstack1 = playerinventory.getCarried();
-                if (slot != null && a(slot, itemstack1, true) && slot.isAllowed(itemstack1) && (this.dragType == 2 || itemstack1.getCount() > this.h.size()) && this.b(slot)) {
-                    this.h.add(slot);
-                }
-            } else if (this.g == 2) {
-                if (!this.h.isEmpty()) {
-                    itemstack2 = playerinventory.getCarried().cloneItemStack();
-                    l = playerinventory.getCarried().getCount();
-                    Iterator iterator = this.h.iterator();
-
-                    Map<Integer, ItemStack> draggedSlots = new HashMap<Integer, ItemStack>(); // CraftBukkit - Store slots from drag in map (raw slot id -> new stack)
-                    while (iterator.hasNext()) {
-                        Slot slot1 = (Slot) iterator.next();
-                        ItemStack itemstack3 = playerinventory.getCarried();
-
-                        if (slot1 != null && a(slot1, itemstack3, true) && slot1.isAllowed(itemstack3) && (this.dragType == 2 || itemstack3.getCount() >= this.h.size()) && this.b(slot1)) {
-                            ItemStack itemstack4 = itemstack2.cloneItemStack();
-                            int j1 = slot1.hasItem() ? slot1.getItem().getCount() : 0;
-
-                            a(this.h, this.dragType, itemstack4, j1);
-                            k = Math.min(itemstack4.getMaxStackSize(), slot1.getMaxStackSize(itemstack4));
-                            if (itemstack4.getCount() > k) {
-                                itemstack4.setCount(k);
-                            }
-
-                            l -= itemstack4.getCount() - j1;
-                            // slot1.set(itemstack4);
-                            draggedSlots.put(slot1.rawSlotIndex, itemstack4); // CraftBukkit - Put in map instead of setting
-                        }
-                    }
-
-                    // CraftBukkit start - InventoryDragEvent
-                    InventoryView view = getBukkitView();
-                    org.bukkit.inventory.ItemStack newcursor = CraftItemStack.asCraftMirror(itemstack2);
-                    newcursor.setAmount(l);
-                    Map<Integer, org.bukkit.inventory.ItemStack> eventmap = new HashMap<Integer, org.bukkit.inventory.ItemStack>();
-                    for (Map.Entry<Integer, ItemStack> ditem : draggedSlots.entrySet()) {
-                        eventmap.put(ditem.getKey(), CraftItemStack.asBukkitCopy(ditem.getValue()));
-                    }
-
-                    // It's essential that we set the cursor to the new value here to prevent item duplication if a plugin closes the inventory.
-                    ItemStack oldCursor = playerinventory.getCarried();
-                    playerinventory.setCarried(CraftItemStack.asNMSCopy(newcursor));
-
-                    InventoryDragEvent event = new InventoryDragEvent(view, (newcursor.getType() != org.bukkit.Material.AIR ? newcursor : null), CraftItemStack.asBukkitCopy(oldCursor), this.dragType == 1, eventmap);
-                    entityhuman.world.getServer().getPluginManager().callEvent(event);
 
-                    // Whether or not a change was made to the inventory that requires an update.
-                    boolean needsUpdate = event.getResult() != Result.DEFAULT;
-
-                    if (event.getResult() != Result.DENY) {
-                        for (Map.Entry<Integer, ItemStack> dslot : draggedSlots.entrySet()) {
-                            view.setItem(dslot.getKey(), CraftItemStack.asBukkitCopy(dslot.getValue()));
-                        }
-                        // The only time the carried item will be set to null is if the inventory is closed by the server.
-                        // If the inventory is closed by the server, then the cursor items are dropped.  This is why we change the cursor early.
-                        if (playerinventory.getCarried() != null) {
-                            playerinventory.setCarried(CraftItemStack.asNMSCopy(event.getCursor()));
-                            needsUpdate = true;
-                        }
-                    } else {
-                        playerinventory.setCarried(oldCursor);
-                    }
-
-                    if (needsUpdate && entityhuman instanceof EntityPlayer) {
-                        ((EntityPlayer) entityhuman).updateInventory(this);
-                    }
-                    // CraftBukkit end
-                }
-
-                this.d();
-            } else {
-                this.d();
-            }
+        //##################################################
+        //##################QUICK-CRAFT#####################
+        //##################################################
+        if (inventoryclicktype == InventoryClickType.QUICK_CRAFT) {
+            processQuickCraft(i, j, entityhuman, playerinventory);
         } else if (this.g != 0) {
             this.d();
+
+
         } else {
             Slot slot2;
             int k1;
 
             if ((inventoryclicktype == InventoryClickType.PICKUP || inventoryclicktype == InventoryClickType.QUICK_MOVE) && (j == 0 || j == 1)) {
+
+
+                //##################################################
+                //#################Drop-Carried#####################
+                //##################################################
                 if (i == -999) {
-                    if (!playerinventory.getCarried().isEmpty()) {
-                        if (j == 0) {
-                            // CraftBukkit start
-                            ItemStack carried = playerinventory.getCarried();
-                            playerinventory.setCarried(ItemStack.a);
-                            entityhuman.drop(carried, true);
-                            // CraftBukkit start
-                        }
+                    processDropCarried(j, entityhuman, playerinventory);
+                }
 
-                        if (j == 1) {
-                            entityhuman.drop(playerinventory.getCarried().cloneAndSubtract(1), true);
-                        }
-                    }
-                } else if (inventoryclicktype == InventoryClickType.QUICK_MOVE) {
+
+                //##################################################
+                //##################Quick-Move######################
+                //##################################################
+                else if (inventoryclicktype == InventoryClickType.QUICK_MOVE) {
                     if (i < 0) {
                         return ItemStack.a;
                     }
@@ -251,171 +192,384 @@ public abstract class Container {
                     for (itemstack2 = this.shiftClick(entityhuman, i); !itemstack2.isEmpty() && ItemStack.c(slot2.getItem(), itemstack2); itemstack2 = this.shiftClick(entityhuman, i)) {
                         itemstack = itemstack2.cloneItemStack();
                     }
-                } else {
+                }
+
+
+                //##################################################
+                //##################Normal-Click####################
+                //##################################################
+                else {
                     if (i < 0) {
                         return ItemStack.a;
                     }
 
-                    slot2 = (Slot) this.slots.get(i);
-                    if (slot2 != null) {
-                        itemstack2 = slot2.getItem();
-                        itemstack1 = playerinventory.getCarried();
-                        if (!itemstack2.isEmpty()) {
-                            itemstack = itemstack2.cloneItemStack();
-                        }
+                    itemstack = processNormalClick(i, j, entityhuman, itemstack, playerinventory);
+                }
 
-                        if (itemstack2.isEmpty()) {
-                            if (!itemstack1.isEmpty() && slot2.isAllowed(itemstack1)) {
-                                k1 = j == 0 ? itemstack1.getCount() : 1;
-                                if (k1 > slot2.getMaxStackSize(itemstack1)) {
-                                    k1 = slot2.getMaxStackSize(itemstack1);
-                                }
 
-                                slot2.set(itemstack1.cloneAndSubtract(k1));
-                            }
-                        } else if (slot2.isAllowed(entityhuman)) {
-                            if (itemstack1.isEmpty()) {
-                                if (itemstack2.isEmpty()) {
-                                    slot2.set(ItemStack.a);
-                                    playerinventory.setCarried(ItemStack.a);
-                                } else {
-                                    k1 = j == 0 ? itemstack2.getCount() : (itemstack2.getCount() + 1) / 2;
-                                    playerinventory.setCarried(slot2.a(k1));
-                                    if (itemstack2.isEmpty()) {
-                                        slot2.set(ItemStack.a);
-                                    }
-
-                                    slot2.a(entityhuman, playerinventory.getCarried());
-                                }
-                            } else if (slot2.isAllowed(itemstack1)) {
-                                if (itemstack2.getItem() == itemstack1.getItem() && itemstack2.getData() == itemstack1.getData() && ItemStack.equals(itemstack2, itemstack1)) {
-                                    k1 = j == 0 ? itemstack1.getCount() : 1;
-                                    if (k1 > slot2.getMaxStackSize(itemstack1) - itemstack2.getCount()) {
-                                        k1 = slot2.getMaxStackSize(itemstack1) - itemstack2.getCount();
-                                    }
-
-                                    if (k1 > itemstack1.getMaxStackSize() - itemstack2.getCount()) {
-                                        k1 = itemstack1.getMaxStackSize() - itemstack2.getCount();
-                                    }
-
-                                    itemstack1.subtract(k1);
-                                    itemstack2.add(k1);
-                                } else if (itemstack1.getCount() <= slot2.getMaxStackSize(itemstack1)) {
-                                    slot2.set(itemstack1);
-                                    playerinventory.setCarried(itemstack2);
-                                }
-                            } else if (itemstack2.getItem() == itemstack1.getItem() && itemstack1.getMaxStackSize() > 1 && (!itemstack2.usesData() || itemstack2.getData() == itemstack1.getData()) && ItemStack.equals(itemstack2, itemstack1) && !itemstack2.isEmpty()) {
-                                k1 = itemstack2.getCount();
-                                if (k1 + itemstack1.getCount() <= itemstack1.getMaxStackSize()) {
-                                    itemstack1.add(k1);
-                                    itemstack2 = slot2.a(k1);
-                                    if (itemstack2.isEmpty()) {
-                                        slot2.set(ItemStack.a);
-                                    }
-
-                                    slot2.a(entityhuman, playerinventory.getCarried());
-                                }
-                            }
-                        }
+                //##################################################
+                //##################Number-Swap#####################
+                //##################################################
+            } else if (inventoryclicktype == InventoryClickType.SWAP && j >= 0 && j < 9) {
+                processNumberSwap(i, j, entityhuman, playerinventory);
+            }
+
 
-                        slot2.f();
-                        // CraftBukkit start - Make sure the client has the right slot contents
-                        if (entityhuman instanceof EntityPlayer && slot2.getMaxStackSize() != 64) {
-                            ((EntityPlayer) entityhuman).playerConnection.sendPacket(new PacketPlayOutSetSlot(this.windowId, slot2.rawSlotIndex, slot2.getItem()));
-                            // Updating a crafting inventory makes the client reset the result slot, have to send it again
-                            if (this.getBukkitView().getType() == InventoryType.WORKBENCH || this.getBukkitView().getType() == InventoryType.CRAFTING) {
-                                ((EntityPlayer) entityhuman).playerConnection.sendPacket(new PacketPlayOutSetSlot(this.windowId, 0, this.getSlot(0).getItem()));
+            //##################################################
+            //#################Creative-Clone###################
+            //##################################################
+            else if (inventoryclicktype == InventoryClickType.CLONE && entityhuman.abilities.canInstantlyBuild && playerinventory.getCarried().isEmpty() && i >= 0) {
+                processCreativeClone(i, playerinventory);
+            }
+
+
+            //##################################################
+            //######################Throw#######################
+            //##################################################
+            else if (inventoryclicktype == InventoryClickType.THROW && playerinventory.getCarried().isEmpty() && i >= 0) {
+                processDropSlot(i, j, entityhuman);
+            }
+
+
+            //##################################################
+            //####################Pickup-All####################
+            //##################################################
+            else if (inventoryclicktype == InventoryClickType.PICKUP_ALL && i >= 0) {
+                processPickupAll(i, j, entityhuman, playerinventory);
+            }
+        }
+
+        return itemstack;
+    }
+
+    private void processNumberSwap(int i, int j, EntityHuman entityhuman, PlayerInventory playerinventory) {
+        Slot slot2;
+        ItemStack itemstack2;
+        ItemStack itemstack1;
+        int k1;
+        slot2 = (Slot) this.slots.get(i);
+        itemstack2 = playerinventory.getItem(j);
+        itemstack1 = slot2.getItem();
+
+        //OilSpigot start
+        boolean requiresUpdate = !slot2.isAllowed(entityhuman) || (itemstack2 != null && !slot2.isAllowed(itemstack2));
+        //OilSpigot end
+
+        if (!itemstack2.isEmpty() || !itemstack1.isEmpty()) {
+            if (itemstack2.isEmpty()) {
+                if (slot2.isAllowed(entityhuman)) {
+                    playerinventory.setItem(j, itemstack1);
+                    slot2.b(itemstack1.getCount());
+                    slot2.set(ItemStack.a);
+                    slot2.a(entityhuman, itemstack1);
+                }
+            } else if (itemstack1.isEmpty()) {
+                if (slot2.isAllowed(itemstack2)) {
+                    k1 = slot2.getMaxStackSize(itemstack2);
+                    if (itemstack2.getCount() > k1) {
+                        slot2.set(itemstack2.cloneAndSubtract(k1));
+                    } else {
+                        slot2.set(itemstack2);
+                        playerinventory.setItem(j, ItemStack.a);
+                    }
+                }
+            } else if (slot2.isAllowed(entityhuman) && slot2.isAllowed(itemstack2)) {
+                k1 = slot2.getMaxStackSize(itemstack2);
+                if (itemstack2.getCount() > k1) {
+                    slot2.set(itemstack2.cloneAndSubtract(k1));
+                    slot2.a(entityhuman, itemstack1);
+                    if (!playerinventory.pickup(itemstack1)) {
+                        entityhuman.drop(itemstack1, true);
+                    }
+                } else {
+                    slot2.set(itemstack2);
+                    playerinventory.setItem(j, itemstack1);
+                    slot2.a(entityhuman, itemstack1);
+                }
+            }
+        }
+        //OilSpigot start //TODO: this is done to avoid async - be sure that it works
+        if (requiresUpdate && entityhuman instanceof EntityPlayer) {
+            ItemStack slotUpdated = slot2.getItem();
+            ((EntityPlayer) entityhuman).playerConnection.sendPacket(new PacketPlayOutSetSlot(this.windowId, slot2.rawSlotIndex, slotUpdated==null||slotUpdated.getCount()<1?null:slotUpdated));
+            ItemStack slot2Updated = playerinventory.getItem(j);
+            ((EntityPlayer) entityhuman).playerConnection.sendPacket(new PacketPlayOutSetSlot(this.windowId, hotbarSlotToPacketSlot(j), slot2Updated==null||slot2Updated.getCount()<1?null:slot2Updated));
+        }
+        //OilSpigot end
+    }
+
+    private void processPickupAll(int i, int j, EntityHuman entityhuman, PlayerInventory playerinventory) {
+        Slot slot2;
+        ItemStack itemstack2;
+        int l;
+        int k1;
+        int k;
+        slot2 = (Slot) this.slots.get(i);
+        itemstack2 = playerinventory.getCarried();
+        if (!itemstack2.isEmpty() && (slot2 == null || !slot2.hasItem() || !slot2.isAllowed(entityhuman))) {
+            l = j == 0 ? 0 : this.slots.size() - 1;
+            k1 = j == 0 ? 1 : -1;
+
+            for (int l1 = 0; l1 < 2; ++l1) {
+                for (int i2 = l; i2 >= 0 && i2 < this.slots.size() && itemstack2.getCount() < itemstack2.getMaxStackSize(); i2 += k1) {
+                    Slot slot3 = (Slot) this.slots.get(i2);
+
+                    if (slot3.hasItem() && a(slot3, itemstack2, true) && slot3.isAllowed(entityhuman) && this.a(itemstack2, slot3)) {
+                        ItemStack itemstack5 = slot3.getItem();
+
+                        if (l1 != 0 || itemstack5.getCount() != itemstack5.getMaxStackSize()) {
+                            k = Math.min(itemstack2.getMaxStackSize() - itemstack2.getCount(), itemstack5.getCount());
+                            ItemStack itemstack6 = slot3.a(k);
+
+                            itemstack2.add(k);
+                            if (itemstack6.isEmpty()) {
+                                slot3.set(ItemStack.a);
                             }
+
+                            slot3.a(entityhuman, itemstack6);
                         }
-                        // CraftBukkit end
                     }
                 }
-            } else if (inventoryclicktype == InventoryClickType.SWAP && j >= 0 && j < 9) {
-                slot2 = (Slot) this.slots.get(i);
-                itemstack2 = playerinventory.getItem(j);
-                itemstack1 = slot2.getItem();
-                if (!itemstack2.isEmpty() || !itemstack1.isEmpty()) {
+            }
+        }
+
+        this.b();
+    }
+
+    private void processDropSlot(int i, int j, EntityHuman entityhuman) {
+        Slot slot2;
+        ItemStack itemstack2;
+        slot2 = (Slot) this.slots.get(i);
+        if (slot2 != null && slot2.hasItem() && slot2.isAllowed(entityhuman)) {
+            itemstack2 = slot2.a(j == 0 ? 1 : slot2.getItem().getCount());
+            slot2.a(entityhuman, itemstack2);
+            entityhuman.drop(itemstack2, true);
+        }
+    }
+
+    private void processCreativeClone(int i, PlayerInventory playerinventory) {
+        Slot slot2;
+        ItemStack itemstack2;
+        slot2 = (Slot) this.slots.get(i);
+        if (slot2 != null && slot2.hasItem()) {
+            itemstack2 = slot2.getItem().cloneItemStack();
+            itemstack2.setCount(itemstack2.getMaxStackSize());
+            playerinventory.setCarried(itemstack2);
+        }
+    }
+
+    private ItemStack processNormalClick(int i, int j, EntityHuman entityhuman, ItemStack itemstack, PlayerInventory playerinventory) {
+        Slot slot2;
+        ItemStack itemstack2;
+        ItemStack itemstack1;
+        int k1;
+        slot2 = (Slot) this.slots.get(i);
+        if (slot2 != null) {
+            itemstack2 = slot2.getItem();
+            itemstack1 = playerinventory.getCarried();
+            if (!itemstack2.isEmpty()) {
+                itemstack = itemstack2.cloneItemStack();
+            }
+
+            //OilSpigot start
+            boolean requiresUpdate = itemstack1 != null && !slot2.isAllowed(itemstack1);
+            //OilSpigot end
+
+            if (itemstack2.isEmpty()) {
+                if (!itemstack1.isEmpty() && slot2.isAllowed(itemstack1)) {
+                    k1 = j == 0 ? itemstack1.getCount() : 1;
+                    if (k1 > slot2.getMaxStackSize(itemstack1)) {
+                        k1 = slot2.getMaxStackSize(itemstack1);
+                    }
+
+                    slot2.set(itemstack1.cloneAndSubtract(k1));
+                }
+            } else if (slot2.isAllowed(entityhuman)) {
+                if (itemstack1.isEmpty()) {
                     if (itemstack2.isEmpty()) {
-                        if (slot2.isAllowed(entityhuman)) {
-                            playerinventory.setItem(j, itemstack1);
-                            slot2.b(itemstack1.getCount());
+                        slot2.set(ItemStack.a);
+                        playerinventory.setCarried(ItemStack.a);
+                    } else {
+                        k1 = j == 0 ? itemstack2.getCount() : (itemstack2.getCount() + 1) / 2;
+                        playerinventory.setCarried(slot2.a(k1));
+                        if (itemstack2.isEmpty()) {
                             slot2.set(ItemStack.a);
-                            slot2.a(entityhuman, itemstack1);
                         }
-                    } else if (itemstack1.isEmpty()) {
-                        if (slot2.isAllowed(itemstack2)) {
-                            k1 = slot2.getMaxStackSize(itemstack2);
-                            if (itemstack2.getCount() > k1) {
-                                slot2.set(itemstack2.cloneAndSubtract(k1));
-                            } else {
-                                slot2.set(itemstack2);
-                                playerinventory.setItem(j, ItemStack.a);
-                            }
+
+                        slot2.a(entityhuman, playerinventory.getCarried());
+                    }
+                } else if (slot2.isAllowed(itemstack1)) {
+                    if (itemstack2.getItem() == itemstack1.getItem() && itemstack2.getData() == itemstack1.getData() && ItemStack.equals(itemstack2, itemstack1)) {
+                        k1 = j == 0 ? itemstack1.getCount() : 1;
+                        if (k1 > slot2.getMaxStackSize(itemstack1) - itemstack2.getCount()) {
+                            k1 = slot2.getMaxStackSize(itemstack1) - itemstack2.getCount();
                         }
-                    } else if (slot2.isAllowed(entityhuman) && slot2.isAllowed(itemstack2)) {
-                        k1 = slot2.getMaxStackSize(itemstack2);
-                        if (itemstack2.getCount() > k1) {
-                            slot2.set(itemstack2.cloneAndSubtract(k1));
-                            slot2.a(entityhuman, itemstack1);
-                            if (!playerinventory.pickup(itemstack1)) {
-                                entityhuman.drop(itemstack1, true);
-                            }
-                        } else {
-                            slot2.set(itemstack2);
-                            playerinventory.setItem(j, itemstack1);
-                            slot2.a(entityhuman, itemstack1);
+
+                        if (k1 > itemstack1.getMaxStackSize() - itemstack2.getCount()) {
+                            k1 = itemstack1.getMaxStackSize() - itemstack2.getCount();
                         }
+
+                        itemstack1.subtract(k1);
+                        itemstack2.add(k1);
+                    } else if (itemstack1.getCount() <= slot2.getMaxStackSize(itemstack1)) {
+                        slot2.set(itemstack1);
+                        playerinventory.setCarried(itemstack2);
+                    }
+                } else if (itemstack2.getItem() == itemstack1.getItem() && itemstack1.getMaxStackSize() > 1 && (!itemstack2.usesData() || itemstack2.getData() == itemstack1.getData()) && ItemStack.equals(itemstack2, itemstack1) && !itemstack2.isEmpty()) {
+                    k1 = itemstack2.getCount();
+                    if (k1 + itemstack1.getCount() <= itemstack1.getMaxStackSize()) {
+                        itemstack1.add(k1);
+                        itemstack2 = slot2.a(k1);
+                        if (itemstack2.isEmpty()) {
+                            slot2.set(ItemStack.a);
+                        }
+
+                        slot2.a(entityhuman, playerinventory.getCarried());
                     }
                 }
-            } else if (inventoryclicktype == InventoryClickType.CLONE && entityhuman.abilities.canInstantlyBuild && playerinventory.getCarried().isEmpty() && i >= 0) {
-                slot2 = (Slot) this.slots.get(i);
-                if (slot2 != null && slot2.hasItem()) {
-                    itemstack2 = slot2.getItem().cloneItemStack();
-                    itemstack2.setCount(itemstack2.getMaxStackSize());
-                    playerinventory.setCarried(itemstack2);
-                }
-            } else if (inventoryclicktype == InventoryClickType.THROW && playerinventory.getCarried().isEmpty() && i >= 0) {
-                slot2 = (Slot) this.slots.get(i);
-                if (slot2 != null && slot2.hasItem() && slot2.isAllowed(entityhuman)) {
-                    itemstack2 = slot2.a(j == 0 ? 1 : slot2.getItem().getCount());
-                    slot2.a(entityhuman, itemstack2);
-                    entityhuman.drop(itemstack2, true);
+            }
+
+            slot2.f();
+
+            //OilSpigot start //TODO: this is done to avoid async - be sure that it works
+            if (requiresUpdate && entityhuman instanceof EntityPlayer) {
+                ItemStack slotUpdated = slot2.getItem();
+                ((EntityPlayer) entityhuman).playerConnection.sendPacket(new PacketPlayOutSetSlot(this.windowId, slot2.rawSlotIndex, slotUpdated.isEmpty()?ItemStack.a:slotUpdated));
+                ItemStack carriedUpdated = playerinventory.getCarried();
+                ((EntityPlayer) entityhuman).playerConnection.sendPacket(new PacketPlayOutSetSlot(-1, -1, carriedUpdated.isEmpty()?ItemStack.a:carriedUpdated));
+            }
+            //OilSpigot end
+
+            // CraftBukkit start - Make sure the client has the right slot contents
+            if (entityhuman instanceof EntityPlayer && slot2.getMaxStackSize() != 64) {
+                ((EntityPlayer) entityhuman).playerConnection.sendPacket(new PacketPlayOutSetSlot(this.windowId, slot2.rawSlotIndex, slot2.getItem()));
+                // Updating a crafting inventory makes the client reset the result slot, have to send it again
+                if (this.getBukkitView().getType() == InventoryType.WORKBENCH || this.getBukkitView().getType() == InventoryType.CRAFTING) {
+                    ((EntityPlayer) entityhuman).playerConnection.sendPacket(new PacketPlayOutSetSlot(this.windowId, 0, this.getSlot(0).getItem()));
                 }
-            } else if (inventoryclicktype == InventoryClickType.PICKUP_ALL && i >= 0) {
-                slot2 = (Slot) this.slots.get(i);
-                itemstack2 = playerinventory.getCarried();
-                if (!itemstack2.isEmpty() && (slot2 == null || !slot2.hasItem() || !slot2.isAllowed(entityhuman))) {
-                    l = j == 0 ? 0 : this.slots.size() - 1;
-                    k1 = j == 0 ? 1 : -1;
-
-                    for (int l1 = 0; l1 < 2; ++l1) {
-                        for (int i2 = l; i2 >= 0 && i2 < this.slots.size() && itemstack2.getCount() < itemstack2.getMaxStackSize(); i2 += k1) {
-                            Slot slot3 = (Slot) this.slots.get(i2);
-
-                            if (slot3.hasItem() && a(slot3, itemstack2, true) && slot3.isAllowed(entityhuman) && this.a(itemstack2, slot3)) {
-                                ItemStack itemstack5 = slot3.getItem();
-
-                                if (l1 != 0 || itemstack5.getCount() != itemstack5.getMaxStackSize()) {
-                                    k = Math.min(itemstack2.getMaxStackSize() - itemstack2.getCount(), itemstack5.getCount());
-                                    ItemStack itemstack6 = slot3.a(k);
-
-                                    itemstack2.add(k);
-                                    if (itemstack6.isEmpty()) {
-                                        slot3.set(ItemStack.a);
-                                    }
-
-                                    slot3.a(entityhuman, itemstack6);
-                                }
-                            }
+            }
+            // CraftBukkit end
+        }
+        return itemstack;
+    }
+
+    private void processDropCarried(int j, EntityHuman entityhuman, PlayerInventory playerinventory) {
+        if (!playerinventory.getCarried().isEmpty()) {
+            if (j == 0) {
+                // CraftBukkit start
+                ItemStack carried = playerinventory.getCarried();
+                playerinventory.setCarried(ItemStack.a);
+                entityhuman.drop(carried, true);
+                // CraftBukkit start
+            }
+
+            if (j == 1) {
+                entityhuman.drop(playerinventory.getCarried().cloneAndSubtract(1), true);
+            }
+        }
+    }
+
+    private void processQuickCraft(int i, int j, EntityHuman entityhuman, PlayerInventory playerinventory) {
+        ItemStack itemstack1;
+        ItemStack itemstack2;
+        int l;
+        int k;
+        int i1 = this.g;
+
+        this.g = c(j);
+        if ((i1 != 1 || this.g != 2) && i1 != this.g) {
+            this.d();
+        } else if (playerinventory.getCarried().isEmpty()) {
+            this.d();
+        } else if (this.g == 0) {
+            this.dragType = b(j);
+            if (a(this.dragType, entityhuman)) {
+                this.g = 1;
+                this.h.clear();
+            } else {
+                this.d();
+            }
+        } else if (this.g == 1) {
+            Slot slot = i < this.slots.size() ? this.slots.get(i) : null; // Paper - Ensure drag in bounds
+
+            itemstack1 = playerinventory.getCarried();
+            if (slot != null && a(slot, itemstack1, true) && slot.isAllowed(itemstack1) && (this.dragType == 2 || itemstack1.getCount() > this.h.size()) && this.b(slot)) {
+                this.h.add(slot);
+            }
+        } else if (this.g == 2) {
+            if (!this.h.isEmpty()) {
+                itemstack2 = playerinventory.getCarried().cloneItemStack();
+                l = playerinventory.getCarried().getCount();
+                Iterator iterator = this.h.iterator();
+
+                Map<Integer, ItemStack> draggedSlots = new HashMap<Integer, ItemStack>(); // CraftBukkit - Store slots from drag in map (raw slot id -> new stack)
+                while (iterator.hasNext()) {
+                    Slot slot1 = (Slot) iterator.next();
+                    ItemStack itemstack3 = playerinventory.getCarried();
+
+                    if (slot1 != null && a(slot1, itemstack3, true) && slot1.isAllowed(itemstack3) && (this.dragType == 2 || itemstack3.getCount() >= this.h.size()) && this.b(slot1)) {
+                        ItemStack itemstack4 = itemstack2.cloneItemStack();
+                        int j1 = slot1.hasItem() ? slot1.getItem().getCount() : 0;
+
+                        a(this.h, this.dragType, itemstack4, j1);
+                        k = Math.min(itemstack4.getMaxStackSize(), slot1.getMaxStackSize(itemstack4));
+                        if (itemstack4.getCount() > k) {
+                            itemstack4.setCount(k);
                         }
+
+                        l -= itemstack4.getCount() - j1;
+                        // slot1.set(itemstack4);
+                        draggedSlots.put(slot1.rawSlotIndex, itemstack4); // CraftBukkit - Put in map instead of setting
                     }
                 }
 
-                this.b();
+                // CraftBukkit start - InventoryDragEvent
+                InventoryView view = getBukkitView();
+                org.bukkit.inventory.ItemStack newcursor = CraftItemStack.asCraftMirror(itemstack2);
+                newcursor.setAmount(l);
+                Map<Integer, org.bukkit.inventory.ItemStack> eventmap = new HashMap<Integer, org.bukkit.inventory.ItemStack>();
+                for (Map.Entry<Integer, ItemStack> ditem : draggedSlots.entrySet()) {
+                    //OilSpigot - use asCraftMirror and clone
+                    eventmap.put(ditem.getKey(), CraftItemStack.asCraftMirror(ditem.getValue()).clone());
+                }
+
+                // It's essential that we set the cursor to the new value here to prevent item duplication if a plugin closes the inventory.
+                ItemStack oldCursor = playerinventory.getCarried();
+                playerinventory.setCarried(CraftItemStack.asNMSCopy(newcursor));
+
+                //OilSpigot - use asCraftMirror and clone
+                InventoryDragEvent event = new InventoryDragEvent(view, (newcursor.getType() != org.bukkit.Material.AIR ? newcursor : null), CraftItemStack.asCraftMirror(oldCursor).clone(), this.dragType == 1, eventmap);
+                entityhuman.world.getServer().getPluginManager().callEvent(event);
+
+                // Whether or not a change was made to the inventory that requires an update.
+                boolean needsUpdate = event.getResult() != Result.DEFAULT;
+
+                if (event.getResult() != Result.DENY) {
+                    for (Map.Entry<Integer, ItemStack> dslot : draggedSlots.entrySet()) {
+
+                        //OilSpigot - use asCraftMirror and clone
+                        view.setItem(dslot.getKey(), CraftItemStack.asCraftMirror(dslot.getValue()).clone());
+                    }
+                    // The only time the carried item will be set to null is if the inventory is closed by the server.
+                    // If the inventory is closed by the server, then the cursor items are dropped.  This is why we change the cursor early.
+                    if (playerinventory.getCarried() != null) {
+                        playerinventory.setCarried(CraftItemStack.asNMSCopy(event.getCursor()));
+                        needsUpdate = true;
+                    }
+                } else {
+                    playerinventory.setCarried(oldCursor);
+                }
+
+                if (needsUpdate && entityhuman instanceof EntityPlayer) {
+                    ((EntityPlayer) entityhuman).updateInventory(this);
+                }
+                // CraftBukkit end
             }
-        }
 
-        return itemstack;
+            this.d();
+        } else {
+            this.d();
+        }
     }
 
     public boolean a(ItemStack itemstack, Slot slot) {
@@ -471,7 +625,7 @@ public abstract class Container {
 
     public abstract boolean canUse(EntityHuman entityhuman);
 
-    protected boolean a(ItemStack itemstack, int i, int j, boolean flag) {
+    protected boolean a(EntityHuman entityhuman, ItemStack itemstack, int i, int j, boolean flag) {//OilSpigot added param EntityHuman
         boolean flag1 = false;
         int k = i;
 
@@ -493,22 +647,30 @@ public abstract class Container {
                 }
 
                 slot = (Slot) this.slots.get(k);
-                itemstack1 = slot.getItem();
-                if (!itemstack1.isEmpty() && itemstack1.getItem() == itemstack.getItem() && (!itemstack.usesData() || itemstack.getData() == itemstack1.getData()) && ItemStack.equals(itemstack, itemstack1)) {
-                    int l = itemstack1.getCount() + itemstack.getCount();
 
-                    if (l <= itemstack.getMaxStackSize()) {
-                        itemstack.setCount(0);
-                        itemstack1.setCount(l);
-                        slot.f();
-                        flag1 = true;
-                    } else if (itemstack1.getCount() < itemstack.getMaxStackSize()) {
-                        itemstack.subtract(itemstack.getMaxStackSize() - itemstack1.getCount());
-                        itemstack1.setCount(itemstack.getMaxStackSize());
-                        slot.f();
-                        flag1 = true;
+                //OilSpigot start - checks is itemstack can be put into this slot //TODO: maybe requires update of client
+                if (slot.isAllowed(entityhuman) && slot.isAllowed(itemstack)) {
+                    //OilSpigot end
+
+                    itemstack1 = slot.getItem();
+                    if (!itemstack1.isEmpty() && itemstack1.getItem() == itemstack.getItem() && (!itemstack.usesData() || itemstack.getData() == itemstack1.getData()) && ItemStack.equals(itemstack, itemstack1)) {
+                        int l = itemstack1.getCount() + itemstack.getCount();
+
+                        if (l <= itemstack.getMaxStackSize()) {
+                            itemstack.setCount(0);
+                            itemstack1.setCount(l);
+                            slot.f();
+                            flag1 = true;
+                        } else if (itemstack1.getCount() < itemstack.getMaxStackSize()) {
+                            itemstack.subtract(itemstack.getMaxStackSize() - itemstack1.getCount());
+                            itemstack1.setCount(itemstack.getMaxStackSize());
+                            slot.f();
+                            flag1 = true;
+                        }
                     }
-                }
+
+                } //OilSpigot bracket
+
 
                 if (flag) {
                     --k;
@@ -535,18 +697,23 @@ public abstract class Container {
                 }
 
                 slot = (Slot) this.slots.get(k);
-                itemstack1 = slot.getItem();
-                if (itemstack1.isEmpty() && slot.isAllowed(itemstack)) {
-                    if (itemstack.getCount() > slot.getMaxStackSize()) {
-                        slot.set(itemstack.cloneAndSubtract(slot.getMaxStackSize()));
-                    } else {
-                        slot.set(itemstack.cloneAndSubtract(itemstack.getCount()));
-                    }
 
-                    slot.f();
-                    flag1 = true;
-                    break;
-                }
+                //OilSpigot start - checks is itemstack can be put into this slot //TODO: maybe requires update of client
+                if (slot.isAllowed(entityhuman) && slot.isAllowed(itemstack)) {
+                    //OilSpigot end
+                    itemstack1 = slot.getItem();
+                    if (itemstack1.isEmpty() && slot.isAllowed(itemstack)) {
+                        if (itemstack.getCount() > slot.getMaxStackSize()) {
+                            slot.set(itemstack.cloneAndSubtract(slot.getMaxStackSize()));
+                        } else {
+                            slot.set(itemstack.cloneAndSubtract(itemstack.getCount()));
+                        }
+
+                        slot.f();
+                        flag1 = true;
+                        break;
+                    }
+                } //OilSpigot bracket
 
                 if (flag) {
                     --k;
@@ -628,20 +795,21 @@ public abstract class Container {
         }
     }
 
-    protected void a(World world, EntityHuman entityhuman, InventoryCrafting inventorycrafting, InventoryCraftResult inventorycraftresult) {
+    //OilSpigot made static
+    protected static void a(World world, EntityHuman entityhuman, IInventoryCrafting inventorycrafting, IInventoryCraftResult inventorycraftresult, CraftingManager craftingManager, Container container) {
         if (!world.isClientSide) {
             EntityPlayer entityplayer = (EntityPlayer) entityhuman;
             ItemStack itemstack = ItemStack.a;
-            IRecipe irecipe = CraftingManager.b(inventorycrafting, world);
+            IRecipe irecipe = craftingManager.b(inventorycrafting, world);
 
             if (irecipe != null && (irecipe.c() || !world.getGameRules().getBoolean("doLimitedCrafting") || entityplayer.F().b(irecipe))) {
                 inventorycraftresult.a(irecipe);
                 itemstack = irecipe.craftItem(inventorycrafting);
             }
-            itemstack = org.bukkit.craftbukkit.event.CraftEventFactory.callPreCraftEvent(inventorycrafting, itemstack, getBukkitView(), false); // CraftBukkit
+            itemstack = org.bukkit.craftbukkit.event.CraftEventFactory.callPreCraftEvent(inventorycrafting, itemstack, container.getBukkitView(), false); // CraftBukkit
 
             inventorycraftresult.setItem(0, itemstack);
-            entityplayer.playerConnection.sendPacket(new PacketPlayOutSetSlot(this.windowId, 0, itemstack));
+            entityplayer.playerConnection.sendPacket(new PacketPlayOutSetSlot(container.windowId, 0, itemstack));
         }
     }
 }
diff --git a/src/main/java/net/minecraft/server/ContainerAnvil.java b/src/main/java/net/minecraft/server/ContainerAnvil.java
index 16ec6756..bb241d61 100644
--- a/src/main/java/net/minecraft/server/ContainerAnvil.java
+++ b/src/main/java/net/minecraft/server/ContainerAnvil.java
@@ -10,6 +10,11 @@ import org.apache.logging.log4j.Logger;
 import org.bukkit.craftbukkit.inventory.CraftInventoryView;
 // CraftBukkit end
 
+//OilSpigot start
+import org.bukkit.ChatColor;
+import org.oilmod.spigot.items.itemstackimpl.internal.ModItemStack;
+//OilSpigot end
+
 public class ContainerAnvil extends Container {
 
     private static final Logger f = LogManager.getLogger();
@@ -31,6 +36,11 @@ public class ContainerAnvil extends Container {
     private CraftInventoryView bukkitEntity;
     private PlayerInventory player;
     // CraftBukkit end
+    //OilSpigot start
+    private boolean oilSpigotAnvilRepair = false;
+    private boolean oilSpigotAnvilCombine = false;
+    private ItemStack lastResult = null;
+    //OilSpigot end
 
     public ContainerAnvil(PlayerInventory playerinventory, final World world, final BlockPosition blockposition, EntityHuman entityhuman) {
         this.player = playerinventory; // CraftBukkit
@@ -53,6 +63,18 @@ public class ContainerAnvil extends Container {
                     entityhuman.levelDown(-ContainerAnvil.this.levelCost);
                 }
 
+                ContainerAnvil.this.levelCost = 0;
+                //OilSpigot start
+                if(oilSpigotAnvilRepair) {
+                    ((ModItemStack)ContainerAnvil.this.lastResult).repairAnvil(ContainerAnvil.this.h.getItem(1), player.player);
+                }
+                if(oilSpigotAnvilCombine) {
+                    ((ModItemStack)ContainerAnvil.this.lastResult).combineAnvil(ContainerAnvil.this.h.getItem(1), player.player);
+                }
+                oilSpigotAnvilCombine = false;
+                oilSpigotAnvilRepair = false;
+                //OilSpigot end
+
                 ContainerAnvil.this.h.setItem(0, ItemStack.a);
                 if (ContainerAnvil.this.k > 0) {
                     ItemStack itemstack1 = ContainerAnvil.this.h.getItem(1);
@@ -112,6 +134,10 @@ public class ContainerAnvil extends Container {
     }
 
     public void e() {
+        //OilSpigot start
+        oilSpigotAnvilCombine = false;
+        oilSpigotAnvilRepair = false;
+        //OilSpigot end
         ItemStack itemstack = this.h.getItem(0);
 
         this.levelCost = 1;
@@ -122,6 +148,7 @@ public class ContainerAnvil extends Container {
         if (itemstack.isEmpty()) {
             org.bukkit.craftbukkit.event.CraftEventFactory.callPrepareAnvilEvent(getBukkitView(), ItemStack.a); // CraftBukkit
             this.levelCost = 0;
+            this.update(); //OilSpigot - update levelCost for Client //TODO changed d to update check
         } else {
             ItemStack itemstack1 = itemstack.cloneItemStack();
             ItemStack itemstack2 = this.h.getItem(1);
@@ -130,35 +157,53 @@ public class ContainerAnvil extends Container {
 
             this.k = 0;
             if (!itemstack2.isEmpty()) {
-                boolean flag = itemstack2.getItem() == Items.ENCHANTED_BOOK && !ItemEnchantedBook.h(itemstack2).isEmpty();
+                //OilSpigot - ModItemStacks does not behave as vanilla items.
+                boolean flag = itemstack2.getItem() == Items.ENCHANTED_BOOK && !ItemEnchantedBook.h(itemstack2).isEmpty() && !(itemstack2 instanceof ModItemStack); //Todo: maybe removeable after direct item modding is added / scope of the next update
                 int k;
                 int l;
                 int i1;
 
-                if (itemstack1.f() && itemstack1.getItem().a(itemstack, itemstack2)) {
-                    k = Math.min(itemstack1.i(), itemstack1.k() / 4);
-                    if (k <= 0) {
-                        org.bukkit.craftbukkit.event.CraftEventFactory.callPrepareAnvilEvent(getBukkitView(), ItemStack.a); // CraftBukkit
-                        this.levelCost = 0;
-                        return;
-                    }
-
-                    for (l = 0; k > 0 && l < itemstack2.getCount(); ++l) {
-                        i1 = itemstack1.i() - k;
-                        itemstack1.setData(i1);
-                        ++i;
+                //OilSpigot - Allow repairing for ModItemStacks
+                if (itemstack1 instanceof ModItemStack?itemstack.getCount()==1 && (((ModItemStack) itemstack1).canRepairAnvil(itemstack2, player.player)):itemstack1.f() && itemstack1.getItem().a(itemstack, itemstack2)) {
+                    //OilSpigot start
+                    oilSpigotAnvilRepair = itemstack1 instanceof ModItemStack;
+                    if (oilSpigotAnvilRepair) {
+                        this.k = ((ModItemStack) itemstack1).prepareRepairAnvil(itemstack2, player.player);
+                        i+=this.k;
+                    } else {
+                        //OilSpigot end
                         k = Math.min(itemstack1.i(), itemstack1.k() / 4);
-                    }
+                        if (k <= 0) {
+                            org.bukkit.craftbukkit.event.CraftEventFactory.callPrepareAnvilEvent(getBukkitView(), ItemStack.a); // CraftBukkit
+                            this.levelCost = 0;
+                            this.d(); //OilSpigot - update levelCost for Client todo: d -> update
+                            return;
+                        }
 
-                    this.k = l;
+                        for (l = 0; k > 0 && l < itemstack2.getCount(); ++l) {
+                            i1 = itemstack1.i() - k;
+                            itemstack1.setData(i1);
+                            ++i;
+                            k = Math.min(itemstack1.i(), itemstack1.k() / 4);
+                        }
+
+                        this.k = l;
+                    }//OilSpigot bracket
                 } else {
-                    if (!flag && (itemstack1.getItem() != itemstack2.getItem() || !itemstack1.f())) {
+                    if (!flag && (itemstack1 instanceof ModItemStack?(itemstack.getCount()!=1 || itemstack2.getCount()!=1 || !(oilSpigotAnvilCombine=((ModItemStack) itemstack1).canCombineAnvil(itemstack2, player.player))):itemstack1.getItem() != itemstack2.getItem() || !itemstack1.f())) {
                         org.bukkit.craftbukkit.event.CraftEventFactory.callPrepareAnvilEvent(getBukkitView(), ItemStack.a); // CraftBukkit
                         this.levelCost = 0;
+                        this.d(); //OilSpigot - update levelCost for Client todo: d -> update
                         return;
                     }
 
-                    if (itemstack1.f() && !flag) {
+
+                    //OilSpigot start
+                    if (oilSpigotAnvilCombine) {
+                        ((ModItemStack)itemstack1).prepareCombineAnvil(itemstack2, player.player);
+                        i += 2;//increase level cost
+                        //OilSpigot end
+                    } else if (itemstack1.f() && !flag) {
                         k = itemstack.k() - itemstack.i();
                         l = itemstack2.k() - itemstack2.i();
                         i1 = l + itemstack1.k() * 12 / 100;
@@ -188,7 +233,8 @@ public class ContainerAnvil extends Container {
                             int i2 = ((Integer) map1.get(enchantment)).intValue();
 
                             i2 = l1 == i2 ? i2 + 1 : Math.max(i2, l1);
-                            boolean flag3 = enchantment.canEnchant(itemstack);
+                            //OilSpigot - Added support for ModItemstacks
+                            boolean flag3 = itemstack instanceof ModItemStack ? ((ModItemStack) itemstack).canEnchant(enchantment):enchantment.canEnchant(itemstack);
 
                             if (this.m.abilities.canInstantlyBuild || itemstack.getItem() == Items.ENCHANTED_BOOK) {
                                 flag3 = true;
@@ -248,22 +294,41 @@ public class ContainerAnvil extends Container {
                     if (flag2 && !flag1) {
                         org.bukkit.craftbukkit.event.CraftEventFactory.callPrepareAnvilEvent(getBukkitView(), ItemStack.a); // CraftBukkit
                         this.levelCost = 0;
+                        this.d(); //OilSpigot - update levelCost for Client todo: d -> update
                         return;
                     }
                 }
             }
 
-            if (StringUtils.isBlank(this.renameText)) {
-                if (itemstack.hasName()) {
+            //OilSpigot start - handle renaming for moditems
+            if (itemstack instanceof ModItemStack) {
+                ModItemStack modItemStack = (ModItemStack) itemstack;
+                String correctName = modItemStack.getCorrectDisplayName();
+                if (StringUtils.isBlank(this.renameText)) {
+                    if (!oilCompareNames(correctName, this.renameText)) {
+                        b1 = 1;
+                        i += b1;
+                        itemstack1.s(); //update name (if item no longer has custom name apply mod item name)
+                    }
+                } else if ((!oilCompareNames(correctName, ChatColor.stripColor(itemstack.getName())) || !oilCompareNames(correctName, this.renameText)) && !this.renameText.equals(itemstack.getName())) {
                     b1 = 1;
                     i += b1;
-                    itemstack1.s();
+                    itemstack1.c(this.renameText);
                 }
-            } else if (!this.renameText.equals(itemstack.getName())) {
-                b1 = 1;
-                i += b1;
-                itemstack1.g(this.renameText);
-            }
+            } else {
+                //OilSpigot end
+                if (StringUtils.isBlank(this.renameText)) {
+                    if (itemstack.hasName()) {
+                        b1 = 1;
+                        i += b1;
+                        itemstack1.s();
+                    }
+                } else if (!this.renameText.equals(itemstack.getName())) {
+                    b1 = 1;
+                    i += b1;
+                    itemstack1.g(this.renameText);
+                }
+            }//OilSpigot bracket
 
             this.levelCost = j + i;
             if (i <= 0) {
@@ -294,6 +359,7 @@ public class ContainerAnvil extends Container {
             }
 
             org.bukkit.craftbukkit.event.CraftEventFactory.callPrepareAnvilEvent(getBukkitView(), itemstack1); // CraftBukkit
+            lastResult = itemstack1; //OilSpigot - save last result for later
             this.b();
         }
     }
@@ -312,7 +378,8 @@ public class ContainerAnvil extends Container {
 
     public boolean canUse(EntityHuman entityhuman) {
         if (!this.checkReachable) return true; // CraftBukkit
-        return this.i.getType(this.j).getBlock() != Blocks.ANVIL ? false : entityhuman.d((double) this.j.getX() + 0.5D, (double) this.j.getY() + 0.5D, (double) this.j.getZ() + 0.5D) <= 64.0D;
+        //OilSpigot - no logic change - just simplified
+        return this.i.getType(this.j).getBlock() == Blocks.ANVIL && entityhuman.d((double) this.j.getX() + 0.5D, (double) this.j.getY() + 0.5D, (double) this.j.getZ() + 0.5D) <= 64.0D;
     }
 
     public ItemStack shiftClick(EntityHuman entityhuman, int i) {
@@ -324,16 +391,16 @@ public class ContainerAnvil extends Container {
 
             itemstack = itemstack1.cloneItemStack();
             if (i == 2) {
-                if (!this.a(itemstack1, 3, 39, true)) {
+                if (!this.a(entityhuman, itemstack1, 3, 39, true)) { //OilSpigot - added entityhuman param
                     return ItemStack.a;
                 }
 
                 slot.a(itemstack1, itemstack);
             } else if (i != 0 && i != 1) {
-                if (i >= 3 && i < 39 && !this.a(itemstack1, 0, 2, false)) {
+                if (i >= 3 && i < 39 && !this.a(entityhuman, itemstack1, 0, 2, false)) { //OilSpigot - added entityhuman param
                     return ItemStack.a;
                 }
-            } else if (!this.a(itemstack1, 3, 39, false)) {
+            } else if (!this.a(entityhuman, itemstack1, 3, 39, false)) { //OilSpigot - added entityhuman param
                 return ItemStack.a;
             }
 
@@ -361,6 +428,20 @@ public class ContainerAnvil extends Container {
             if (StringUtils.isBlank(s)) {
                 itemstack.s();
             } else {
+                //OilSpigot start
+                if (itemstack instanceof ModItemStack) {
+                    ModItemStack modItemStack_Slot0 = (ModItemStack) this.getSlot(0).getItem();
+                    String oldName = modItemStack_Slot0.getName();
+                    if (oldName.equals(modItemStack_Slot0.getCorrectDisplayName())) {
+                        if (oilCompareNames(oldName, s)) {
+                            this.renameText = oldName;
+                            itemstack.s();
+                            this.e();
+                            return;
+                        }
+                    }
+                }
+                //OilSpigot end
                 itemstack.g(this.renameText);
             }
         }
@@ -368,21 +449,29 @@ public class ContainerAnvil extends Container {
         this.e();
     }
 
-    // CraftBukkit start
-    @Override
-    public void b() {
-        super.b();
-
-        for (int i = 0; i < this.listeners.size(); ++i) {
-            ICrafting icrafting = (ICrafting) this.listeners.get(i);
+    //OilSpigot start
+    private boolean oilCompareNames(String correct, String toCompare) {
+        return correct.equals(toCompare) || correct.replace("","").equals(toCompare) || ChatColor.stripColor(correct).equals(ChatColor.stripColor(toCompare));
+    }
+    //OilSpigot end
 
-            //if (this.lastLevelCost != this.levelCost) { // Paper - this was the wrong solution to this, fixing it correctly in CraftPlayer
-                icrafting.setContainerData(this, 0, this.levelCost);
-            //} // Paper
+    //OilSpigot start - added level cost updating
+    @Override
+    public boolean update() {
+        boolean result = super.update();
+        if (levelCost != lastLevelCost) {
+            result = true;
+            for (int j = 0; j < this.listeners.size(); ++j) {
+                //Same as in Paper
+                ((ICrafting) this.listeners.get(j)).setContainerData(this, 0, this.levelCost);
+            }
         }
 
+
         this.lastLevelCost = this.levelCost;
+        return result;
     }
+    //OilSpigot end
 
     @Override
     public CraftInventoryView getBukkitView() {
diff --git a/src/main/java/net/minecraft/server/ContainerBeacon.java b/src/main/java/net/minecraft/server/ContainerBeacon.java
index 3f760781..3d06903e 100644
--- a/src/main/java/net/minecraft/server/ContainerBeacon.java
+++ b/src/main/java/net/minecraft/server/ContainerBeacon.java
@@ -68,24 +68,24 @@ public class ContainerBeacon extends Container {
 
             itemstack = itemstack1.cloneItemStack();
             if (i == 0) {
-                if (!this.a(itemstack1, 1, 37, true)) {
+                if (!this.a(entityhuman, itemstack1, 1, 37, true)) { //OilSpigot - added entityhuman param
                     return ItemStack.a;
                 }
 
                 slot.a(itemstack1, itemstack);
             } else if (!this.f.hasItem() && this.f.isAllowed(itemstack1) && itemstack1.getCount() == 1) {
-                if (!this.a(itemstack1, 0, 1, false)) {
+                if (!this.a(entityhuman, itemstack1, 0, 1, false)) { //OilSpigot - added entityhuman param
                     return ItemStack.a;
                 }
             } else if (i >= 1 && i < 28) {
-                if (!this.a(itemstack1, 28, 37, false)) {
+                if (!this.a(entityhuman, itemstack1, 28, 37, false)) { //OilSpigot - added entityhuman param
                     return ItemStack.a;
                 }
             } else if (i >= 28 && i < 37) {
-                if (!this.a(itemstack1, 1, 28, false)) {
+                if (!this.a(entityhuman, itemstack1, 1, 28, false)) { //OilSpigot - added entityhuman param
                     return ItemStack.a;
                 }
-            } else if (!this.a(itemstack1, 1, 37, false)) {
+            } else if (!this.a(entityhuman, itemstack1, 1, 37, false)) { //OilSpigot - added entityhuman param
                 return ItemStack.a;
             }
 
diff --git a/src/main/java/net/minecraft/server/ContainerBrewingStand.java b/src/main/java/net/minecraft/server/ContainerBrewingStand.java
index 0c7ab472..ad4c8e52 100644
--- a/src/main/java/net/minecraft/server/ContainerBrewingStand.java
+++ b/src/main/java/net/minecraft/server/ContainerBrewingStand.java
@@ -1,6 +1,7 @@
 package net.minecraft.server;
 
 // CraftBukkit start
+import org.oilmod.spigot.items.itemstackimpl.internal.ModItemStack;
 import org.bukkit.craftbukkit.inventory.CraftInventoryBrewer;
 import org.bukkit.craftbukkit.inventory.CraftInventoryView;
 // CraftBukkit end
@@ -45,24 +46,32 @@ public class ContainerBrewingStand extends Container {
         icrafting.setContainerData(this, this.brewingStand);
     }
 
-    public void b() {
-        super.b();
+    //OilSpigot start
+    public boolean update() {//OilSpigot changed result to boolean
+        boolean result = super.update();
 
-        for (int i = 0; i < this.listeners.size(); ++i) {
-            ICrafting icrafting = (ICrafting) this.listeners.get(i);
-
-            if (this.g != this.brewingStand.getProperty(0)) {
+        if (this.g != this.brewingStand.getProperty(0)) { //OilSpigot - optimised code: swapped if/for
+            for (int i = 0; i < this.listeners.size(); ++i) {
+                ICrafting icrafting = (ICrafting) this.listeners.get(i);
                 icrafting.setContainerData(this, 0, this.brewingStand.getProperty(0));
             }
+            result = true;
+        }
 
-            if (this.h != this.brewingStand.getProperty(1)) {
+        if (this.h != this.brewingStand.getProperty(1)) { //OilSpigot - optimised code: swapped if/for
+            for (int i = 0; i < this.listeners.size(); ++i) {
+                ICrafting icrafting = (ICrafting) this.listeners.get(i);
                 icrafting.setContainerData(this, 1, this.brewingStand.getProperty(1));
             }
+            result = true;
         }
 
         this.g = this.brewingStand.getProperty(0);
         this.h = this.brewingStand.getProperty(1);
+
+        return result;
     }
+    //OilSpigot end
 
     public boolean canUse(EntityHuman entityhuman) {
         if (!this.checkReachable) return true; // CraftBukkit
@@ -78,32 +87,32 @@ public class ContainerBrewingStand extends Container {
 
             itemstack = itemstack1.cloneItemStack();
             if ((i < 0 || i > 2) && i != 3 && i != 4) {
-                if (this.f.isAllowed(itemstack1)) {
-                    if (!this.a(itemstack1, 3, 4, false)) {
-                        return ItemStack.a;
+                if (!this.f.hasItem() && this.f.isAllowed(itemstack1)) {
+                    if (!this.a(entityhuman, itemstack1, 3, 4, false)) { //OilSpigot - added entityhuman param
+                        return null;
                     }
                 } else if (ContainerBrewingStand.SlotPotionBottle.c_(itemstack) && itemstack.getCount() == 1) {
-                    if (!this.a(itemstack1, 0, 3, false)) {
-                        return ItemStack.a;
+                    if (!this.a(entityhuman, itemstack1, 0, 3, false)) { //OilSpigot - added entityhuman param
+                        return null;
                     }
                 } else if (ContainerBrewingStand.a.b_(itemstack)) {
-                    if (!this.a(itemstack1, 4, 5, false)) {
-                        return ItemStack.a;
+                    if (!this.a(entityhuman, itemstack1, 4, 5, false)) { //OilSpigot - added entityhuman param
+                        return null;
                     }
                 } else if (i >= 5 && i < 32) {
-                    if (!this.a(itemstack1, 32, 41, false)) {
-                        return ItemStack.a;
+                    if (!this.a(entityhuman, itemstack1, 32, 41, false)) { //OilSpigot - added entityhuman param
+                        return null;
                     }
                 } else if (i >= 32 && i < 41) {
-                    if (!this.a(itemstack1, 5, 32, false)) {
-                        return ItemStack.a;
+                    if (!this.a(entityhuman, itemstack1, 5, 32, false)) { //OilSpigot - added entityhuman param
+                        return null;
                     }
-                } else if (!this.a(itemstack1, 5, 41, false)) {
-                    return ItemStack.a;
+                } else if (!this.a(entityhuman, itemstack1, 5, 41, false)) { //OilSpigot - added entityhuman param
+                    return null;
                 }
             } else {
-                if (!this.a(itemstack1, 5, 41, true)) {
-                    return ItemStack.a;
+                if (!this.a(entityhuman, itemstack1, 5, 41, true)) { //OilSpigot - added entityhuman param
+                    return null;
                 }
 
                 slot.a(itemstack1, itemstack);
@@ -136,7 +145,7 @@ public class ContainerBrewingStand extends Container {
         }
 
         public static boolean b_(ItemStack itemstack) {
-            return itemstack.getItem() == Items.BLAZE_POWDER;
+            return itemstack.getItem() == Items.BLAZE_POWDER && !(itemstack instanceof ModItemStack); //OilSpigot - deny use of modded items
         }
 
         public int getMaxStackSize() {
@@ -151,7 +160,7 @@ public class ContainerBrewingStand extends Container {
         }
 
         public boolean isAllowed(ItemStack itemstack) {
-            return PotionBrewer.a(itemstack);
+            return PotionBrewer.a(itemstack) && !(itemstack instanceof ModItemStack);//OilSpigot - deny use of modded items
         }
 
         public int getMaxStackSize() {
diff --git a/src/main/java/net/minecraft/server/ContainerChest.java b/src/main/java/net/minecraft/server/ContainerChest.java
index ea63cb29..66832a8b 100644
--- a/src/main/java/net/minecraft/server/ContainerChest.java
+++ b/src/main/java/net/minecraft/server/ContainerChest.java
@@ -49,7 +49,9 @@ public class ContainerChest extends Container {
 
         for (j = 0; j < this.f; ++j) {
             for (k = 0; k < 9; ++k) {
-                this.a(new Slot(iinventory1, k + j * 9, 8 + k * 18, 18 + j * 18));
+                //OilSpigot start
+                this.a(createChestSlot(iinventory1,j,k, k + j * 9, 8 + k * 18, 18 + j * 18));
+                //OilSpigot end
             }
         }
 
@@ -65,6 +67,12 @@ public class ContainerChest extends Container {
 
     }
 
+    //OilSpigot start
+    protected Slot createChestSlot(IInventory inventory, int row, int column, int index, int j, int k) {
+        return new Slot(inventory,index,j,k);
+    }
+    //OilSpigot end
+
     public boolean canUse(EntityHuman entityhuman) {
         if (!this.checkReachable) return true; // CraftBukkit
         return this.container.a(entityhuman);
@@ -79,10 +87,10 @@ public class ContainerChest extends Container {
 
             itemstack = itemstack1.cloneItemStack();
             if (i < this.f * 9) {
-                if (!this.a(itemstack1, this.f * 9, this.slots.size(), true)) {
+                if (!this.a(entityhuman, itemstack1, this.f * 9, this.slots.size(), true)) { //OilSpigot - added entityhuman param
                     return ItemStack.a;
                 }
-            } else if (!this.a(itemstack1, 0, this.f * 9, false)) {
+            } else if (!this.a(entityhuman, itemstack1, 0, this.f * 9, false)) { //OilSpigot - added entityhuman param
                 return ItemStack.a;
             }
 
diff --git a/src/main/java/net/minecraft/server/ContainerDispenser.java b/src/main/java/net/minecraft/server/ContainerDispenser.java
index 8b6533d0..de40dd7f 100644
--- a/src/main/java/net/minecraft/server/ContainerDispenser.java
+++ b/src/main/java/net/minecraft/server/ContainerDispenser.java
@@ -55,10 +55,10 @@ public class ContainerDispenser extends Container {
 
             itemstack = itemstack1.cloneItemStack();
             if (i < 9) {
-                if (!this.a(itemstack1, 9, 45, true)) {
+                if (!this.a(entityhuman, itemstack1, 9, 45, true)) { //OilSpigot - added entityhuman param
                     return ItemStack.a;
                 }
-            } else if (!this.a(itemstack1, 0, 9, false)) {
+            } else if (!this.a(entityhuman, itemstack1, 0, 9, false)) { //OilSpigot - added entityhuman param
                 return ItemStack.a;
             }
 
diff --git a/src/main/java/net/minecraft/server/ContainerEnchantTable.java b/src/main/java/net/minecraft/server/ContainerEnchantTable.java
index edb929cb..08feb1b6 100644
--- a/src/main/java/net/minecraft/server/ContainerEnchantTable.java
+++ b/src/main/java/net/minecraft/server/ContainerEnchantTable.java
@@ -16,6 +16,10 @@ import org.bukkit.event.enchantment.PrepareItemEnchantEvent;
 import org.bukkit.entity.Player;
 // CraftBukkit end
 
+//OilSpigot start
+import org.oilmod.spigot.items.itemstackimpl.internal.ModItemStack;
+//OilSpigot end
+
 public class ContainerEnchantTable extends Container {
 
     public IInventory enchantSlots = new InventorySubcontainer("Enchant", true, 2) {
@@ -42,6 +46,13 @@ public class ContainerEnchantTable extends Container {
     public int[] costs = new int[3];
     public int[] h = new int[] { -1, -1, -1};
     public int[] i = new int[] { -1, -1, -1};
+    //OilSpigot start
+    private int oldSeed;
+    private int[] oldcosts = new int[3];
+    private int[] oldPreview = new int[] { -1, -1, -1};
+    private int[] oldExtra = new int[] { -1, -1, -1};
+    private boolean forceUpdate = false;
+    //OilSpigot end
     // CraftBukkit start
     private CraftInventoryView bukkitEntity = null;
     private Player player;
@@ -101,16 +112,37 @@ public class ContainerEnchantTable extends Container {
         this.c(icrafting);
     }
 
-    public void b() {
-        super.b();
+    //OilSpigot start
+    public boolean update() {
+        return update(false);
+    }
 
-        for (int i = 0; i < this.listeners.size(); ++i) {
-            ICrafting icrafting = (ICrafting) this.listeners.get(i);
+    public boolean update(boolean force) {
+        boolean result = super.update();
+        if (forceUpdate || result || force || costs[0] != oldcosts [0] || costs[1] != oldcosts [1] || costs[2] != oldcosts [2] || f != oldSeed || h[0] != oldPreview [0] || h[1] != oldPreview[1] || h[2] != oldPreview [2]) { //OilSpigot - only send if changed or itemstack changed (this is needed for manipulated enchanting because you need to fool the client)
+            result = true;
+            for (int i = 0; i < this.listeners.size(); ++i) {
+                ICrafting icrafting = (ICrafting) this.listeners.get(i);
 
-            this.c(icrafting);
+                this.c(icrafting);
+            }
+            //OilSpigot start
+            oldcosts[0] = costs[0];
+            oldcosts[1] = costs[1];
+            oldcosts[2] = costs[2];
+            oldSeed = f;
+            oldPreview[0] = h[0];
+            oldPreview[1] = h[1];
+            oldPreview[2] = h[2];
+            oldExtra[0] = i[0];
+            oldExtra[1] = i[1];
+            oldExtra[2] = i[2];
+            //OilSpigot end
         }
-
+        forceUpdate = force; //if update is forced it will update the client on the next tick as well. this is needed because client behaves weird
+        return result;
     }
+    //OilSpigot end
 
     public void a(IInventory iinventory) {
         if (iinventory == this.enchantSlots) {
@@ -214,7 +246,7 @@ public class ContainerEnchantTable extends Container {
                     }
                     // CraftBukkit end
 
-                    this.b();
+                    this.update(true); //OilSpigot - forces update
                 }
             } else {
                 for (i = 0; i < 3; ++i) {
@@ -230,6 +262,9 @@ public class ContainerEnchantTable extends Container {
     public boolean a(EntityHuman entityhuman, int i) {
         ItemStack itemstack = this.enchantSlots.getItem(0);
         ItemStack itemstack1 = this.enchantSlots.getItem(1);
+        //OilSpigot start - check if unnamed before
+        boolean unnamed = itemstack instanceof ModItemStack && ((ModItemStack) itemstack).getCorrectDisplayName().equals(itemstack.getName());
+
         int j = i + 1;
 
         if ((itemstack1.isEmpty() || itemstack1.getCount() < j) && !entityhuman.abilities.canInstantlyBuild) {
@@ -291,6 +326,12 @@ public class ContainerEnchantTable extends Container {
                         }
                     }
 
+                    //OilSpigot start
+                    if (unnamed) {
+                        itemstack.s(); //Need to update the name because enchanted items have a blue name
+                    }
+                    //OilSpigot end
+
                     entityhuman.b(StatisticList.W);
                     if (entityhuman instanceof EntityPlayer) {
                         CriterionTriggers.i.a((EntityPlayer) entityhuman, itemstack, j);
@@ -334,7 +375,8 @@ public class ContainerEnchantTable extends Container {
 
     public boolean canUse(EntityHuman entityhuman) {
         if (!this.checkReachable) return true; // CraftBukkit
-        return this.world.getType(this.position).getBlock() != Blocks.ENCHANTING_TABLE ? false : entityhuman.d((double) this.position.getX() + 0.5D, (double) this.position.getY() + 0.5D, (double) this.position.getZ() + 0.5D) <= 64.0D;
+        //OilSpigot - no logic change just simplified
+        return this.world.getType(this.position).getBlock() == Blocks.ENCHANTING_TABLE && entityhuman.d((double) this.position.getX() + 0.5D, (double) this.position.getY() + 0.5D, (double) this.position.getZ() + 0.5D) <= 64.0D;
     }
 
     public ItemStack shiftClick(EntityHuman entityhuman, int i) {
@@ -346,15 +388,15 @@ public class ContainerEnchantTable extends Container {
 
             itemstack = itemstack1.cloneItemStack();
             if (i == 0) {
-                if (!this.a(itemstack1, 2, 38, true)) {
+                if (!this.a(entityhuman, itemstack1, 2, 38, true)) { //OilSpigot - added entityhuman param
                     return ItemStack.a;
                 }
             } else if (i == 1) {
-                if (!this.a(itemstack1, 2, 38, true)) {
+                if (!this.a(entityhuman, itemstack1, 2, 38, true)) { //OilSpigot - added entityhuman param
                     return ItemStack.a;
                 }
             } else if (itemstack1.getItem() == Items.DYE && EnumColor.fromInvColorIndex(itemstack1.getData()) == EnumColor.BLUE) {
-                if (!this.a(itemstack1, 1, 2, true)) {
+                if (!this.a(entityhuman, itemstack1, 1, 2, true)) { //OilSpigot - added entityhuman param
                     return ItemStack.a;
                 }
             } else {
diff --git a/src/main/java/net/minecraft/server/ContainerFurnace.java b/src/main/java/net/minecraft/server/ContainerFurnace.java
index 0970e537..2ddb51ac 100644
--- a/src/main/java/net/minecraft/server/ContainerFurnace.java
+++ b/src/main/java/net/minecraft/server/ContainerFurnace.java
@@ -3,6 +3,8 @@ package net.minecraft.server;
 // CraftBukkit start
 import org.bukkit.craftbukkit.inventory.CraftInventoryFurnace;
 import org.bukkit.craftbukkit.inventory.CraftInventoryView;
+
+import static org.bukkit.inventory.EquipmentSlot.HEAD;
 // CraftBukkit end
 
 public class ContainerFurnace extends Container {
@@ -31,9 +33,8 @@ public class ContainerFurnace extends Container {
 
     public ContainerFurnace(PlayerInventory playerinventory, IInventory iinventory) {
         this.furnace = iinventory;
-        this.a(new Slot(iinventory, 0, 56, 17));
-        this.a((Slot) (new SlotFurnaceFuel(iinventory, 1, 56, 53)));
-        this.a((Slot) (new SlotFurnaceResult(playerinventory.player, iinventory, 2, 116, 35)));
+        //OilSpigot start - use method instead
+        addFurnaceSlots(playerinventory, iinventory);
         this.player = playerinventory; // CraftBukkit - save player
 
         int i;
@@ -50,31 +51,43 @@ public class ContainerFurnace extends Container {
 
     }
 
+    //OilSpigot start
+    protected void addFurnaceSlots(PlayerInventory playerinventory, IInventory iinventory) {
+        this.a(new Slot(iinventory, 0, 56, 17));
+        this.a((Slot) (new SlotFurnaceFuel(iinventory, 1, 56, 53)));
+        this.a((Slot) (new SlotFurnaceResult(playerinventory.player, iinventory, 2, 116, 35)));
+    }
+    //OilSpigot end
+
     public void addSlotListener(ICrafting icrafting) {
         super.addSlotListener(icrafting);
         icrafting.setContainerData(this, this.furnace);
     }
 
-    public void b() {
-        super.b();
+    public boolean update() { //OilSpigot changed to boolean
+        boolean result = super.update();
 
         for (int i = 0; i < this.listeners.size(); ++i) {
             ICrafting icrafting = (ICrafting) this.listeners.get(i);
 
             if (this.f != this.furnace.getProperty(2)) {
                 icrafting.setContainerData(this, 2, this.furnace.getProperty(2));
+                result = true;
             }
 
             if (this.h != this.furnace.getProperty(0)) {
                 icrafting.setContainerData(this, 0, this.furnace.getProperty(0));
+                result = true;
             }
 
             if (this.i != this.furnace.getProperty(1)) {
                 icrafting.setContainerData(this, 1, this.furnace.getProperty(1));
+                result = true;
             }
 
             if (this.g != this.furnace.getProperty(3)) {
                 icrafting.setContainerData(this, 3, this.furnace.getProperty(3));
+                result = true;
             }
         }
 
@@ -82,6 +95,7 @@ public class ContainerFurnace extends Container {
         this.h = this.furnace.getProperty(0);
         this.i = this.furnace.getProperty(1);
         this.g = this.furnace.getProperty(3);
+        return result;
     }
 
     public boolean canUse(EntityHuman entityhuman) {
@@ -98,28 +112,28 @@ public class ContainerFurnace extends Container {
 
             itemstack = itemstack1.cloneItemStack();
             if (i == 2) {
-                if (!this.a(itemstack1, 3, 39, true)) {
+                if (!this.a(entityhuman, itemstack1, 3, 39, true)) { //OilSpigot - added entityhuman param
                     return ItemStack.a;
                 }
 
                 slot.a(itemstack1, itemstack);
             } else if (i != 1 && i != 0) {
                 if (!RecipesFurnace.getInstance().getResult(itemstack1).isEmpty()) {
-                    if (!this.a(itemstack1, 0, 1, false)) {
+                    if (!this.a(entityhuman, itemstack1, 0, 1, false)) { //OilSpigot - added entityhuman param
                         return ItemStack.a;
                     }
                 } else if (TileEntityFurnace.isFuel(itemstack1)) {
-                    if (!this.a(itemstack1, 1, 2, false)) {
+                    if (!this.a(entityhuman, itemstack1, 1, 2, false)) { //OilSpigot - added entityhuman param
                         return ItemStack.a;
                     }
                 } else if (i >= 3 && i < 30) {
-                    if (!this.a(itemstack1, 30, 39, false)) {
+                    if (!this.a(entityhuman, itemstack1, 30, 39, false)) { //OilSpigot - added entityhuman param
                         return ItemStack.a;
                     }
-                } else if (i >= 30 && i < 39 && !this.a(itemstack1, 3, 30, false)) {
+                } else if (i >= 30 && i < 39 && !this.a(entityhuman, itemstack1, 3, 30, false)) { //OilSpigot - added entityhuman param
                     return ItemStack.a;
                 }
-            } else if (!this.a(itemstack1, 3, 39, false)) {
+            } else if (!this.a(entityhuman, itemstack1, 3, 39, false)) { //OilSpigot - added entityhuman param
                 return ItemStack.a;
             }
 
diff --git a/src/main/java/net/minecraft/server/ContainerHopper.java b/src/main/java/net/minecraft/server/ContainerHopper.java
index 1d7a3832..971bbec2 100644
--- a/src/main/java/net/minecraft/server/ContainerHopper.java
+++ b/src/main/java/net/minecraft/server/ContainerHopper.java
@@ -34,7 +34,9 @@ public class ContainerHopper extends Container {
         int i;
 
         for (i = 0; i < iinventory.getSize(); ++i) {
-            this.a(new Slot(iinventory, i, 44 + i * 18, 20));
+            //OilSpigot start
+            this.a(createChestSlot(iinventory, i, 44 + i * 18, 20));
+            //OilSpigot end
         }
 
         for (i = 0; i < 3; ++i) {
@@ -49,6 +51,12 @@ public class ContainerHopper extends Container {
 
     }
 
+    //OilSpigot start
+    protected Slot createChestSlot(IInventory inventory, int index, int j, int k) {
+        return new Slot(inventory,index,j,k);
+    }
+    //OilSpigot end
+
     public boolean canUse(EntityHuman entityhuman) {
         if (!this.checkReachable) return true; // CraftBukkit
         return this.hopper.a(entityhuman);
@@ -63,10 +71,10 @@ public class ContainerHopper extends Container {
 
             itemstack = itemstack1.cloneItemStack();
             if (i < this.hopper.getSize()) {
-                if (!this.a(itemstack1, this.hopper.getSize(), this.slots.size(), true)) {
+                if (!this.a(entityhuman, itemstack1, this.hopper.getSize(), this.slots.size(), true)) { //OilSpigot - added entityhuman param
                     return ItemStack.a;
                 }
-            } else if (!this.a(itemstack1, 0, this.hopper.getSize(), false)) {
+            } else if (!this.a(entityhuman, itemstack1, 0, this.hopper.getSize(), false)) { //OilSpigot - added entityhuman param
                 return ItemStack.a;
             }
 
diff --git a/src/main/java/net/minecraft/server/ContainerHorse.java b/src/main/java/net/minecraft/server/ContainerHorse.java
index 1f2d0a58..9864ca7e 100644
--- a/src/main/java/net/minecraft/server/ContainerHorse.java
+++ b/src/main/java/net/minecraft/server/ContainerHorse.java
@@ -83,18 +83,18 @@ public class ContainerHorse extends Container {
 
             itemstack = itemstack1.cloneItemStack();
             if (i < this.a.getSize()) {
-                if (!this.a(itemstack1, this.a.getSize(), this.slots.size(), true)) {
+                if (!this.a(entityhuman, itemstack1, this.a.getSize(), this.slots.size(), true)) {//OilSpigot - added entityhuman param
                     return ItemStack.a;
                 }
             } else if (this.getSlot(1).isAllowed(itemstack1) && !this.getSlot(1).hasItem()) {
-                if (!this.a(itemstack1, 1, 2, false)) {
+                if (!this.a(entityhuman, itemstack1, 1, 2, false)) {//OilSpigot - added entityhuman param
                     return ItemStack.a;
                 }
             } else if (this.getSlot(0).isAllowed(itemstack1)) {
-                if (!this.a(itemstack1, 0, 1, false)) {
+                if (!this.a(entityhuman, itemstack1, 0, 1, false)) {//OilSpigot - added entityhuman param
                     return ItemStack.a;
                 }
-            } else if (this.a.getSize() <= 2 || !this.a(itemstack1, 2, this.a.getSize(), false)) {
+            } else if (this.a.getSize() <= 2 || !this.a(entityhuman, itemstack1, 2, this.a.getSize(), false)) {//OilSpigot - added entityhuman param
                 return ItemStack.a;
             }
 
diff --git a/src/main/java/net/minecraft/server/ContainerMerchant.java b/src/main/java/net/minecraft/server/ContainerMerchant.java
index 8dc071ef..e53d91dd 100644
--- a/src/main/java/net/minecraft/server/ContainerMerchant.java
+++ b/src/main/java/net/minecraft/server/ContainerMerchant.java
@@ -48,8 +48,12 @@ public class ContainerMerchant extends Container {
         return this.f;
     }
 
+    public void addSlotListener(ICrafting icrafting) {
+        super.addSlotListener(icrafting);
+    }
+
     public void a(IInventory iinventory) {
-        this.f.i();
+            this.f.i();
         super.a(iinventory);
     }
 
@@ -70,20 +74,20 @@ public class ContainerMerchant extends Container {
 
             itemstack = itemstack1.cloneItemStack();
             if (i == 2) {
-                if (!this.a(itemstack1, 3, 39, true)) {
+                if (!this.a(entityhuman, itemstack1, 3, 39, true)) { //OilSpigot - added entityhuman param
                     return ItemStack.a;
                 }
 
                 slot.a(itemstack1, itemstack);
             } else if (i != 0 && i != 1) {
                 if (i >= 3 && i < 30) {
-                    if (!this.a(itemstack1, 30, 39, false)) {
+                    if (!this.a(entityhuman, itemstack1, 30, 39, false)) { //OilSpigot - added entityhuman param
                         return ItemStack.a;
                     }
-                } else if (i >= 30 && i < 39 && !this.a(itemstack1, 3, 30, false)) {
+                } else if (i >= 30 && i < 39 && !this.a(entityhuman, itemstack1, 3, 30, false)) { //OilSpigot - added entityhuman param
                     return ItemStack.a;
                 }
-            } else if (!this.a(itemstack1, 3, 39, false)) {
+            } else if (!this.a(entityhuman, itemstack1, 3, 39, false)) { //OilSpigot - added entityhuman param
                 return ItemStack.a;
             }
 
diff --git a/src/main/java/net/minecraft/server/ContainerPlayer.java b/src/main/java/net/minecraft/server/ContainerPlayer.java
index 2397ebf5..01a44def 100644
--- a/src/main/java/net/minecraft/server/ContainerPlayer.java
+++ b/src/main/java/net/minecraft/server/ContainerPlayer.java
@@ -1,15 +1,18 @@
 package net.minecraft.server;
 
 // CraftBukkit start
+import net.minecraft.server.oilmod.ICraftingContainer;
+import net.minecraft.server.oilmod.IInventoryCraftResult;
+import net.minecraft.server.oilmod.IInventoryCrafting;
 import org.bukkit.craftbukkit.inventory.CraftInventoryCrafting;
 import org.bukkit.craftbukkit.inventory.CraftInventoryView;
 // CraftBukkit end
 
-public class ContainerPlayer extends Container {
+public class ContainerPlayer extends Container implements ICraftingContainer { //OilSpigot implements ICraftingContainer
 
     private static final EnumItemSlot[] h = new EnumItemSlot[] { EnumItemSlot.HEAD, EnumItemSlot.CHEST, EnumItemSlot.LEGS, EnumItemSlot.FEET};
     public InventoryCrafting craftInventory = new InventoryCrafting(this, 2, 2);
-    public InventoryCraftResult resultInventory = new InventoryCraftResult();
+    public IInventoryCraftResult resultInventory = new InventoryCraftResult(); //OilSpigot change to IInventoryCraftResult
     public boolean g;
     private final EntityHuman owner;
     // CraftBukkit start
@@ -72,7 +75,7 @@ public class ContainerPlayer extends Container {
     }
 
     public void a(IInventory iinventory) {
-        this.a(this.owner.world, this.owner, this.craftInventory, this.resultInventory);
+        Container.a(this.owner.world, this.owner, this.craftInventory, this.resultInventory, CraftingManager.getInstance(), this);//OilSpigot - changed to static
     }
 
     public void b(EntityHuman entityhuman) {
@@ -98,38 +101,38 @@ public class ContainerPlayer extends Container {
             EnumItemSlot enumitemslot = EntityInsentient.d(itemstack);
 
             if (i == 0) {
-                if (!this.a(itemstack1, 9, 45, true)) {
+                if (!this.a(entityhuman, itemstack1, 9, 45, true)) { //OilSpigot - added entityhuman param
                     return ItemStack.a;
                 }
 
                 slot.a(itemstack1, itemstack);
             } else if (i >= 1 && i < 5) {
-                if (!this.a(itemstack1, 9, 45, false)) {
+                if (!this.a(entityhuman, itemstack1, 9, 45, false)) { //OilSpigot - added entityhuman param
                     return ItemStack.a;
                 }
             } else if (i >= 5 && i < 9) {
-                if (!this.a(itemstack1, 9, 45, false)) {
+                if (!this.a(entityhuman, itemstack1, 9, 45, false)) { //OilSpigot - added entityhuman param
                     return ItemStack.a;
                 }
-            } else if (enumitemslot.a() == EnumItemSlot.Function.ARMOR && !((Slot) this.slots.get(8 - enumitemslot.b())).hasItem()) {
+            } else if (enumitemslot.a() == EnumItemSlot.Function.ARMOR && !((Slot) this.slots.get(8 - enumitemslot.b())).hasItem()) { 
                 int j = 8 - enumitemslot.b();
 
-                if (!this.a(itemstack1, j, j + 1, false)) {
+                if (!this.a(entityhuman, itemstack1, j, j + 1, false)) { //OilSpigot - added entityhuman param
                     return ItemStack.a;
                 }
             } else if (enumitemslot == EnumItemSlot.OFFHAND && !((Slot) this.slots.get(45)).hasItem()) {
-                if (!this.a(itemstack1, 45, 46, false)) {
+                if (!this.a(entityhuman, itemstack1, 45, 46, false)) { //OilSpigot - added entityhuman param
                     return ItemStack.a;
                 }
             } else if (i >= 9 && i < 36) {
-                if (!this.a(itemstack1, 36, 45, false)) {
+                if (!this.a(entityhuman, itemstack1, 36, 45, false)) { //OilSpigot - added entityhuman param
                     return ItemStack.a;
                 }
             } else if (i >= 36 && i < 45) {
-                if (!this.a(itemstack1, 9, 36, false)) {
+                if (!this.a(entityhuman, itemstack1, 9, 36, false)) { //OilSpigot - added entityhuman param
                     return ItemStack.a;
                 }
-            } else if (!this.a(itemstack1, 9, 45, false)) {
+            } else if (!this.a(entityhuman, itemstack1, 9, 45, false)) { //OilSpigot - added entityhuman param
                 return ItemStack.a;
             }
 
@@ -154,7 +157,7 @@ public class ContainerPlayer extends Container {
     }
 
     public boolean a(ItemStack itemstack, Slot slot) {
-        return slot.inventory != this.resultInventory && super.a(itemstack, slot);
+        return slot.getInventory() != this.resultInventory && super.a(itemstack, slot); //OilSpigot - changed .inventory to .getInventory()
     }
 
     // CraftBukkit start
@@ -169,4 +172,24 @@ public class ContainerPlayer extends Container {
         return bukkitEntity;
     }
     // CraftBukkit end
+
+
+    //OilSpigot start
+    protected int hotbarSlotToPacketSlot(int i) {
+        return 36+i;
+    }
+    //OilSpigot end
+
+
+    //OilSpigot start
+    @Override
+    public IInventoryCrafting getCraftingInventory() {
+        return craftInventory;
+    }
+
+    @Override
+    public IInventoryCraftResult getResultInventory() {
+        return resultInventory;
+    }
+    //OilSpigot end
 }
diff --git a/src/main/java/net/minecraft/server/ContainerShulkerBox.java b/src/main/java/net/minecraft/server/ContainerShulkerBox.java
index 5f217978..00c24474 100644
--- a/src/main/java/net/minecraft/server/ContainerShulkerBox.java
+++ b/src/main/java/net/minecraft/server/ContainerShulkerBox.java
@@ -64,10 +64,12 @@ public class ContainerShulkerBox extends Container {
 
             itemstack = itemstack1.cloneItemStack();
             if (i < this.a.getSize()) {
-                if (!this.a(itemstack1, this.a.getSize(), this.slots.size(), true)) {
+                //OilSpigot added EntityHuman param
+                if (!this.a(entityhuman, itemstack1, this.a.getSize(), this.slots.size(), true)) {
                     return ItemStack.a;
                 }
-            } else if (!this.a(itemstack1, 0, this.a.getSize(), false)) {
+                //OilSpigot added EntityHuman param
+            } else if (!this.a(entityhuman, itemstack1, 0, this.a.getSize(), false)) {
                 return ItemStack.a;
             }
 
diff --git a/src/main/java/net/minecraft/server/ContainerUtil.java b/src/main/java/net/minecraft/server/ContainerUtil.java
new file mode 100644
index 00000000..9b90f9dd
--- /dev/null
+++ b/src/main/java/net/minecraft/server/ContainerUtil.java
@@ -0,0 +1,56 @@
+package net.minecraft.server;
+
+import java.util.List;
+
+//KEEPSYNC
+public class ContainerUtil {
+
+    public static ItemStack a(List<ItemStack> list, int i, int j) {
+        return i >= 0 && i < list.size() && !((ItemStack) list.get(i)).isEmpty() && j > 0 ? ((ItemStack) list.get(i)).cloneAndSubtract(j) : ItemStack.a;
+    }
+
+    public static ItemStack a(List<ItemStack> list, int i) {
+        return i >= 0 && i < list.size() ? (ItemStack) list.set(i, ItemStack.a) : ItemStack.a;
+    }
+
+    public static NBTTagCompound a(NBTTagCompound nbttagcompound, NonNullList<ItemStack> nonnulllist) {
+        return a(nbttagcompound, nonnulllist, true);
+    }
+
+    public static NBTTagCompound a(NBTTagCompound nbttagcompound, NonNullList<ItemStack> nonnulllist, boolean flag) {
+        NBTTagList nbttaglist = new NBTTagList();
+
+        for (int i = 0; i < nonnulllist.size(); ++i) {
+            ItemStack itemstack = (ItemStack) nonnulllist.get(i);
+
+            if (!itemstack.isEmpty()) {
+                NBTTagCompound nbttagcompound1 = new NBTTagCompound();
+
+                nbttagcompound1.setByte("Slot", (byte) i);
+                itemstack.save(nbttagcompound1);
+                nbttaglist.add(nbttagcompound1);
+            }
+        }
+
+        if (!nbttaglist.isEmpty() || flag) {
+            nbttagcompound.set("Items", nbttaglist);
+        }
+
+        return nbttagcompound;
+    }
+
+    public static void b(NBTTagCompound nbttagcompound, NonNullList<ItemStack> nonnulllist) {
+        NBTTagList nbttaglist = nbttagcompound.getList("Items", 10);
+
+        for (int i = 0; i < nbttaglist.size(); ++i) {
+            NBTTagCompound nbttagcompound1 = nbttaglist.get(i);
+            int j = nbttagcompound1.getByte("Slot") & 255;
+
+            if (j >= 0 && j < nonnulllist.size()) {
+                //OilSPigot use factory method
+                nonnulllist.set(j, ItemStack.createStack(nbttagcompound1));
+            }
+        }
+
+    }
+}
diff --git a/src/main/java/net/minecraft/server/ContainerWorkbench.java b/src/main/java/net/minecraft/server/ContainerWorkbench.java
index f07e81f8..0d70f519 100644
--- a/src/main/java/net/minecraft/server/ContainerWorkbench.java
+++ b/src/main/java/net/minecraft/server/ContainerWorkbench.java
@@ -1,14 +1,22 @@
 package net.minecraft.server;
 
 // CraftBukkit start
+import net.minecraft.server.oilmod.ICraftingContainer;
+import net.minecraft.server.oilmod.IInventoryCraftResult;
+import net.minecraft.server.oilmod.IInventoryCrafting;
 import org.bukkit.craftbukkit.inventory.CraftInventoryCrafting;
 import org.bukkit.craftbukkit.inventory.CraftInventoryView;
 // CraftBukkit end
 
-public class ContainerWorkbench extends Container {
+public class ContainerWorkbench extends Container implements ICraftingContainer { //OilSpigot implements ICraftingContainer
 
-    public InventoryCrafting craftInventory; // CraftBukkit - move initialization into constructor
-    public InventoryCraftResult resultInventory; // CraftBukkit - move initialization into constructor
+    //OilSpigot start
+    // OilSpigot - changed from InventoryCrafting to IInventoryCrafting
+    // OilSpigot - changed from public modifier to private
+    private IInventoryCrafting craftInventory; // CraftBukkit - move initialization into constructor
+    // OilSpigot - changed from public modifier to private
+    private IInventoryCraftResult resultInventory; // CraftBukkit - move initialization into constructor
+    /*OilSpigot stop*/
     private final World g;
     private final BlockPosition h;
     private final EntityHuman i;
@@ -17,17 +25,29 @@ public class ContainerWorkbench extends Container {
     private PlayerInventory player;
     // CraftBukkit end
 
+    //OilSpigot start
     public ContainerWorkbench(PlayerInventory playerinventory, World world, BlockPosition blockposition) {
         // CraftBukkit start - Switched order of IInventory construction and stored player
-        this.resultInventory = new InventoryCraftResult();
-        this.craftInventory = new InventoryCrafting(this, 3, 3, playerinventory.player); // CraftBukkit - pass player
-        this.craftInventory.resultInventory = this.resultInventory;
+        this(playerinventory,new InventoryCrafting(3, 3, playerinventory.player),new InventoryCraftResult(),world,blockposition);// CraftBukkit - pass player
+        this.craftInventory.setResultInventory(this.resultInventory);
+        ((InventoryCrafting)this.craftInventory).setContainer(this);
+    }
+
+    public ContainerWorkbench(PlayerInventory playerinventory, IInventoryCrafting craftInventory, IInventoryCraftResult resultInventory, World world, BlockPosition blockposition) {
+        //OilSpigot start
+        this.resultInventory = resultInventory;
+        this.craftInventory = craftInventory;
+        this.craftInventory.setResultInventory(this.resultInventory);
+        /*OilSpigot stop*/
         this.player = playerinventory;
         // CraftBukkit end
         this.g = world;
         this.h = blockposition;
         this.i = playerinventory.player;
-        this.a((Slot) (new SlotResult(playerinventory.player, this.craftInventory, this.resultInventory, 0, 124, 35)));
+
+        //OilSpigot start
+        addResultSlot(playerinventory,craftInventory,resultInventory);
+        /*OilSpigot stop*/
 
         int i;
         int j;
@@ -48,22 +68,32 @@ public class ContainerWorkbench extends Container {
             this.a(new Slot(playerinventory, i, 8 + i * 18, 142));
         }
 
+        this.a((IInventory) this.craftInventory);
     }
 
+
+    protected void addResultSlot(PlayerInventory playerinventory, IInventoryCrafting craftInventory, IInventory resultInventory) {
+        this.a((Slot) (new SlotResult(playerinventory.player, (InventoryCrafting) craftInventory, resultInventory, 0, 124, 35)));
+    }
+    /*OilSpigot stop*/
+
+
     public void a(IInventory iinventory) {
-        this.a(this.g, this.i, this.craftInventory, this.resultInventory);
+        a(this.g, this.i, this.craftInventory, this.resultInventory, CraftingManager.getInstance(), this); //OilSpigot use standard crafting manager for normal workbenches
     }
 
     public void b(EntityHuman entityhuman) {
         super.b(entityhuman);
-        if (!this.g.isClientSide) {
+        //OilSpigot check if null first todo: is this necessary
+        if (this.g != null && !this.g.isClientSide) {
             this.a(entityhuman, this.g, this.craftInventory);
         }
     }
 
     public boolean canUse(EntityHuman entityhuman) {
         if (!this.checkReachable) return true; // CraftBukkit
-        return this.g.getType(this.h).getBlock() != Blocks.CRAFTING_TABLE ? false : entityhuman.d((double) this.h.getX() + 0.5D, (double) this.h.getY() + 0.5D, (double) this.h.getZ() + 0.5D) <= 64.0D;
+        //OilSpigot no logic change, just simplified
+        return this.g.getType(this.h).getBlock() == Blocks.CRAFTING_TABLE && entityhuman.d((double) this.h.getX() + 0.5D, (double) this.h.getY() + 0.5D, (double) this.h.getZ() + 0.5D) <= 64.0D;
     }
 
     public ItemStack shiftClick(EntityHuman entityhuman, int i) {
@@ -76,20 +106,20 @@ public class ContainerWorkbench extends Container {
             itemstack = itemstack1.cloneItemStack();
             if (i == 0) {
                 itemstack1.getItem().b(itemstack1, this.g, entityhuman);
-                if (!this.a(itemstack1, 10, 46, true)) {
+                if (!this.a(entityhuman, itemstack1, 10, 46, true)) { //OilSpigot - added entityhuman param
                     return ItemStack.a;
                 }
 
                 slot.a(itemstack1, itemstack);
             } else if (i >= 10 && i < 37) {
-                if (!this.a(itemstack1, 37, 46, false)) {
+                if (!this.a(entityhuman, itemstack1, 37, 46, false)) { //OilSpigot - added entityhuman param
                     return ItemStack.a;
                 }
             } else if (i >= 37 && i < 46) {
-                if (!this.a(itemstack1, 10, 37, false)) {
+                if (!this.a(entityhuman, itemstack1, 10, 37, false)) { //OilSpigot - added entityhuman param
                     return ItemStack.a;
                 }
-            } else if (!this.a(itemstack1, 10, 46, false)) {
+            } else if (!this.a(entityhuman, itemstack1, 10, 46, false)) { //OilSpigot - added entityhuman param
                 return ItemStack.a;
             }
 
@@ -114,7 +144,7 @@ public class ContainerWorkbench extends Container {
     }
 
     public boolean a(ItemStack itemstack, Slot slot) {
-        return slot.inventory != this.resultInventory && super.a(itemstack, slot);
+        return slot.getInventory() != this.resultInventory && super.a(itemstack, slot); //OilSpigot - changed .inventory to .getInventory()
     }
 
     // CraftBukkit start
@@ -124,9 +154,22 @@ public class ContainerWorkbench extends Container {
             return bukkitEntity;
         }
 
+        System.out.println("resultInventory=" + (resultInventory==null?"null":resultInventory.toString())); //OilSpigot debug
         CraftInventoryCrafting inventory = new CraftInventoryCrafting(this.craftInventory, this.resultInventory);
         bukkitEntity = new CraftInventoryView(this.player.player.getBukkitEntity(), inventory, this);
         return bukkitEntity;
     }
     // CraftBukkit end
+
+    //OilSpigot start
+    @Override
+    public IInventoryCrafting getCraftingInventory() {
+        return craftInventory;
+    }
+
+    @Override
+    public IInventoryCraftResult getResultInventory() {
+        return resultInventory;
+    }
+    //OilSpigot end
 }
diff --git a/src/main/java/net/minecraft/server/CraftingManager.java b/src/main/java/net/minecraft/server/CraftingManager.java
index 288f7a17..4a9eabe1 100644
--- a/src/main/java/net/minecraft/server/CraftingManager.java
+++ b/src/main/java/net/minecraft/server/CraftingManager.java
@@ -19,40 +19,148 @@ import java.nio.file.Paths;
 import java.util.Collections;
 import java.util.Iterator;
 import javax.annotation.Nullable;
+
+import net.minecraft.server.oilmod.IInventoryCrafting;
 import org.apache.commons.io.FilenameUtils;
 import org.apache.commons.io.IOUtils;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
+//OilSpigot start
+import org.oilmod.spigot.items.itemstackimpl.crafting.OilRecipe;
+import org.oilmod.spigot.items.itemstackimpl.crafting.help.CHView;
+import org.oilmod.spigot.items.itemstackimpl.crafting.nms.NMS_OilRecipe;
+
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Set;
+import gnu.trove.set.hash.THashSet;
+
+import com.google.common.collect.Lists;
+//OilSpigot end
+
+//OilSpigot - completely restructured to allow more than one instance. It is advised to rather look at the diff of two paper version then trying to update this class by a merge.
 public class CraftingManager {
+    //OilSpigot start
+    private static final CraftingManager instance; //OilSpigot renamed to instance
+    private static final CraftingManager defaultManager; //OilSpigot
+    private RegistryMaterials<MinecraftKey, IRecipe> recipes = new RegistryMaterials<>(); //OilSpigot Pail public to private, removed static, final
+    private static RegistryMaterials<MinecraftKey, IRecipe> recipesGlobal = new RegistryMaterials<>(); //OilSpigot Pail public to private, removed static, final
+    private static int globalId = 0;
+    public final List<CHView> oilChViews = Lists.newArrayList();
+    public final List<CHView> vanillaChViews = Lists.newArrayList();
+    public final List<CHView> vanillaSpecialChViews = Lists.newArrayList();
+    private static final List<CraftingManager> CRAFTING_MANAGERS = new LinkedList<>();
+    public static final List<CraftingManager> REGISTERED_CRAFTING_MANAGERS = Collections.unmodifiableList(CRAFTING_MANAGERS);
+    public final ItemStack helpDisplayItem;
+    public final ItemStack helpDisplayItem2;
+    public final String name;
+
+    public static CraftingManager getInstance() {
+        return CraftingManager.instance;
+    }
+    //OilSpigot end
 
     private static final Logger b = LogManager.getLogger();
-    private static int c;
-    public static RegistryMaterials<MinecraftKey, IRecipe> recipes = new RegistryMaterials();
+    //private int count; //OilSpigot remove c / count
+    //debug readd later
+
+    //TODO: consider updating player with all crafting recipes of the current craftingtable so that he only sees the right ones
+    //TODO: reorganise to make future merge/updates easier (maybe its good like this, try to conserve same order an vanilla)
+    //OilSpigot start - TODO: only register vanilla recipes in standard CraftingManager
 
-    public CraftingManager() {}
 
+
+    static {
+        defaultManager = new CraftingManager(new ItemStack(Blocks.CRAFTING_TABLE), new ItemStack(Items.BANNER, 1, 2), "Crafting Table - Defaults");
+        instance = new CraftingManager(new ItemStack(Blocks.CRAFTING_TABLE), new ItemStack(Items.BANNER, 1, 2), "Crafting Table");
+    }
+    
+    
     public static boolean init() {
         try {
-            CraftingManager.c = 0; // Reset recipe ID count
-            a("armordye", new RecipeArmorDye());
-            a("bookcloning", new RecipeBookClone());
-            a("mapcloning", new RecipeMapClone());
-            a("mapextending", new RecipeMapExtend());
-            a("fireworks", new RecipeFireworks());
-            a("repairitem", new RecipeRepair());
-            a("tippedarrow", new RecipeTippedArrow());
-            a("bannerduplicate", new RecipesBanner.DuplicateRecipe());
-            a("banneraddpattern", new RecipesBanner.AddRecipe());
-            a("shielddecoration", new RecipiesShield.Decoration());
-            a("shulkerboxcoloring", new RecipeShulkerBox.Dye());
-            return b();
+            //defaultManager.count = 0; // Reset recipe ID count
+            defaultManager.a("armordye", new RecipeArmorDye());
+            defaultManager.a("bookcloning", new RecipeBookClone());
+            defaultManager.a("mapcloning", new RecipeMapClone());
+            defaultManager.a("mapextending", new RecipeMapExtend());
+            defaultManager.a("fireworks", new RecipeFireworks());
+            defaultManager.a("repairitem", new RecipeRepair());
+            defaultManager.a("tippedarrow", new RecipeTippedArrow());
+            defaultManager.a("bannerduplicate", new RecipesBanner.DuplicateRecipe());
+            defaultManager.a("banneraddpattern", new RecipesBanner.AddRecipe());
+            defaultManager.a("shielddecoration", new RecipiesShield.Decoration());
+            defaultManager.a("shulkerboxcoloring", new RecipeShulkerBox.Dye());
+            defaultManager.LoadFromFiles();
         } catch (Throwable throwable) {
             return false;
         }
+
+        return initVanilla(instance);
+    }
+
+    public static boolean initVanilla(CraftingManager man) {
+        man.copyAll(defaultManager);
+        return true;
+    }
+
+    //OilSpigot end - static
+
+
+    //OilSpigot start
+    public CraftingManager(ItemStack helpDisplayItem, ItemStack helpDisplayItem2, String name) {
+        this.name = name;
+        CRAFTING_MANAGERS.add(this);
+        this.helpDisplayItem = helpDisplayItem;
+        this.helpDisplayItem2 = helpDisplayItem2;
+    }
+
+    public void unregister() {
+        CRAFTING_MANAGERS.remove(this);
+    }
+
+    public void clear() {
+        recipes = new RegistryMaterials<>(); //TODO: maybe memory leak
+        vanillaChViews.clear();
+        vanillaSpecialChViews.clear();
+        oilChViews.clear();
+    }
+
+    public Iterator<IRecipe> recipeIterator() {
+        return recipes.iterator();
+    }
+
+    public static Iterator<IRecipe> allRecipeIterator() {
+        return new Iterator<IRecipe>() {
+            Iterator<CraftingManager> cmIterator = REGISTERED_CRAFTING_MANAGERS.iterator();
+            Iterator<IRecipe> current = cmIterator.next().recipeIterator();
+
+
+            private boolean nextIterator() {
+                while(!current.hasNext() && cmIterator.hasNext()) {
+                    current = cmIterator.next().recipeIterator();
+                }
+                return current.hasNext();
+            }
+
+            @Override
+            public boolean hasNext() {
+                return current.hasNext() || nextIterator();
+            }
+
+            @Override
+            public IRecipe next() {
+                nextIterator();
+                return current.next();
+            }
+        };
     }
 
-    private static boolean b() {
+
+    //OilSpigot end
+
+
+    private boolean LoadFromFiles() { //OilSpigot Pail b LoadFromFiles
         FileSystem filesystem = null;
         Gson gson = (new GsonBuilder()).setPrettyPrinting().disableHtmlEscaping().create();
 
@@ -128,6 +236,7 @@ public class CraftingManager {
         return true;
     }
 
+
     private static IRecipe a(JsonObject jsonobject) {
         String s = ChatDeserializer.h(jsonobject, "type");
 
@@ -140,58 +249,123 @@ public class CraftingManager {
         }
     }
 
-    public static void a(String s, IRecipe irecipe) {
+    public void a(String s, IRecipe irecipe) {
         a(new MinecraftKey(s), irecipe);
     }
 
-    public static void a(MinecraftKey minecraftkey, IRecipe irecipe) {
-        if (CraftingManager.recipes.d(minecraftkey)) {
+    //OilSpigot Pail non static
+    public void a(MinecraftKey minecraftkey, IRecipe irecipe) {
+        if (recipes.d(minecraftkey)) {
             throw new IllegalStateException("Duplicate recipe ignored with ID " + minecraftkey);
         } else {
-            irecipe.setKey(minecraftkey); // CraftBukkit
-            CraftingManager.recipes.a(CraftingManager.c++, minecraftkey, irecipe);
+            //OilSpigot - only register globally if new
+            if (!irecipe.isRegistered()) {
+                registerGlobal(minecraftkey, irecipe);
+            }
+            recipes.a(irecipe.getGlobalId(), minecraftkey, irecipe);
+            //OilSpigot start
+            if (!(irecipe instanceof NMS_OilRecipe) && irecipe.getCraftingHelps() != null) {
+                CHView[] views = irecipe.getCraftingHelps();
+                for(CHView view:views) {
+                    if (view != null) {
+                        if (irecipe instanceof OilRecipe) {
+                            oilChViews.add(view);
+                        } else if (view.isSpecialRecipe()) {
+                            vanillaSpecialChViews.add(view);
+                        } else {
+                            vanillaChViews.add(view);
+                        }
+                    } else {
+                        System.err.println("Warning it was tried to register null CHView: " + irecipe.toString());
+                    }
+                }
+
+            }
+
+            //OilSpigot send
         }
     }
 
-    public static ItemStack craft(InventoryCrafting inventorycrafting, World world) {
-        Iterator iterator = CraftingManager.recipes.iterator();
+    //OilSpigot start
+    public static void registerRecipe(MinecraftKey minecraftkey, IRecipe irecipe) {
+        getInstance().a(minecraftkey, irecipe);
+    }
+
+    public NonNullList<ItemStack> c(InventoryCrafting inventorycrafting, World world) {
+        return c((IInventoryCrafting)inventorycrafting,world);
+    }
+    
+    @Nullable
+    public IRecipe b(InventoryCrafting inventorycrafting, World world) {
+        return b((IInventoryCrafting)inventorycrafting,world);
+    }
+
+    @Nullable
+    public ItemStack craft(InventoryCrafting inventorycrafting, World world) {
+        return craft((IInventoryCrafting)inventorycrafting,world);
+    }
+
+
+    /*Oilspigot stop*/
+
+
+
+
+
+
+
+
+
+
+
+
+    //OilSpigot Pail non static
+    public ItemStack craft(IInventoryCrafting inventorycrafting, World world) {//OilSpigot changed from InventoryCrafting to IInventoryCrafting
+        Iterator iterator = this.recipes.iterator();
 
         IRecipe irecipe;
 
         do {
             if (!iterator.hasNext()) {
-                inventorycrafting.currentRecipe = null; // CraftBukkit - Clear recipe when no recipe is found
+                //OilSpigot use interface method instead
+                inventorycrafting.setCurrentRecipe(null); // CraftBukkit - Clear recipe when no recipe is found
                 return ItemStack.a;
             }
 
             irecipe = (IRecipe) iterator.next();
         } while (!irecipe.a(inventorycrafting, world));
 
-        inventorycrafting.currentRecipe = irecipe; // CraftBukkit
+        inventorycrafting.setCurrentRecipe(irecipe); // CraftBukkit //OilSpigot use method
         return irecipe.craftItem(inventorycrafting);
     }
 
+
+    //OilSpigot Pail non static
     @Nullable
-    public static IRecipe b(InventoryCrafting inventorycrafting, World world) {
-        Iterator iterator = CraftingManager.recipes.iterator();
+    public IRecipe b(IInventoryCrafting inventorycrafting, World world) {//OilSpigot changed from InventoryCrafting to IInventoryCrafting
+        Iterator iterator = recipes.iterator();
 
         IRecipe irecipe;
 
         do {
             if (!iterator.hasNext()) {
-                inventorycrafting.currentRecipe = null; // CraftBukkit - Clear recipe when no recipe is found
+                //OilSpigot use method
+                inventorycrafting.setCurrentRecipe(null); // CraftBukkit - Clear recipe when no recipe is found
                 return null;
             }
 
             irecipe = (IRecipe) iterator.next();
         } while (!irecipe.a(inventorycrafting, world));
 
-        inventorycrafting.currentRecipe = irecipe; // CraftBukkit
+        //OilSpigot use interface method instead
+        inventorycrafting.setCurrentRecipe(irecipe); // CraftBukkit
         return irecipe;
     }
 
-    public static NonNullList<ItemStack> c(InventoryCrafting inventorycrafting, World world) {
-        Iterator iterator = CraftingManager.recipes.iterator();
+
+    //OilSpigot Pail non static
+    public  NonNullList<ItemStack> c(IInventoryCrafting inventorycrafting, World world) {//OilSpigot changed from InventoryCrafting to IInventoryCrafting
+        Iterator iterator = recipes.iterator();
 
         while (iterator.hasNext()) {
             IRecipe irecipe = (IRecipe) iterator.next();
@@ -210,17 +384,83 @@ public class CraftingManager {
         return nonnulllist;
     }
 
+
+    //OilSpigot Pail non static
     @Nullable
-    public static IRecipe a(MinecraftKey minecraftkey) {
-        return (IRecipe) CraftingManager.recipes.get(minecraftkey);
+    public IRecipe a(MinecraftKey minecraftkey) {
+        return (IRecipe) recipes.get(minecraftkey);
     }
 
-    public static int a(IRecipe irecipe) {
-        return CraftingManager.recipes.a(irecipe); // CraftBukkit - decompile error
+    //OilSpigot start
+    public static IRecipe getByKey(MinecraftKey minecraftkey) {
+        return recipesGlobal.get(minecraftkey);
+    }
+    public static IRecipe getById(int id) {
+        return recipesGlobal.getId(id);
     }
 
+    public int getRecipeId(IRecipe recipe) {
+        return recipes.a(recipe);
+    }
+
+    private void copyAll(CraftingManager from) {
+        Iterator<IRecipe> iterator = from.recipeIterator();
+        while (iterator.hasNext()) {
+            IRecipe recipe = iterator.next();
+            recipes.a(recipe.getGlobalId(), recipe.getKey(), recipe);
+        }
+        mergeLists(vanillaChViews, from.vanillaChViews);
+        mergeLists(vanillaSpecialChViews, from.vanillaSpecialChViews);
+        mergeLists(oilChViews, from.oilChViews);
+    }
+
+    /**
+     * does not conserve order
+     */
+    private static <T> void mergeLists(List<T> in, List<T> from) {
+        Set<T> set = new THashSet<T>(in.size() + from.size());
+
+        set.addAll(in);
+        set.addAll(from);
+
+        in.clear();
+        in.addAll(set);
+    }
+
+    private static void registerGlobal(MinecraftKey key, IRecipe recipe) { //only to be called from within craftingmanager
+        if (recipesGlobal.d(key)) {
+            throw new IllegalStateException("Duplicate recipe ignored with ID " + key);
+        }
+        recipesGlobal.a(globalId, key, recipe);
+        int before = recipe.getGlobalId();
+        recipe.registered(key, globalId++);
+    }
+
+    public static Set<MinecraftKey> getAllKeys() {
+        return recipesGlobal.keySet();
+    }
+
+    public static Set<IRecipe> getAllRecipes() {
+        return recipesGlobal.b.keySet();
+    }
+    //OilSpigot end
+
+
+    //OilSpigot Pail non static
+    public  int a(IRecipe irecipe) {
+        return recipes.a(irecipe); // CraftBukkit - decompile error
+    }
+
+
+    //OilSpigot Pail non static
     @Nullable
-    public static IRecipe a(int i) {
-        return (IRecipe) CraftingManager.recipes.getId(i);
+    public IRecipe a(int i) {
+        return (IRecipe) recipes.getId(i);
     }
+
+    //OilSpigot start - todo: fix for new list type
+    /*public List<IRecipe> getRecipes() {
+        return this.recipes;
+    }*/
+    //OilSpigot end
 }
diff --git a/src/main/java/net/minecraft/server/CriterionTriggerRecipeUnlocked.java b/src/main/java/net/minecraft/server/CriterionTriggerRecipeUnlocked.java
new file mode 100644
index 00000000..4a616958
--- /dev/null
+++ b/src/main/java/net/minecraft/server/CriterionTriggerRecipeUnlocked.java
@@ -0,0 +1,142 @@
+package net.minecraft.server;
+
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Sets;
+import com.google.gson.JsonDeserializationContext;
+import com.google.gson.JsonObject;
+import com.google.gson.JsonSyntaxException;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Set;
+
+public class CriterionTriggerRecipeUnlocked implements CriterionTrigger<CriterionTriggerRecipeUnlocked.b> {
+
+    private static final MinecraftKey a = new MinecraftKey("recipe_unlocked");
+    private final Map<AdvancementDataPlayer, CriterionTriggerRecipeUnlocked.a> b = Maps.newHashMap();
+
+    public CriterionTriggerRecipeUnlocked() {}
+
+    public MinecraftKey a() {
+        return CriterionTriggerRecipeUnlocked.a;
+    }
+
+    public void a(AdvancementDataPlayer advancementdataplayer, CriterionTrigger.a<CriterionTriggerRecipeUnlocked.b> criteriontrigger_a) {
+        CriterionTriggerRecipeUnlocked.a criteriontriggerrecipeunlocked_a = (CriterionTriggerRecipeUnlocked.a) this.b.get(advancementdataplayer);
+
+        if (criteriontriggerrecipeunlocked_a == null) {
+            criteriontriggerrecipeunlocked_a = new a(advancementdataplayer);
+            this.b.put(advancementdataplayer, criteriontriggerrecipeunlocked_a);
+        }
+
+        criteriontriggerrecipeunlocked_a.a(criteriontrigger_a);
+    }
+
+    public void b(AdvancementDataPlayer advancementdataplayer, CriterionTrigger.a<CriterionTriggerRecipeUnlocked.b> criteriontrigger_a) {
+        CriterionTriggerRecipeUnlocked.a criteriontriggerrecipeunlocked_a = (CriterionTriggerRecipeUnlocked.a) this.b.get(advancementdataplayer);
+
+        if (criteriontriggerrecipeunlocked_a != null) {
+            criteriontriggerrecipeunlocked_a.b(criteriontrigger_a);
+            if (criteriontriggerrecipeunlocked_a.a()) {
+                this.b.remove(advancementdataplayer);
+            }
+        }
+
+    }
+
+    public void a(AdvancementDataPlayer advancementdataplayer) {
+        this.b.remove(advancementdataplayer);
+    }
+
+    public CriterionTriggerRecipeUnlocked.b b(JsonObject jsonobject, JsonDeserializationContext jsondeserializationcontext) {
+        MinecraftKey minecraftkey = new MinecraftKey(ChatDeserializer.h(jsonobject, "recipe"));
+        //OilSpigot start - use getByKey
+        IRecipe irecipe = CraftingManager.getByKey(minecraftkey); //OilSpigot use global method
+
+        if (irecipe == null) {
+            throw new JsonSyntaxException("Unknown recipe \'" + minecraftkey + "\'");
+        } else {
+            return new b(irecipe);
+        }
+        //OilSpigot end
+    }
+
+    public void a(EntityPlayer entityplayer, IRecipe irecipe) {
+        CriterionTriggerRecipeUnlocked.a criteriontriggerrecipeunlocked_a = (CriterionTriggerRecipeUnlocked.a) this.b.get(entityplayer.getAdvancementData());
+
+        if (criteriontriggerrecipeunlocked_a != null) {
+            criteriontriggerrecipeunlocked_a.a(irecipe);
+        }
+
+    }
+
+    //OilSpigot fix decompiler error
+    public CriterionTriggerRecipeUnlocked.b a(JsonObject jsonobject, JsonDeserializationContext jsondeserializationcontext) {
+        return this.b(jsonobject, jsondeserializationcontext);
+    }
+
+    static class a {
+
+        private final AdvancementDataPlayer a;
+        private final Set<CriterionTrigger.a<CriterionTriggerRecipeUnlocked.b>> b = Sets.newHashSet();
+
+        public a(AdvancementDataPlayer advancementdataplayer) {
+            this.a = advancementdataplayer;
+        }
+
+        public boolean a() {
+            return this.b.isEmpty();
+        }
+
+        public void a(CriterionTrigger.a<CriterionTriggerRecipeUnlocked.b> criteriontrigger_a) {
+            this.b.add(criteriontrigger_a);
+        }
+
+        public void b(CriterionTrigger.a<CriterionTriggerRecipeUnlocked.b> criteriontrigger_a) {
+            this.b.remove(criteriontrigger_a);
+        }
+
+        public void a(IRecipe irecipe) {
+            ArrayList arraylist = null;
+            Iterator iterator = this.b.iterator();
+
+            CriterionTrigger.a criteriontrigger_a;
+
+            while (iterator.hasNext()) {
+                criteriontrigger_a = (CriterionTrigger.a) iterator.next();
+                if (((CriterionTriggerRecipeUnlocked.b) criteriontrigger_a.a()).a(irecipe)) {
+                    if (arraylist == null) {
+                        arraylist = Lists.newArrayList();
+                    }
+
+                    arraylist.add(criteriontrigger_a);
+                }
+            }
+
+            if (arraylist != null) {
+                iterator = arraylist.iterator();
+
+                while (iterator.hasNext()) {
+                    criteriontrigger_a = (CriterionTrigger.a) iterator.next();
+                    criteriontrigger_a.a(this.a);
+                }
+            }
+
+        }
+    }
+
+    public static class b extends CriterionInstanceAbstract {
+
+        private final IRecipe a;
+
+        public b(IRecipe irecipe) {
+            super(CriterionTriggerRecipeUnlocked.a);
+            this.a = irecipe;
+        }
+
+        public boolean a(IRecipe irecipe) {
+            return this.a == irecipe;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/DedicatedServer.java b/src/main/java/net/minecraft/server/DedicatedServer.java
index 6a8292ce..0fcbda9d 100644
--- a/src/main/java/net/minecraft/server/DedicatedServer.java
+++ b/src/main/java/net/minecraft/server/DedicatedServer.java
@@ -30,6 +30,10 @@ import org.bukkit.craftbukkit.util.Waitable;
 import org.bukkit.event.server.RemoteServerCommandEvent;
 // CraftBukkit end
 
+//OilSpigot start
+import org.oilmod.spigot.OilMain;
+//OilSpigot end
+
 public class DedicatedServer extends MinecraftServer implements IMinecraftServer {
 
     private static final Logger LOGGER = LogManager.getLogger();
@@ -133,7 +137,9 @@ public class DedicatedServer extends MinecraftServer implements IMinecraftServer
 
         thread.setDaemon(true);
         thread.start();
-        DedicatedServer.LOGGER.info("Starting minecraft server version 1.12.2");
+        //OilSpigot start
+        DedicatedServer.LOGGER.info("Starting modifiable minecraft server version 1.12.2");
+        //OilSpigot end
         if (Runtime.getRuntime().maxMemory() / 1024L / 1024L < 512L) {
             DedicatedServer.LOGGER.warn("To start the server with more ram, launch it as \"java -Xmx1024M -Xms1024M -jar minecraft_server.jar\"");
         }
@@ -202,6 +208,10 @@ public class DedicatedServer extends MinecraftServer implements IMinecraftServer
             com.destroystokyo.paper.VersionHistoryManager.INSTANCE.getClass(); // load version history now
             // Paper end
 
+            //OilSpigot start
+            OilMain.registerCommands();
+            /*OilSpigot stop*/
+
             DedicatedServer.LOGGER.info("Generating keypair");
             this.a(MinecraftEncryption.b());
             DedicatedServer.LOGGER.info("Starting Minecraft server on {}:{}", this.getServerIp().isEmpty() ? "*" : this.getServerIp(), Integer.valueOf(this.P()));
@@ -217,6 +227,13 @@ public class DedicatedServer extends MinecraftServer implements IMinecraftServer
             }
         }
 
+
+            //OilSpigot start
+            DedicatedServer.LOGGER.info("Initializing OilMod...");
+            OilMain.init();
+            DedicatedServer.LOGGER.info("OilMod Initialized");
+            //OilSpigot end
+
             // CraftBukkit start
             // this.a((PlayerList) (new DedicatedPlayerList(this))); // Spigot - moved up
             server.loadPlugins();
diff --git a/src/main/java/net/minecraft/server/EnchantmentManager.java b/src/main/java/net/minecraft/server/EnchantmentManager.java
index f714dc32..259e93f8 100644
--- a/src/main/java/net/minecraft/server/EnchantmentManager.java
+++ b/src/main/java/net/minecraft/server/EnchantmentManager.java
@@ -10,6 +10,10 @@ import java.util.Map;
 import java.util.Random;
 import java.util.Map.Entry;
 
+//OilSpigot start
+import org.oilmod.spigot.items.itemstackimpl.internal.ModItemStack;
+//OilSpigot end
+
 public class EnchantmentManager {
 
     private static final EnchantmentManager.EnchantmentModifierProtection a = new EnchantmentManager.EnchantmentModifierProtection(null);
@@ -250,7 +254,7 @@ public class EnchantmentManager {
 
     public static int a(Random random, int i, int j, ItemStack itemstack) {
         Item item = itemstack.getItem();
-        int k = item.c();
+        int k = (itemstack instanceof ModItemStack)?((ModItemStack) itemstack).getEnchantSelectModifier():item.c(); //OilSpigot added support for ModItems - this the enchantabilty value
 
         if (k <= 0) {
             return 0;
@@ -291,7 +295,7 @@ public class EnchantmentManager {
     public static List<WeightedRandomEnchant> b(Random random, ItemStack itemstack, int i, boolean flag) {
         ArrayList arraylist = Lists.newArrayList();
         Item item = itemstack.getItem();
-        int j = item.c();
+        int j = (itemstack instanceof ModItemStack)?((ModItemStack) itemstack).getEnchantSelectModifier():item.c(); //OilSpigot added support for ModItems
 
         if (j <= 0) {
             return arraylist;
@@ -334,13 +338,14 @@ public class EnchantmentManager {
     public static List<WeightedRandomEnchant> a(int i, ItemStack itemstack, boolean flag) {
         ArrayList arraylist = Lists.newArrayList();
         Item item = itemstack.getItem();
-        boolean flag1 = itemstack.getItem() == Items.BOOK;
+        boolean isBook = itemstack.getItem() == Items.BOOK; //OilSpigot renamed
         Iterator iterator = Enchantment.enchantments.iterator();
 
         while (iterator.hasNext()) {
             Enchantment enchantment = (Enchantment) iterator.next();
 
-            if ((!enchantment.isTreasure() || flag) && (enchantment.itemTarget.canEnchant(item) || flag1)) {
+            //OilSpigot add support for moditems if needed
+            if ((!enchantment.isTreasure() || flag) && ((itemstack instanceof ModItemStack)?((ModItemStack) itemstack).canEnchant(enchantment):(enchantment.itemTarget.canEnchant(item) || isBook))) {
                 for (int j = enchantment.getMaxLevel(); j > enchantment.getStartLevel() - 1; --j) {
                     if (i >= enchantment.a(j) && i <= enchantment.b(j)) {
                         arraylist.add(new WeightedRandomEnchant(enchantment, j));
diff --git a/src/main/java/net/minecraft/server/Entity.java b/src/main/java/net/minecraft/server/Entity.java
index 74bbba01..5acd3420 100644
--- a/src/main/java/net/minecraft/server/Entity.java
+++ b/src/main/java/net/minecraft/server/Entity.java
@@ -42,7 +42,15 @@ import org.bukkit.event.entity.EntityPortalEvent;
 import org.bukkit.plugin.PluginManager;
 // CraftBukkit end
 
-public abstract class Entity implements ICommandListener, KeyedObject { // Paper
+//OilSpigot start
+import org.oilmod.api.entity.NMSEntity;
+//OilSpigot end
+
+
+//OilSpigot start
+// Paper - KeyedObject
+public abstract class Entity implements ICommandListener, NMSEntity, KeyedObject {//OilSpigot - now implements NMSEntity
+    //OilSpigot end
 
     // CraftBukkit start
     private static final int CURRENT_LEVEL = 2;
@@ -1888,7 +1896,9 @@ public abstract class Entity implements ICommandListener, KeyedObject { // Paper
         } else {
             // CraftBukkit start - Capture drops for death event
             if (this instanceof EntityLiving && !((EntityLiving) this).forceDrops) {
-                ((EntityLiving) this).drops.add(org.bukkit.craftbukkit.inventory.CraftItemStack.asBukkitCopy(itemstack));
+                //OilSpigot start
+                ((EntityLiving) this).drops.add(org.bukkit.craftbukkit.inventory.CraftItemStack.asCraftMirror(itemstack));
+                //OilSpigot end
                 return null;
             }
             // CraftBukkit end
diff --git a/src/main/java/net/minecraft/server/EntityArmorStand.java b/src/main/java/net/minecraft/server/EntityArmorStand.java
index 90749924..a29225a8 100644
--- a/src/main/java/net/minecraft/server/EntityArmorStand.java
+++ b/src/main/java/net/minecraft/server/EntityArmorStand.java
@@ -225,7 +225,8 @@ public class EntityArmorStand extends EntityLiving {
             nbttaglist = nbttagcompound.getList("ArmorItems", 10);
 
             for (i = 0; i < this.bz.size(); ++i) {
-                this.bz.set(i, new ItemStack(nbttaglist.get(i)));
+                //OilSpigot use factory method instead
+                this.bz.set(i, ItemStack.createStack(nbttaglist.get(i)));
             }
         }
 
@@ -233,7 +234,8 @@ public class EntityArmorStand extends EntityLiving {
             nbttaglist = nbttagcompound.getList("HandItems", 10);
 
             for (i = 0; i < this.by.size(); ++i) {
-                this.by.set(i, new ItemStack(nbttaglist.get(i)));
+                //OilSpigot use factory method instead
+                this.by.set(i, ItemStack.createStack(nbttaglist.get(i)));
             }
         }
 
@@ -512,7 +514,9 @@ public class EntityArmorStand extends EntityLiving {
     }
 
     private void E() {
-        drops.add(org.bukkit.craftbukkit.inventory.CraftItemStack.asBukkitCopy(new ItemStack(Items.ARMOR_STAND))); // CraftBukkit - add to drops
+
+        //OilSpigot use asCraftMirror instead
+        drops.add(org.bukkit.craftbukkit.inventory.CraftItemStack.asCraftMirror(new ItemStack(Items.ARMOR_STAND))); // CraftBukkit - add to drops
         this.F();
     }
 
@@ -525,7 +529,8 @@ public class EntityArmorStand extends EntityLiving {
         for (i = 0; i < this.by.size(); ++i) {
             itemstack = (ItemStack) this.by.get(i);
             if (!itemstack.isEmpty()) {
-                drops.add(org.bukkit.craftbukkit.inventory.CraftItemStack.asBukkitCopy(itemstack)); // CraftBukkit - add to drops
+                //OilSpigot use asCraftMirror instead
+                drops.add(org.bukkit.craftbukkit.inventory.CraftItemStack.asCraftMirror(itemstack)); // CraftBukkit - add to drops
                 this.by.set(i, ItemStack.a);
             }
         }
@@ -533,7 +538,8 @@ public class EntityArmorStand extends EntityLiving {
         for (i = 0; i < this.bz.size(); ++i) {
             itemstack = (ItemStack) this.bz.get(i);
             if (!itemstack.isEmpty()) {
-                drops.add(org.bukkit.craftbukkit.inventory.CraftItemStack.asBukkitCopy(itemstack)); // CraftBukkit - add to drops
+                //OilSpigot use asCraftMirror instead
+                drops.add(org.bukkit.craftbukkit.inventory.CraftItemStack.asCraftMirror(itemstack)); // CraftBukkit - add to drops
                 this.bz.set(i, ItemStack.a);
             }
         }
diff --git a/src/main/java/net/minecraft/server/EntityFireworks.java b/src/main/java/net/minecraft/server/EntityFireworks.java
index bd0ec95f..e9ce820c 100644
--- a/src/main/java/net/minecraft/server/EntityFireworks.java
+++ b/src/main/java/net/minecraft/server/EntityFireworks.java
@@ -220,7 +220,8 @@ public class EntityFireworks extends Entity {
         NBTTagCompound nbttagcompound1 = nbttagcompound.getCompound("FireworksItem");
 
         if (nbttagcompound1 != null) {
-            ItemStack itemstack = new ItemStack(nbttagcompound1);
+            //OilSpigot use factory method
+            ItemStack itemstack = ItemStack.createStack(nbttagcompound1);
 
             if (!itemstack.isEmpty()) {
                 this.datawatcher.set(EntityFireworks.FIREWORK_ITEM, itemstack);
diff --git a/src/main/java/net/minecraft/server/EntityHorseAbstract.java b/src/main/java/net/minecraft/server/EntityHorseAbstract.java
index dcc39236..7a0cf628 100644
--- a/src/main/java/net/minecraft/server/EntityHorseAbstract.java
+++ b/src/main/java/net/minecraft/server/EntityHorseAbstract.java
@@ -766,7 +766,8 @@ public abstract class EntityHorseAbstract extends EntityAnimal implements IInven
         }
 
         if (nbttagcompound.hasKeyOfType("SaddleItem", 10)) {
-            ItemStack itemstack = new ItemStack(nbttagcompound.getCompound("SaddleItem"));
+            //OilSpigot use factory method instead
+            ItemStack itemstack = ItemStack.createStack(nbttagcompound.getCompound("SaddleItem"));
 
             if (itemstack.getItem() == Items.SADDLE) {
                 this.inventoryChest.setItem(0, itemstack);
diff --git a/src/main/java/net/minecraft/server/EntityHorseChestedAbstract.java b/src/main/java/net/minecraft/server/EntityHorseChestedAbstract.java
index 6c520496..08e88330 100644
--- a/src/main/java/net/minecraft/server/EntityHorseChestedAbstract.java
+++ b/src/main/java/net/minecraft/server/EntityHorseChestedAbstract.java
@@ -99,7 +99,8 @@ public abstract class EntityHorseChestedAbstract extends EntityHorseAbstract {
                 int j = nbttagcompound1.getByte("Slot") & 255;
 
                 if (j >= 2 && j < this.inventoryChest.getSize()) {
-                    this.inventoryChest.setItem(j, new ItemStack(nbttagcompound1));
+                    //OilSpigot use createStack
+                    this.inventoryChest.setItem(j, ItemStack.createStack(nbttagcompound1));
                 }
             }
         }
diff --git a/src/main/java/net/minecraft/server/EntityInsentient.java b/src/main/java/net/minecraft/server/EntityInsentient.java
index d6a1933a..3a657166 100644
--- a/src/main/java/net/minecraft/server/EntityInsentient.java
+++ b/src/main/java/net/minecraft/server/EntityInsentient.java
@@ -407,7 +407,8 @@ public abstract class EntityInsentient extends EntityLiving {
             nbttaglist = nbttagcompound.getList("ArmorItems", 10);
 
             for (i = 0; i < this.by.size(); ++i) {
-                this.by.set(i, new ItemStack(nbttaglist.get(i)));
+                //OilSpigot use factory method instead
+                this.by.set(i, ItemStack.createStack(nbttaglist.get(i)));
             }
         }
 
@@ -415,7 +416,8 @@ public abstract class EntityInsentient extends EntityLiving {
             nbttaglist = nbttagcompound.getList("HandItems", 10);
 
             for (i = 0; i < this.bx.size(); ++i) {
-                this.bx.set(i, new ItemStack(nbttaglist.get(i)));
+                //OilSpigot use factory method instead
+                this.bx.set(i, ItemStack.createStack(nbttaglist.get(i)));
             }
         }
 
diff --git a/src/main/java/net/minecraft/server/EntityItem.java b/src/main/java/net/minecraft/server/EntityItem.java
index 099bc755..78aa51a9 100644
--- a/src/main/java/net/minecraft/server/EntityItem.java
+++ b/src/main/java/net/minecraft/server/EntityItem.java
@@ -11,6 +11,10 @@ import org.bukkit.event.player.PlayerPickupItemEvent;
 import org.bukkit.event.player.PlayerAttemptPickupItemEvent; // Paper
 import com.destroystokyo.paper.HopperPusher; // Paper
 
+//OilSpigot start
+import org.oilmod.spigot.items.itemstackimpl.internal.ModItemStack;
+//OilSpigot end
+
 // Paper start - implement HopperPusher
 public class EntityItem extends Entity implements HopperPusher {
     @Override
@@ -322,7 +326,9 @@ public class EntityItem extends Entity implements HopperPusher {
 
         NBTTagCompound nbttagcompound1 = nbttagcompound.getCompound("Item");
 
-        this.setItemStack(new ItemStack(nbttagcompound1));
+
+        //OilSpigot use factory method instead
+        this.setItemStack(ItemStack.createStack(nbttagcompound1));
         if (this.getItemStack().isEmpty()) {
             this.die();
         }
@@ -405,7 +411,9 @@ public class EntityItem extends Entity implements HopperPusher {
     }
 
     public String getName() {
-        return this.hasCustomName() ? this.getCustomName() : LocaleI18n.get("item." + this.getItemStack().a());
+        //OilSpigot start
+        return this.hasCustomName() ? this.getCustomName() : (this.getItemStack() instanceof ModItemStack) ? "item."+((ModItemStack) this.getItemStack()).getModItem().getKey().toString(): LocaleI18n.get("item." + this.getItemStack().a()); //OilSpigot
+        //OilSpigot end
     }
 
     public boolean bd() {
diff --git a/src/main/java/net/minecraft/server/EntityItemFrame.java b/src/main/java/net/minecraft/server/EntityItemFrame.java
index f0d6d6b8..7b1a7eee 100644
--- a/src/main/java/net/minecraft/server/EntityItemFrame.java
+++ b/src/main/java/net/minecraft/server/EntityItemFrame.java
@@ -182,7 +182,8 @@ public class EntityItemFrame extends EntityHanging {
         NBTTagCompound nbttagcompound1 = nbttagcompound.getCompound("Item");
 
         if (nbttagcompound1 != null && !nbttagcompound1.isEmpty()) {
-            this.setItem(new ItemStack(nbttagcompound1), false);
+            //OilSpigot use factory method
+            this.setItem(ItemStack.createStack(nbttagcompound1), false);
             this.setRotation(nbttagcompound.getByte("ItemRotation"), false);
             if (nbttagcompound.hasKeyOfType("ItemDropChance", 99)) {
                 this.e = nbttagcompound.getFloat("ItemDropChance");
diff --git a/src/main/java/net/minecraft/server/EntityLiving.java b/src/main/java/net/minecraft/server/EntityLiving.java
index ed5bb2d3..231a4092 100644
--- a/src/main/java/net/minecraft/server/EntityLiving.java
+++ b/src/main/java/net/minecraft/server/EntityLiving.java
@@ -32,6 +32,10 @@ import org.bukkit.event.entity.EntityTeleportEvent;
 import org.bukkit.event.player.PlayerItemConsumeEvent;
 // CraftBukkit end
 
+//OilSpigot start
+import de.sirati97.spigot.optimisation.ItemStackFreeze;
+//OilSpigot end
+
 import co.aikar.timings.MinecraftTimings; // Paper
 
 public abstract class EntityLiving extends Entity {
@@ -47,8 +51,10 @@ public abstract class EntityLiving extends Entity {
     private AttributeMapBase attributeMap;
     public CombatTracker combatTracker = new CombatTracker(this);
     public final Map<MobEffectList, MobEffect> effects = Maps.newHashMap();
-    private final NonNullList<ItemStack> bv;
-    private final NonNullList<ItemStack> bw;
+    //OilSpigot start -  changed ItemStack to ItemStackFreeze
+    private final NonNullList<ItemStackFreeze> bv;
+    private final NonNullList<ItemStackFreeze> bw;
+    //OilSpigot end
     public boolean au;
     public EnumHand av;
     public int aw;
@@ -138,8 +144,8 @@ public abstract class EntityLiving extends Entity {
 
     public EntityLiving(World world) {
         super(world);
-        this.bv = NonNullList.a(2, ItemStack.a);
-        this.bw = NonNullList.a(4, ItemStack.a);
+        this.bv = NonNullList.a(2, ItemStackFreeze.EMPTY);
+        this.bw = NonNullList.a(4, ItemStackFreeze.EMPTY);
         this.maxNoDamageTicks = 20;
         this.aR = 0.02F;
         this.updateEffects = true;
@@ -1963,15 +1969,18 @@ public abstract class EntityLiving extends Entity {
 
             for (int k = 0; k < j; ++k) {
                 EnumItemSlot enumitemslot = aenumitemslot[k];
-                ItemStack itemstack;
+
+                //OilSpigot start
+                ItemStackFreeze freeze;
 
                 switch (enumitemslot.a()) {
                 case HAND:
-                    itemstack = (ItemStack) this.bv.get(enumitemslot.b());
+                    freeze = (ItemStackFreeze) this.bv.get(enumitemslot.b());
                     break;
 
                 case ARMOR:
-                    itemstack = (ItemStack) this.bw.get(enumitemslot.b());
+                    freeze = (ItemStackFreeze) this.bw.get(enumitemslot.b());
+                    //OilSpigot end
                     break;
 
                 default:
@@ -1980,7 +1989,8 @@ public abstract class EntityLiving extends Entity {
 
                 ItemStack itemstack1 = this.getEquipment(enumitemslot);
 
-                if (!ItemStack.matches(itemstack1, itemstack)) {
+                //OilSpigot start
+                if (!ItemStackFreeze.matches(freeze, itemstack1)) {
                     // Paper start - PlayerArmorChangeEvent
                     if (this instanceof EntityPlayer && enumitemslot.getType() == EnumItemSlot.Function.ARMOR && !itemstack.getItem().equals(itemstack1.getItem())) {
                         final org.bukkit.inventory.ItemStack oldItem = CraftItemStack.asBukkitCopy(itemstack);
@@ -1989,8 +1999,8 @@ public abstract class EntityLiving extends Entity {
                     }
                     // Paper end
                     ((WorldServer) this.world).getTracker().a((Entity) this, (Packet) (new PacketPlayOutEntityEquipment(this.getId(), enumitemslot, itemstack1)));
-                    if (!itemstack.isEmpty()) {
-                        this.getAttributeMap().a(itemstack.a(enumitemslot));
+                    if (!freeze.isEmpty()) { //TODO: FIX
+                        this.getAttributeMap().a(ItemStack.getEntityHoldingAttributes(freeze.tag, freeze.item, enumitemslot));
                     }
 
                     if (!itemstack1.isEmpty()) {
@@ -1999,12 +2009,14 @@ public abstract class EntityLiving extends Entity {
 
                     switch (enumitemslot.a()) {
                     case HAND:
-                        this.bv.set(enumitemslot.b(), itemstack1.isEmpty() ? ItemStack.a : itemstack1.cloneItemStack());
+                        //TODO: FIX
+                        this.bv.set(enumitemslot.b(), itemstack1.createFreeze());
                         break;
 
                     case ARMOR:
-                        this.bw.set(enumitemslot.b(), itemstack1.isEmpty() ? ItemStack.a : itemstack1.cloneItemStack());
+                        this.bw.set(enumitemslot.b(), itemstack1.createFreeze());
                     }
+                    //OilSpigot end
                 }
             }
 
@@ -2461,7 +2473,9 @@ public abstract class EntityLiving extends Entity {
             // CraftBukkit start - fire PlayerItemConsumeEvent
             ItemStack itemstack;
             if (this instanceof EntityPlayer) {
-                org.bukkit.inventory.ItemStack craftItem = CraftItemStack.asBukkitCopy(this.activeItem);
+                /*/OilSpigot start*/
+                org.bukkit.inventory.ItemStack craftItem = CraftItemStack.asCraftMirror(this.activeItem); //OilSpigot - use asCraftMirror
+                /*/OilSpigot end*/
                 event = new PlayerItemConsumeEvent((Player) this.getBukkitEntity(), craftItem); // Paper
                 world.getServer().getPluginManager().callEvent(event);
 
diff --git a/src/main/java/net/minecraft/server/EntityMushroomCow.java b/src/main/java/net/minecraft/server/EntityMushroomCow.java
index 5b0f8a98..226a0e77 100644
--- a/src/main/java/net/minecraft/server/EntityMushroomCow.java
+++ b/src/main/java/net/minecraft/server/EntityMushroomCow.java
@@ -2,6 +2,7 @@ package net.minecraft.server;
 
 import javax.annotation.Nullable;
 import org.bukkit.event.player.PlayerShearEntityEvent; // CraftBukkit
+import org.oilmod.spigot.items.ItemUtil;
 
 public class EntityMushroomCow extends EntityCow {
 
@@ -27,7 +28,8 @@ public class EntityMushroomCow extends EntityCow {
             }
 
             return true;
-        } else if (itemstack.getItem() == Items.SHEARS && this.getAge() >= 0) {
+        //OilSpigot allow modded shears
+        } else if (ItemUtil.isShears(itemstack.getItem()) && this.getAge() >= 0) {
             // CraftBukkit start
             PlayerShearEntityEvent event = new PlayerShearEntityEvent((org.bukkit.entity.Player) entityhuman.getBukkitEntity(), this.getBukkitEntity());
             this.world.getServer().getPluginManager().callEvent(event);
diff --git a/src/main/java/net/minecraft/server/EntityPlayer.java b/src/main/java/net/minecraft/server/EntityPlayer.java
index c1a2ddcf..5191302b 100644
--- a/src/main/java/net/minecraft/server/EntityPlayer.java
+++ b/src/main/java/net/minecraft/server/EntityPlayer.java
@@ -97,6 +97,10 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
     public boolean sentListPacket = false;
     // CraftBukkit end
 
+    //OilSpigot start
+    public int lastSwing;
+    //OilSpigot end
+
     public EntityPlayer(MinecraftServer minecraftserver, WorldServer worldserver, GameProfile gameprofile, PlayerInteractManager playerinteractmanager) {
         super(worldserver, gameprofile);
         playerinteractmanager.player = this;
@@ -1057,7 +1061,7 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
         }
     }
 
-    public void a(List<IRecipe> list) {
+    public void a(List<IRecipe> list) { //OilSpigot TODO: use to add/delete visible recipes
         this.cr.a(list, this);
     }
 
@@ -1069,19 +1073,23 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
         for (int j = 0; j < i; ++j) {
             MinecraftKey minecraftkey = aminecraftkey1[j];
 
-            // CraftBukkit start
-            if (CraftingManager.a(minecraftkey) == null) {
-                Bukkit.getLogger().warning("Ignoring grant of non existent recipe " + minecraftkey);
-                continue;
+            //OilSpigot start - this method is used to grant achievements so we need to search all registered CraftingManagers
+            for(CraftingManager craftingManager:CraftingManager.REGISTERED_CRAFTING_MANAGERS) {
+                // CraftBukkit start
+                if (craftingManager.a(minecraftkey) == null) {
+                    Bukkit.getLogger().warning("Ignoring grant of non existent recipe " + minecraftkey);
+                    continue;
+                }
+                // CraftBukit end
+                arraylist.add(craftingManager.a(minecraftkey));
             }
-            // CraftBukit end
-            arraylist.add(CraftingManager.a(minecraftkey));
+            //OilSpigot end
         }
 
         this.a((List<IRecipe>) arraylist); // CraftBukkit - decompile error
     }
 
-    public void b(List<IRecipe> list) {
+    public void b(List<IRecipe> list) {  //OilSpigot TODO: use to add/delete visible recipes
         this.cr.b(list, this);
     }
 
@@ -1409,6 +1417,8 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
     }
 
     public void a(EnumHand enumhand) {
+        //OilSpigot
+        lastSwing = MinecraftServer.currentTick;
         super.a(enumhand);
         this.ds();
     }
diff --git a/src/main/java/net/minecraft/server/EntityPotion.java b/src/main/java/net/minecraft/server/EntityPotion.java
index 80d09488..af2c74a8 100644
--- a/src/main/java/net/minecraft/server/EntityPotion.java
+++ b/src/main/java/net/minecraft/server/EntityPotion.java
@@ -247,7 +247,8 @@ public class EntityPotion extends EntityProjectile {
 
     public void a(NBTTagCompound nbttagcompound) {
         super.a(nbttagcompound);
-        ItemStack itemstack = new ItemStack(nbttagcompound.getCompound("Potion"));
+        //OilSpigot use createStack
+        ItemStack itemstack = ItemStack.createStack(nbttagcompound.getCompound("Potion"));
 
         if (itemstack.isEmpty()) {
             this.die();
diff --git a/src/main/java/net/minecraft/server/EntitySheep.java b/src/main/java/net/minecraft/server/EntitySheep.java
index dd2ecc02..b6130fba 100644
--- a/src/main/java/net/minecraft/server/EntitySheep.java
+++ b/src/main/java/net/minecraft/server/EntitySheep.java
@@ -9,6 +9,7 @@ import javax.annotation.Nullable;
 import org.bukkit.event.entity.SheepRegrowWoolEvent;
 import org.bukkit.event.player.PlayerShearEntityEvent;
 import org.bukkit.inventory.InventoryView;
+import org.oilmod.spigot.items.ItemUtil;
 // CraftBukkit end
 
 public class EntitySheep extends EntityAnimal {
@@ -143,7 +144,8 @@ public class EntitySheep extends EntityAnimal {
     public boolean a(EntityHuman entityhuman, EnumHand enumhand) {
         ItemStack itemstack = entityhuman.b(enumhand);
 
-        if (itemstack.getItem() == Items.SHEARS && !this.isSheared() && !this.isBaby()) {
+        //OilSpigot allow modded shears
+        if (ItemUtil.isShears(itemstack.getItem()) && !this.isSheared() && !this.isBaby()) {
             if (!this.world.isClientSide) {
                 // CraftBukkit start
                 PlayerShearEntityEvent event = new PlayerShearEntityEvent((org.bukkit.entity.Player) entityhuman.getBukkitEntity(), this.getBukkitEntity());
@@ -273,7 +275,8 @@ public class EntitySheep extends EntityAnimal {
 
         this.container.getItem(0).setData(i);
         this.container.getItem(1).setData(j);
-        ItemStack itemstack = CraftingManager.craft(this.container, ((EntitySheep) entityanimal).world);
+        //OilSpigot added getInstance()
+        ItemStack itemstack = CraftingManager.getInstance().craft(this.container, ((EntitySheep) entityanimal).world); //no clue what is this but wgatever
         int k;
 
         if (itemstack.getItem() == Items.DYE) {
@@ -305,4 +308,10 @@ public class EntitySheep extends EntityAnimal {
 
         EntitySheep.bz.put(EnumColor.WHITE, new float[] { 0.9019608F, 0.9019608F, 0.9019608F});
     }
+
+    //OilSpigot start
+    public static float[] getFloatColor(EnumColor enumcolor) {
+        return (float[]) EntitySheep.bz.get(enumcolor);
+    }
+    //OilSpigot end
 }
diff --git a/src/main/java/net/minecraft/server/EntitySnowman.java b/src/main/java/net/minecraft/server/EntitySnowman.java
index f8a2273c..09f1ece2 100644
--- a/src/main/java/net/minecraft/server/EntitySnowman.java
+++ b/src/main/java/net/minecraft/server/EntitySnowman.java
@@ -4,6 +4,7 @@ import javax.annotation.Nullable;
 // CraftBukkit start
 import org.bukkit.craftbukkit.event.CraftEventFactory;
 import org.bukkit.event.player.PlayerShearEntityEvent;
+import org.oilmod.spigot.items.ItemUtil;
 // CraftBukkit end
 
 public class EntitySnowman extends EntityGolem implements IRangedEntity {
@@ -109,7 +110,9 @@ public class EntitySnowman extends EntityGolem implements IRangedEntity {
     protected boolean a(EntityHuman entityhuman, EnumHand enumhand) {
         ItemStack itemstack = entityhuman.b(enumhand);
 
-        if (itemstack.getItem() == Items.SHEARS && this.hasPumpkin() && !this.world.isClientSide) {
+
+        //OilSpigot allow modded shears
+        if (ItemUtil.isShears(itemstack.getItem()) && this.hasPumpkin() && !this.world.isClientSide) {
             // CraftBukkit start
             PlayerShearEntityEvent event = new PlayerShearEntityEvent((org.bukkit.entity.Player) entityhuman.getBukkitEntity(), this.getBukkitEntity());
             this.world.getServer().getPluginManager().callEvent(event);
diff --git a/src/main/java/net/minecraft/server/EntityVillager.java b/src/main/java/net/minecraft/server/EntityVillager.java
index a9c4ab10..6f10f73c 100644
--- a/src/main/java/net/minecraft/server/EntityVillager.java
+++ b/src/main/java/net/minecraft/server/EntityVillager.java
@@ -270,7 +270,7 @@ public class EntityVillager extends EntityAgeable implements NPC, IMerchant {
         NBTTagList nbttaglist = nbttagcompound.getList("Inventory", 10);
 
         for (int i = 0; i < nbttaglist.size(); ++i) {
-            ItemStack itemstack = new ItemStack(nbttaglist.get(i));
+            ItemStack itemstack = ItemStack.createStack(nbttaglist.get(i)); //OilSpigot uses itemstack factory instead of constructor
 
             if (!itemstack.isEmpty()) {
                 this.inventory.a(itemstack);
diff --git a/src/main/java/net/minecraft/server/IRecipe.java b/src/main/java/net/minecraft/server/IRecipe.java
index cfb862fe..f8f2596f 100644
--- a/src/main/java/net/minecraft/server/IRecipe.java
+++ b/src/main/java/net/minecraft/server/IRecipe.java
@@ -1,18 +1,24 @@
 package net.minecraft.server;
 
-public interface IRecipe {
+import net.minecraft.server.oilmod.IInventoryCrafting;
+import org.oilmod.api.items.crafting.NMSCraftingRecipe;
+import org.oilmod.spigot.items.itemstackimpl.crafting.help.CHView;
 
-    boolean a(InventoryCrafting inventorycrafting, World world);
 
-    ItemStack craftItem(InventoryCrafting inventorycrafting);
+public interface IRecipe extends NMSCraftingRecipe/*OilSpigot added OilApi dependency*/ {
+
+    boolean a(IInventoryCrafting inventorycrafting, World world);
+
+    ItemStack craftItem(IInventoryCrafting inventorycrafting);
 
     ItemStack b();
 
-    NonNullList<ItemStack> b(InventoryCrafting inventorycrafting);
+    NonNullList<ItemStack> b(IInventoryCrafting inventorycrafting);
+
 
     default NonNullList<RecipeItemStack> d() {
         return NonNullList.a();
-    }
+    } //OilSpigot returns ingredients
 
     default boolean c() {
         return false;
@@ -20,5 +26,11 @@ public interface IRecipe {
 
     org.bukkit.inventory.Recipe toBukkitRecipe(); // CraftBukkit
 
-    void setKey(MinecraftKey key); // CraftBukkit
+    //OilSpigot replace setKey with registered
+    void registered(MinecraftKey key, int globalId); // CraftBukkit
+    MinecraftKey getKey();//OilSpigot
+    int getGlobalId();//OilSpigot
+    boolean isRegistered();//OilSpigot
+
+    CHView[] getCraftingHelps(); //OilSpigot
 }
diff --git a/src/main/java/net/minecraft/server/InventoryCraftResult.java b/src/main/java/net/minecraft/server/InventoryCraftResult.java
index 1e3b3b1a..0ae998ba 100644
--- a/src/main/java/net/minecraft/server/InventoryCraftResult.java
+++ b/src/main/java/net/minecraft/server/InventoryCraftResult.java
@@ -3,12 +3,13 @@ package net.minecraft.server;
 import java.util.Iterator;
 import javax.annotation.Nullable;
 // CraftBukkit start
+import net.minecraft.server.oilmod.IInventoryCraftResult;
 import org.bukkit.Location;
 import org.bukkit.craftbukkit.entity.CraftHumanEntity;
 import org.bukkit.entity.HumanEntity;
 // CraftBukkit end
 
-public class InventoryCraftResult implements IInventory {
+public class InventoryCraftResult implements IInventoryCraftResult { //OilSpigot changed from IIventory to
 
     private final NonNullList<ItemStack> items;
     private IRecipe b;
diff --git a/src/main/java/net/minecraft/server/InventoryCrafting.java b/src/main/java/net/minecraft/server/InventoryCrafting.java
index 14721adb..463213eb 100644
--- a/src/main/java/net/minecraft/server/InventoryCrafting.java
+++ b/src/main/java/net/minecraft/server/InventoryCrafting.java
@@ -3,6 +3,8 @@ package net.minecraft.server;
 import java.util.Iterator;
 // CraftBukkit start
 import java.util.List;
+
+import net.minecraft.server.oilmod.IInventoryCrafting;
 import org.bukkit.Location;
 
 import org.bukkit.craftbukkit.entity.CraftHumanEntity;
@@ -10,12 +12,16 @@ import org.bukkit.entity.HumanEntity;
 import org.bukkit.event.inventory.InventoryType;
 // CraftBukkit end
 
-public class InventoryCrafting implements IInventory {
+//OilSpigot start
+import org.bukkit.craftbukkit.inventory.CraftInventoryCrafting;
+//OilSpigot end
+
+public class InventoryCrafting implements IInventoryCrafting { //OilSpigot implementing IInventoryCrafting instant of IInventory
 
     private final NonNullList<ItemStack> items;
-    private final int b;
-    private final int c;
-    public final Container container;
+    private final int width; //OilSpigot Pail width width
+    private final int height; //OilSpigot Pail height height
+    public Container container; //OilSpigot PAIL removed final
 
     // CraftBukkit start - add fields
     public List<HumanEntity> transaction = new java.util.ArrayList<HumanEntity>();
@@ -36,6 +42,22 @@ public class InventoryCrafting implements IInventory {
         return items.size() == 4 ? InventoryType.CRAFTING : InventoryType.WORKBENCH;
     }
 
+    //OilSpigot start
+    @Override
+    public CraftInventoryCrafting getBukkitInventory() {
+        return new CraftInventoryCrafting(this, resultInventory);
+    }
+
+    @Override
+    public CraftingManager getCraftingManager() {
+        return CraftingManager.getInstance();
+    }
+
+    @Override
+    public Container getContainer() {
+        return container;
+    }
+
     public void onClose(CraftHumanEntity who) {
         transaction.remove(who);
     }
@@ -66,10 +88,20 @@ public class InventoryCrafting implements IInventory {
 
     public InventoryCrafting(Container container, int i, int j) {
         this.items = NonNullList.a(i * j, ItemStack.a);
+        setContainer(container);
+        this.width = i;
+        this.height = j;
+    }
+
+    //OilSpigot start
+    public InventoryCrafting(int i, int j, EntityHuman player) { //to be called container is not available yet
+        this(null, i, j, player);
+    }
+
+    public void setContainer(Container container) {
         this.container = container;
-        this.b = i;
-        this.c = j;
     }
+    /*OilSpigot stop*/
 
     public int getSize() {
         return this.items.size();
@@ -96,8 +128,17 @@ public class InventoryCrafting implements IInventory {
     }
 
     public ItemStack c(int i, int j) {
-        return i >= 0 && i < this.b && j >= 0 && j <= this.c ? this.getItem(i + j * this.b) : ItemStack.a;
+        return i >= 0 && i < this.width && j >= 0 && j <= this.height ? this.getItem(i + j * this.width) : ItemStack.a;
+    }
+
+    //OilSpigot start
+    @Override
+    public void setItem(int left, int top, ItemStack itemStack, boolean update) {
+        if (left >= 0 && left < this.width && top >= 0 && top <= this.height) {
+            this.setItem(left + top * this.width, itemStack, update);
+        }
     }
+    //OilSpigot end
 
     public String getName() {
         return "container.crafting";
@@ -118,17 +159,28 @@ public class InventoryCrafting implements IInventory {
     public ItemStack splitStack(int i, int j) {
         ItemStack itemstack = ContainerUtil.a(this.items, i, j);
 
-        if (!itemstack.isEmpty()) {
-            this.container.a((IInventory) this);
+        if (itemstack != null) {
+            updateResult(); //OilSpigot - use own method
         }
 
         return itemstack;
     }
 
+    //OilSpigot start
     public void setItem(int i, ItemStack itemstack) {
+        setItem(i, itemstack, true);
+    }
+
+    public void setItem(int i, ItemStack itemstack, boolean update) {
         this.items.set(i, itemstack);
+        if (update)updateResult();
+    }
+
+    @Override
+    public void updateResult() {
         this.container.a((IInventory) this);
     }
+    //OilSpigot end
 
     public int getMaxStackSize() {
         return 64;
@@ -163,11 +215,11 @@ public class InventoryCrafting implements IInventory {
     }
 
     public int i() {
-        return this.c;
+        return this.height;
     }
 
     public int j() {
-        return this.b;
+        return this.width;
     }
 
     public void a(AutoRecipeStackManager autorecipestackmanager) {
@@ -178,6 +230,26 @@ public class InventoryCrafting implements IInventory {
 
             autorecipestackmanager.a(itemstack);
         }
+    }
+
 
+    //OilSpigot start todo: delete if unneeded
+    public IInventory getResultInventory() {
+        return resultInventory;
+    }
+
+    public void setResultInventory(IInventory resultInventory) {
+        this.resultInventory = resultInventory;
+    }
+
+    @Override
+    public void setCurrentRecipe(IRecipe currentRecipe) {
+        this.currentRecipe = currentRecipe;
+    }
+
+    @Override
+    public IRecipe getCurrentRecipe() {
+        return currentRecipe;
     }
+    //OilSpigot end
 }
diff --git a/src/main/java/net/minecraft/server/InventoryEnderChest.java b/src/main/java/net/minecraft/server/InventoryEnderChest.java
index 37b494b7..04fdfaf6 100644
--- a/src/main/java/net/minecraft/server/InventoryEnderChest.java
+++ b/src/main/java/net/minecraft/server/InventoryEnderChest.java
@@ -41,7 +41,7 @@ public class InventoryEnderChest extends InventorySubcontainer {
             int j = nbttagcompound.getByte("Slot") & 255;
 
             if (j >= 0 && j < this.getSize()) {
-                this.setItem(j, new ItemStack(nbttagcompound));
+                this.setItem(j, ItemStack.createStack(nbttagcompound));
             }
         }
 
diff --git a/src/main/java/net/minecraft/server/InventoryUtils.java b/src/main/java/net/minecraft/server/InventoryUtils.java
new file mode 100644
index 00000000..99ab05de
--- /dev/null
+++ b/src/main/java/net/minecraft/server/InventoryUtils.java
@@ -0,0 +1,62 @@
+package net.minecraft.server;
+
+import java.util.Random;
+
+public class InventoryUtils {
+
+    private static final Random a = new Random();
+
+    public static void dropInventory(World world, BlockPosition blockposition, IInventory iinventory) {
+        dropInventory(world, (double) blockposition.getX(), (double) blockposition.getY(), (double) blockposition.getZ(), iinventory);
+    }
+
+    public static void dropEntity(World world, Entity entity, IInventory iinventory) {
+        dropInventory(world, entity.locX, entity.locY, entity.locZ, iinventory);
+    }
+
+    private static void dropInventory(World world, double d0, double d1, double d2, IInventory iinventory) {
+        for (int i = 0; i < iinventory.getSize(); ++i) {
+            ItemStack itemstack = iinventory.getItem(i);
+
+            if (!itemstack.isEmpty()) {
+                dropItem(world, d0, d1, d2, itemstack);
+            }
+        }
+
+    }
+
+    public static void dropItem(World world, double d0, double d1, double d2, ItemStack itemstack) {
+        float f = InventoryUtils.a.nextFloat() * 0.8F + 0.1F;
+        float f1 = InventoryUtils.a.nextFloat() * 0.8F + 0.1F;
+        float f2 = InventoryUtils.a.nextFloat() * 0.8F + 0.1F;
+
+        while (!itemstack.isEmpty()) {
+            EntityItem entityitem = new EntityItem(world, d0 + (double) f, d1 + (double) f1, d2 + (double) f2, itemstack.cloneAndSubtract(InventoryUtils.a.nextInt(21) + 10));
+            float f3 = 0.05F;
+
+
+            //OilSpigot start
+            boolean clone = true;
+            int var11 = a.nextInt(21) + 10;
+            if(var11 > itemstack.getCount() ) {
+                var11 = itemstack.getCount() ;
+                clone = false;
+            }
+
+            ItemStack drop = clone?itemstack.cloneAndSubtract(var11):itemstack;
+            EntityItem var12 = new EntityItem(world, d0 + (double)f, d1 + (double)f1, d2 + (double)f2, drop);
+            //OilSpigot end
+
+            entityitem.motX = InventoryUtils.a.nextGaussian() * 0.05000000074505806D;
+            entityitem.motY = InventoryUtils.a.nextGaussian() * 0.05000000074505806D + 0.20000000298023224D;
+            entityitem.motZ = InventoryUtils.a.nextGaussian() * 0.05000000074505806D;
+            world.addEntity(entityitem);
+            //OilSpigot start
+            if (!clone) {
+                break; //if the coutn is 1 the item is not
+            }
+            //OilSpigot end
+        }
+
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Item.java b/src/main/java/net/minecraft/server/Item.java
new file mode 100644
index 00000000..42578cff
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Item.java
@@ -0,0 +1,831 @@
+package net.minecraft.server;
+
+import com.google.common.collect.HashMultimap;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Multimap;
+import java.util.Map;
+import java.util.Random;
+import java.util.UUID;
+import javax.annotation.Nullable;
+
+public class Item {
+
+    public static final RegistryMaterials<MinecraftKey, Item> REGISTRY = new RegistryMaterials();
+    private static int highestId; //OilSpigot
+    private static final Map<Block, Item> a = Maps.newHashMap();
+    private static final IDynamicTexture b = new IDynamicTexture() {
+    };
+    private static final IDynamicTexture c = new IDynamicTexture() {
+    };
+    private static final IDynamicTexture d = new IDynamicTexture() {
+    };
+    private static final IDynamicTexture e = new IDynamicTexture() {
+    };
+    private final IRegistry<MinecraftKey, IDynamicTexture> f = new RegistrySimple();
+    protected static final UUID h = UUID.fromString("CB3F55D3-645C-4F38-A497-9C13A33DB5CF");
+    protected static final UUID i = UUID.fromString("FA233E1C-4180-4865-B01B-BCCE9785ACA3");
+    private CreativeModeTab n;
+    protected static Random j = new Random();
+    protected int maxStackSize = 64;
+    private int durability;
+    protected boolean l;
+    protected boolean m;
+    private Item craftingResult;
+    private String name;
+
+    //OilSpigot fix compiler error
+    public static int getId(Item item) {
+        return item == null ? 0 : Item.REGISTRY.a(item);
+    }
+
+    public static Item getById(int i) {
+        return (Item) Item.REGISTRY.getId(i);
+    }
+
+    public static Item getItemOf(Block block) {
+        Item item = (Item) Item.a.get(block);
+
+        return item == null ? Items.a : item;
+    }
+
+    @Nullable
+    public static Item b(String s) {
+        Item item = (Item) Item.REGISTRY.get(new MinecraftKey(s));
+
+        if (item == null) {
+            try {
+                return getById(Integer.parseInt(s));
+            } catch (NumberFormatException numberformatexception) {
+                ;
+            }
+        }
+
+        return item;
+    }
+
+    public final void a(MinecraftKey minecraftkey, IDynamicTexture idynamictexture) {
+        this.f.a(minecraftkey, idynamictexture);
+    }
+
+    public boolean a(NBTTagCompound nbttagcompound) {
+        return false;
+    }
+
+    public Item() {
+        this.a(new MinecraftKey("lefthanded"), Item.d);
+        this.a(new MinecraftKey("cooldown"), Item.e);
+    }
+
+    public Item d(int i) {
+        this.maxStackSize = i;
+        return this;
+    }
+
+    public EnumInteractionResult a(EntityHuman entityhuman, World world, BlockPosition blockposition, EnumHand enumhand, EnumDirection enumdirection, float f, float f1, float f2) {
+        return EnumInteractionResult.PASS;
+    }
+
+    public float getDestroySpeed(ItemStack itemstack, IBlockData iblockdata) {
+        return 1.0F;
+    }
+
+    public InteractionResultWrapper<ItemStack> a(World world, EntityHuman entityhuman, EnumHand enumhand) {
+        return new InteractionResultWrapper(EnumInteractionResult.PASS, entityhuman.b(enumhand));
+    }
+
+    public ItemStack a(ItemStack itemstack, World world, EntityLiving entityliving) {
+        return itemstack;
+    }
+
+    public int getMaxStackSize() {
+        return this.maxStackSize;
+    }
+
+    public int filterData(int i) {
+        return 0;
+    }
+
+    public boolean k() {
+        return this.m;
+    }
+
+    protected Item a(boolean flag) {
+        this.m = flag;
+        return this;
+    }
+
+    public int getMaxDurability() {
+        return this.durability;
+    }
+
+    protected Item setMaxDurability(int i) {
+        this.durability = i;
+        if (i > 0) {
+            this.a(new MinecraftKey("damaged"), Item.b);
+            this.a(new MinecraftKey("damage"), Item.c);
+        }
+
+        return this;
+    }
+
+    public boolean usesDurability() {
+        return this.durability > 0 && (!this.m || this.maxStackSize == 1);
+    }
+
+    public boolean a(ItemStack itemstack, EntityLiving entityliving, EntityLiving entityliving1) {
+        return false;
+    }
+
+    public boolean a(ItemStack itemstack, World world, IBlockData iblockdata, BlockPosition blockposition, EntityLiving entityliving) {
+        return false;
+    }
+
+    public boolean canDestroySpecialBlock(IBlockData iblockdata) {
+        return false;
+    }
+
+    public boolean a(ItemStack itemstack, EntityHuman entityhuman, EntityLiving entityliving, EnumHand enumhand) {
+        return false;
+    }
+
+    public Item n() {
+        this.l = true;
+        return this;
+    }
+
+    public Item c(String s) {
+        this.name = s;
+        return this;
+    }
+
+    public String j(ItemStack itemstack) {
+        return LocaleI18n.get(this.a(itemstack));
+    }
+
+    public String getName() {
+        return "item." + this.name;
+    }
+
+    public String a(ItemStack itemstack) {
+        return "item." + this.name;
+    }
+
+    public Item b(Item item) {
+        this.craftingResult = item;
+        return this;
+    }
+
+    public boolean p() {
+        return true;
+    }
+
+    @Nullable
+    public Item q() {
+        return this.craftingResult;
+    }
+
+    public boolean r() {
+        return this.craftingResult != null;
+    }
+
+    public void a(ItemStack itemstack, World world, Entity entity, int i, boolean flag) {}
+
+    public void b(ItemStack itemstack, World world, EntityHuman entityhuman) {}
+
+    public boolean f() {
+        return false;
+    }
+
+    public EnumAnimation f(ItemStack itemstack) {
+        return EnumAnimation.NONE;
+    }
+
+    public int e(ItemStack itemstack) {
+        return 0;
+    }
+
+    public void a(ItemStack itemstack, World world, EntityLiving entityliving, int i) {}
+
+    public String b(ItemStack itemstack) {
+        return LocaleI18n.get(this.j(itemstack) + ".name").trim();
+    }
+
+    public EnumItemRarity g(ItemStack itemstack) {
+        return itemstack.hasEnchantments() ? EnumItemRarity.RARE : EnumItemRarity.COMMON;
+    }
+
+    public boolean g_(ItemStack itemstack) {
+        return this.getMaxStackSize() == 1 && this.usesDurability();
+    }
+
+    protected MovingObjectPosition a(World world, EntityHuman entityhuman, boolean flag) {
+        float f = entityhuman.pitch;
+        float f1 = entityhuman.yaw;
+        double d0 = entityhuman.locX;
+        double d1 = entityhuman.locY + (double) entityhuman.getHeadHeight();
+        double d2 = entityhuman.locZ;
+        Vec3D vec3d = new Vec3D(d0, d1, d2);
+        float f2 = MathHelper.cos(-f1 * 0.017453292F - 3.1415927F);
+        float f3 = MathHelper.sin(-f1 * 0.017453292F - 3.1415927F);
+        float f4 = -MathHelper.cos(-f * 0.017453292F);
+        float f5 = MathHelper.sin(-f * 0.017453292F);
+        float f6 = f3 * f4;
+        float f7 = f2 * f4;
+        double d3 = 5.0D;
+        Vec3D vec3d1 = vec3d.add((double) f6 * 5.0D, (double) f5 * 5.0D, (double) f7 * 5.0D);
+
+        return world.rayTrace(vec3d, vec3d1, flag, !flag, false);
+    }
+
+    public int c() {
+        return 0;
+    }
+
+    public void a(CreativeModeTab creativemodetab, NonNullList<ItemStack> nonnulllist) {
+        if (this.a(creativemodetab)) {
+            nonnulllist.add(new ItemStack(this));
+        }
+
+    }
+
+    protected boolean a(CreativeModeTab creativemodetab) {
+        CreativeModeTab creativemodetab1 = this.b();
+
+        return creativemodetab1 != null && (creativemodetab == CreativeModeTab.g || creativemodetab == creativemodetab1);
+    }
+
+    @Nullable
+    public CreativeModeTab b() {
+        return this.n;
+    }
+
+    public Item b(CreativeModeTab creativemodetab) {
+        this.n = creativemodetab;
+        return this;
+    }
+
+    public boolean s() {
+        return false;
+    }
+
+    public boolean a(ItemStack itemstack, ItemStack itemstack1) {
+        return false;
+    }
+
+    public Multimap<String, AttributeModifier> a(EnumItemSlot enumitemslot) {
+        return HashMultimap.create();
+    }
+
+    public static void t() {
+        a(Blocks.AIR, (Item) (new ItemAir(Blocks.AIR)));
+        a(Blocks.STONE, (new ItemMultiTexture(Blocks.STONE, Blocks.STONE, new ItemMultiTexture.a() {
+            public String a(ItemStack itemstack) {
+                return BlockStone.EnumStoneVariant.a(itemstack.getData()).d();
+            }
+        })).c("stone"));
+        a((Block) Blocks.GRASS, (Item) (new ItemWithAuxData(Blocks.GRASS, false)));
+        a(Blocks.DIRT, (new ItemMultiTexture(Blocks.DIRT, Blocks.DIRT, new ItemMultiTexture.a() {
+            public String a(ItemStack itemstack) {
+                return BlockDirt.EnumDirtVariant.a(itemstack.getData()).c();
+            }
+        })).c("dirt"));
+        b(Blocks.COBBLESTONE);
+        a(Blocks.PLANKS, (new ItemMultiTexture(Blocks.PLANKS, Blocks.PLANKS, new ItemMultiTexture.a() {
+            public String a(ItemStack itemstack) {
+                return BlockWood.EnumLogVariant.a(itemstack.getData()).d();
+            }
+        })).c("wood"));
+        a(Blocks.SAPLING, (new ItemMultiTexture(Blocks.SAPLING, Blocks.SAPLING, new ItemMultiTexture.a() {
+            public String a(ItemStack itemstack) {
+                return BlockWood.EnumLogVariant.a(itemstack.getData()).d();
+            }
+        })).c("sapling"));
+        b(Blocks.BEDROCK);
+        a((Block) Blocks.SAND, (new ItemMultiTexture(Blocks.SAND, Blocks.SAND, new ItemMultiTexture.a() {
+            public String a(ItemStack itemstack) {
+                return BlockSand.EnumSandVariant.a(itemstack.getData()).e();
+            }
+        })).c("sand"));
+        b(Blocks.GRAVEL);
+        b(Blocks.GOLD_ORE);
+        b(Blocks.IRON_ORE);
+        b(Blocks.COAL_ORE);
+        a(Blocks.LOG, (new ItemMultiTexture(Blocks.LOG, Blocks.LOG, new ItemMultiTexture.a() {
+            public String a(ItemStack itemstack) {
+                return BlockWood.EnumLogVariant.a(itemstack.getData()).d();
+            }
+        })).c("log"));
+        a(Blocks.LOG2, (new ItemMultiTexture(Blocks.LOG2, Blocks.LOG2, new ItemMultiTexture.a() {
+            public String a(ItemStack itemstack) {
+                return BlockWood.EnumLogVariant.a(itemstack.getData() + 4).d();
+            }
+        })).c("log"));
+        a((Block) Blocks.LEAVES, (new ItemLeaves(Blocks.LEAVES)).c("leaves"));
+        a((Block) Blocks.LEAVES2, (new ItemLeaves(Blocks.LEAVES2)).c("leaves"));
+        a(Blocks.SPONGE, (new ItemMultiTexture(Blocks.SPONGE, Blocks.SPONGE, new ItemMultiTexture.a() {
+            public String a(ItemStack itemstack) {
+                return (itemstack.getData() & 1) == 1 ? "wet" : "dry";
+            }
+        })).c("sponge"));
+        b(Blocks.GLASS);
+        b(Blocks.LAPIS_ORE);
+        b(Blocks.LAPIS_BLOCK);
+        b(Blocks.DISPENSER);
+        a(Blocks.SANDSTONE, (new ItemMultiTexture(Blocks.SANDSTONE, Blocks.SANDSTONE, new ItemMultiTexture.a() {
+            public String a(ItemStack itemstack) {
+                return BlockSandStone.EnumSandstoneVariant.a(itemstack.getData()).c();
+            }
+        })).c("sandStone"));
+        b(Blocks.NOTEBLOCK);
+        b(Blocks.GOLDEN_RAIL);
+        b(Blocks.DETECTOR_RAIL);
+        a((Block) Blocks.STICKY_PISTON, (Item) (new ItemPiston(Blocks.STICKY_PISTON)));
+        b(Blocks.WEB);
+        a((Block) Blocks.TALLGRASS, (Item) (new ItemWithAuxData(Blocks.TALLGRASS, true)).a(new String[] { "shrub", "grass", "fern"}));
+        b((Block) Blocks.DEADBUSH);
+        a((Block) Blocks.PISTON, (Item) (new ItemPiston(Blocks.PISTON)));
+        a(Blocks.WOOL, (new ItemCloth(Blocks.WOOL)).c("cloth"));
+        a((Block) Blocks.YELLOW_FLOWER, (new ItemMultiTexture(Blocks.YELLOW_FLOWER, Blocks.YELLOW_FLOWER, new ItemMultiTexture.a() {
+            public String a(ItemStack itemstack) {
+                return BlockFlowers.EnumFlowerVarient.a(BlockFlowers.EnumFlowerType.YELLOW, itemstack.getData()).d();
+            }
+        })).c("flower"));
+        a((Block) Blocks.RED_FLOWER, (new ItemMultiTexture(Blocks.RED_FLOWER, Blocks.RED_FLOWER, new ItemMultiTexture.a() {
+            public String a(ItemStack itemstack) {
+                return BlockFlowers.EnumFlowerVarient.a(BlockFlowers.EnumFlowerType.RED, itemstack.getData()).d();
+            }
+        })).c("rose"));
+        b((Block) Blocks.BROWN_MUSHROOM);
+        b((Block) Blocks.RED_MUSHROOM);
+        b(Blocks.GOLD_BLOCK);
+        b(Blocks.IRON_BLOCK);
+        a((Block) Blocks.STONE_SLAB, (new ItemStep(Blocks.STONE_SLAB, Blocks.STONE_SLAB, Blocks.DOUBLE_STONE_SLAB)).c("stoneSlab"));
+        b(Blocks.BRICK_BLOCK);
+        b(Blocks.TNT);
+        b(Blocks.BOOKSHELF);
+        b(Blocks.MOSSY_COBBLESTONE);
+        b(Blocks.OBSIDIAN);
+        b(Blocks.TORCH);
+        b(Blocks.END_ROD);
+        b(Blocks.CHORUS_PLANT);
+        b(Blocks.CHORUS_FLOWER);
+        b(Blocks.PURPUR_BLOCK);
+        b(Blocks.PURPUR_PILLAR);
+        b(Blocks.PURPUR_STAIRS);
+        a((Block) Blocks.PURPUR_SLAB, (new ItemStep(Blocks.PURPUR_SLAB, Blocks.PURPUR_SLAB, Blocks.PURPUR_DOUBLE_SLAB)).c("purpurSlab"));
+        b(Blocks.MOB_SPAWNER);
+        b(Blocks.OAK_STAIRS);
+        b((Block) Blocks.CHEST);
+        b(Blocks.DIAMOND_ORE);
+        b(Blocks.DIAMOND_BLOCK);
+        b(Blocks.CRAFTING_TABLE);
+        b(Blocks.FARMLAND);
+        b(Blocks.FURNACE);
+        b(Blocks.LADDER);
+        b(Blocks.RAIL);
+        b(Blocks.STONE_STAIRS);
+        b(Blocks.LEVER);
+        b(Blocks.STONE_PRESSURE_PLATE);
+        b(Blocks.WOODEN_PRESSURE_PLATE);
+        b(Blocks.REDSTONE_ORE);
+        b(Blocks.REDSTONE_TORCH);
+        b(Blocks.STONE_BUTTON);
+        a(Blocks.SNOW_LAYER, (Item) (new ItemSnow(Blocks.SNOW_LAYER)));
+        b(Blocks.ICE);
+        b(Blocks.SNOW);
+        b((Block) Blocks.CACTUS);
+        b(Blocks.CLAY);
+        b(Blocks.JUKEBOX);
+        b(Blocks.FENCE);
+        b(Blocks.SPRUCE_FENCE);
+        b(Blocks.BIRCH_FENCE);
+        b(Blocks.JUNGLE_FENCE);
+        b(Blocks.DARK_OAK_FENCE);
+        b(Blocks.ACACIA_FENCE);
+        b(Blocks.PUMPKIN);
+        b(Blocks.NETHERRACK);
+        b(Blocks.SOUL_SAND);
+        b(Blocks.GLOWSTONE);
+        b(Blocks.LIT_PUMPKIN);
+        b(Blocks.TRAPDOOR);
+        a(Blocks.MONSTER_EGG, (new ItemMultiTexture(Blocks.MONSTER_EGG, Blocks.MONSTER_EGG, new ItemMultiTexture.a() {
+            public String a(ItemStack itemstack) {
+                return BlockMonsterEggs.EnumMonsterEggVarient.a(itemstack.getData()).c();
+            }
+        })).c("monsterStoneEgg"));
+        a(Blocks.STONEBRICK, (new ItemMultiTexture(Blocks.STONEBRICK, Blocks.STONEBRICK, new ItemMultiTexture.a() {
+            public String a(ItemStack itemstack) {
+                return BlockSmoothBrick.EnumStonebrickType.a(itemstack.getData()).c();
+            }
+        })).c("stonebricksmooth"));
+        b(Blocks.BROWN_MUSHROOM_BLOCK);
+        b(Blocks.RED_MUSHROOM_BLOCK);
+        b(Blocks.IRON_BARS);
+        b(Blocks.GLASS_PANE);
+        b(Blocks.MELON_BLOCK);
+        a(Blocks.VINE, (Item) (new ItemWithAuxData(Blocks.VINE, false)));
+        b(Blocks.FENCE_GATE);
+        b(Blocks.SPRUCE_FENCE_GATE);
+        b(Blocks.BIRCH_FENCE_GATE);
+        b(Blocks.JUNGLE_FENCE_GATE);
+        b(Blocks.DARK_OAK_FENCE_GATE);
+        b(Blocks.ACACIA_FENCE_GATE);
+        b(Blocks.BRICK_STAIRS);
+        b(Blocks.STONE_BRICK_STAIRS);
+        b((Block) Blocks.MYCELIUM);
+        a(Blocks.WATERLILY, (Item) (new ItemWaterLily(Blocks.WATERLILY)));
+        b(Blocks.NETHER_BRICK);
+        b(Blocks.NETHER_BRICK_FENCE);
+        b(Blocks.NETHER_BRICK_STAIRS);
+        b(Blocks.ENCHANTING_TABLE);
+        b(Blocks.END_PORTAL_FRAME);
+        b(Blocks.END_STONE);
+        b(Blocks.END_BRICKS);
+        b(Blocks.DRAGON_EGG);
+        b(Blocks.REDSTONE_LAMP);
+        a((Block) Blocks.WOODEN_SLAB, (new ItemStep(Blocks.WOODEN_SLAB, Blocks.WOODEN_SLAB, Blocks.DOUBLE_WOODEN_SLAB)).c("woodSlab"));
+        b(Blocks.SANDSTONE_STAIRS);
+        b(Blocks.EMERALD_ORE);
+        b(Blocks.ENDER_CHEST);
+        b((Block) Blocks.TRIPWIRE_HOOK);
+        b(Blocks.EMERALD_BLOCK);
+        b(Blocks.SPRUCE_STAIRS);
+        b(Blocks.BIRCH_STAIRS);
+        b(Blocks.JUNGLE_STAIRS);
+        b(Blocks.COMMAND_BLOCK);
+        b((Block) Blocks.BEACON);
+        a(Blocks.COBBLESTONE_WALL, (new ItemMultiTexture(Blocks.COBBLESTONE_WALL, Blocks.COBBLESTONE_WALL, new ItemMultiTexture.a() {
+            public String a(ItemStack itemstack) {
+                return BlockCobbleWall.EnumCobbleVariant.a(itemstack.getData()).c();
+            }
+        })).c("cobbleWall"));
+        b(Blocks.WOODEN_BUTTON);
+        a(Blocks.ANVIL, (new ItemAnvil(Blocks.ANVIL)).c("anvil"));
+        b(Blocks.TRAPPED_CHEST);
+        b(Blocks.LIGHT_WEIGHTED_PRESSURE_PLATE);
+        b(Blocks.HEAVY_WEIGHTED_PRESSURE_PLATE);
+        b((Block) Blocks.DAYLIGHT_DETECTOR);
+        b(Blocks.REDSTONE_BLOCK);
+        b(Blocks.QUARTZ_ORE);
+        b((Block) Blocks.HOPPER);
+        a(Blocks.QUARTZ_BLOCK, (new ItemMultiTexture(Blocks.QUARTZ_BLOCK, Blocks.QUARTZ_BLOCK, new String[] { "default", "chiseled", "lines"})).c("quartzBlock"));
+        b(Blocks.QUARTZ_STAIRS);
+        b(Blocks.ACTIVATOR_RAIL);
+        b(Blocks.DROPPER);
+        a(Blocks.STAINED_HARDENED_CLAY, (new ItemCloth(Blocks.STAINED_HARDENED_CLAY)).c("clayHardenedStained"));
+        b(Blocks.BARRIER);
+        b(Blocks.IRON_TRAPDOOR);
+        b(Blocks.HAY_BLOCK);
+        a(Blocks.CARPET, (new ItemCloth(Blocks.CARPET)).c("woolCarpet"));
+        b(Blocks.HARDENED_CLAY);
+        b(Blocks.COAL_BLOCK);
+        b(Blocks.PACKED_ICE);
+        b(Blocks.ACACIA_STAIRS);
+        b(Blocks.DARK_OAK_STAIRS);
+        b(Blocks.SLIME);
+        b(Blocks.GRASS_PATH);
+        a((Block) Blocks.DOUBLE_PLANT, (new ItemMultiTexture(Blocks.DOUBLE_PLANT, Blocks.DOUBLE_PLANT, new ItemMultiTexture.a() {
+            public String a(ItemStack itemstack) {
+                return BlockTallPlant.EnumTallFlowerVariants.a(itemstack.getData()).c();
+            }
+        })).c("doublePlant"));
+        a((Block) Blocks.STAINED_GLASS, (new ItemCloth(Blocks.STAINED_GLASS)).c("stainedGlass"));
+        a((Block) Blocks.STAINED_GLASS_PANE, (new ItemCloth(Blocks.STAINED_GLASS_PANE)).c("stainedGlassPane"));
+        a(Blocks.PRISMARINE, (new ItemMultiTexture(Blocks.PRISMARINE, Blocks.PRISMARINE, new ItemMultiTexture.a() {
+            public String a(ItemStack itemstack) {
+                return BlockPrismarine.EnumPrismarineVariant.a(itemstack.getData()).c();
+            }
+        })).c("prismarine"));
+        b(Blocks.SEA_LANTERN);
+        a(Blocks.RED_SANDSTONE, (new ItemMultiTexture(Blocks.RED_SANDSTONE, Blocks.RED_SANDSTONE, new ItemMultiTexture.a() {
+            public String a(ItemStack itemstack) {
+                return BlockRedSandstone.EnumRedSandstoneVariant.a(itemstack.getData()).c();
+            }
+        })).c("redSandStone"));
+        b(Blocks.RED_SANDSTONE_STAIRS);
+        a((Block) Blocks.STONE_SLAB2, (new ItemStep(Blocks.STONE_SLAB2, Blocks.STONE_SLAB2, Blocks.DOUBLE_STONE_SLAB2)).c("stoneSlab2"));
+        b(Blocks.dc);
+        b(Blocks.dd);
+        b(Blocks.df);
+        b(Blocks.dg);
+        b(Blocks.dh);
+        b(Blocks.di);
+        b(Blocks.dj);
+        b(Blocks.dk);
+        a(Blocks.WHITE_SHULKER_BOX, (Item) (new ItemShulkerBox(Blocks.WHITE_SHULKER_BOX)));
+        a(Blocks.dm, (Item) (new ItemShulkerBox(Blocks.dm)));
+        a(Blocks.dn, (Item) (new ItemShulkerBox(Blocks.dn)));
+        a(Blocks.LIGHT_BLUE_SHULKER_BOX, (Item) (new ItemShulkerBox(Blocks.LIGHT_BLUE_SHULKER_BOX)));
+        a(Blocks.dp, (Item) (new ItemShulkerBox(Blocks.dp)));
+        a(Blocks.dq, (Item) (new ItemShulkerBox(Blocks.dq)));
+        a(Blocks.dr, (Item) (new ItemShulkerBox(Blocks.dr)));
+        a(Blocks.ds, (Item) (new ItemShulkerBox(Blocks.ds)));
+        a(Blocks.dt, (Item) (new ItemShulkerBox(Blocks.dt)));
+        a(Blocks.du, (Item) (new ItemShulkerBox(Blocks.du)));
+        a(Blocks.dv, (Item) (new ItemShulkerBox(Blocks.dv)));
+        a(Blocks.dw, (Item) (new ItemShulkerBox(Blocks.dw)));
+        a(Blocks.dx, (Item) (new ItemShulkerBox(Blocks.dx)));
+        a(Blocks.dy, (Item) (new ItemShulkerBox(Blocks.dy)));
+        a(Blocks.dz, (Item) (new ItemShulkerBox(Blocks.dz)));
+        a(Blocks.dA, (Item) (new ItemShulkerBox(Blocks.dA)));
+        b(Blocks.dB);
+        b(Blocks.dC);
+        b(Blocks.dD);
+        b(Blocks.dE);
+        b(Blocks.dF);
+        b(Blocks.dG);
+        b(Blocks.dH);
+        b(Blocks.dI);
+        b(Blocks.dJ);
+        b(Blocks.dK);
+        b(Blocks.dL);
+        b(Blocks.dM);
+        b(Blocks.dN);
+        b(Blocks.dO);
+        b(Blocks.dP);
+        b(Blocks.dQ);
+        a(Blocks.dR, (new ItemCloth(Blocks.dR)).c("concrete"));
+        a(Blocks.dS, (new ItemCloth(Blocks.dS)).c("concrete_powder"));
+        b(Blocks.STRUCTURE_BLOCK);
+        a(256, "iron_shovel", (new ItemSpade(EnumToolMaterial.IRON)).c("shovelIron"));
+        a(257, "iron_pickaxe", (new ItemPickaxe(EnumToolMaterial.IRON)).c("pickaxeIron"));
+        a(258, "iron_axe", (new ItemAxe(EnumToolMaterial.IRON)).c("hatchetIron"));
+        a(259, "flint_and_steel", (new ItemFlintAndSteel()).c("flintAndSteel"));
+        a(260, "apple", (new ItemFood(4, 0.3F, false)).c("apple"));
+        a(261, "bow", (new ItemBow()).c("bow"));
+        a(262, "arrow", (new ItemArrow()).c("arrow"));
+        a(263, "coal", (new ItemCoal()).c("coal"));
+        a(264, "diamond", (new Item()).c("diamond").b(CreativeModeTab.l));
+        a(265, "iron_ingot", (new Item()).c("ingotIron").b(CreativeModeTab.l));
+        a(266, "gold_ingot", (new Item()).c("ingotGold").b(CreativeModeTab.l));
+        a(267, "iron_sword", (new ItemSword(EnumToolMaterial.IRON)).c("swordIron"));
+        a(268, "wooden_sword", (new ItemSword(EnumToolMaterial.WOOD)).c("swordWood"));
+        a(269, "wooden_shovel", (new ItemSpade(EnumToolMaterial.WOOD)).c("shovelWood"));
+        a(270, "wooden_pickaxe", (new ItemPickaxe(EnumToolMaterial.WOOD)).c("pickaxeWood"));
+        a(271, "wooden_axe", (new ItemAxe(EnumToolMaterial.WOOD)).c("hatchetWood"));
+        a(272, "stone_sword", (new ItemSword(EnumToolMaterial.STONE)).c("swordStone"));
+        a(273, "stone_shovel", (new ItemSpade(EnumToolMaterial.STONE)).c("shovelStone"));
+        a(274, "stone_pickaxe", (new ItemPickaxe(EnumToolMaterial.STONE)).c("pickaxeStone"));
+        a(275, "stone_axe", (new ItemAxe(EnumToolMaterial.STONE)).c("hatchetStone"));
+        a(276, "diamond_sword", (new ItemSword(EnumToolMaterial.DIAMOND)).c("swordDiamond"));
+        a(277, "diamond_shovel", (new ItemSpade(EnumToolMaterial.DIAMOND)).c("shovelDiamond"));
+        a(278, "diamond_pickaxe", (new ItemPickaxe(EnumToolMaterial.DIAMOND)).c("pickaxeDiamond"));
+        a(279, "diamond_axe", (new ItemAxe(EnumToolMaterial.DIAMOND)).c("hatchetDiamond"));
+        a(280, "stick", (new Item()).n().c("stick").b(CreativeModeTab.l));
+        a(281, "bowl", (new Item()).c("bowl").b(CreativeModeTab.l));
+        a(282, "mushroom_stew", (new ItemSoup(6)).c("mushroomStew"));
+        a(283, "golden_sword", (new ItemSword(EnumToolMaterial.GOLD)).c("swordGold"));
+        a(284, "golden_shovel", (new ItemSpade(EnumToolMaterial.GOLD)).c("shovelGold"));
+        a(285, "golden_pickaxe", (new ItemPickaxe(EnumToolMaterial.GOLD)).c("pickaxeGold"));
+        a(286, "golden_axe", (new ItemAxe(EnumToolMaterial.GOLD)).c("hatchetGold"));
+        a(287, "string", (new ItemReed(Blocks.TRIPWIRE)).c("string").b(CreativeModeTab.l));
+        a(288, "feather", (new Item()).c("feather").b(CreativeModeTab.l));
+        a(289, "gunpowder", (new Item()).c("sulphur").b(CreativeModeTab.l));
+        a(290, "wooden_hoe", (new ItemHoe(EnumToolMaterial.WOOD)).c("hoeWood"));
+        a(291, "stone_hoe", (new ItemHoe(EnumToolMaterial.STONE)).c("hoeStone"));
+        a(292, "iron_hoe", (new ItemHoe(EnumToolMaterial.IRON)).c("hoeIron"));
+        a(293, "diamond_hoe", (new ItemHoe(EnumToolMaterial.DIAMOND)).c("hoeDiamond"));
+        a(294, "golden_hoe", (new ItemHoe(EnumToolMaterial.GOLD)).c("hoeGold"));
+        a(295, "wheat_seeds", (new ItemSeeds(Blocks.WHEAT, Blocks.FARMLAND)).c("seeds"));
+        a(296, "wheat", (new Item()).c("wheat").b(CreativeModeTab.l));
+        a(297, "bread", (new ItemFood(5, 0.6F, false)).c("bread"));
+        a(298, "leather_helmet", (new ItemArmor(ItemArmor.EnumArmorMaterial.LEATHER, 0, EnumItemSlot.HEAD)).c("helmetCloth"));
+        a(299, "leather_chestplate", (new ItemArmor(ItemArmor.EnumArmorMaterial.LEATHER, 0, EnumItemSlot.CHEST)).c("chestplateCloth"));
+        a(300, "leather_leggings", (new ItemArmor(ItemArmor.EnumArmorMaterial.LEATHER, 0, EnumItemSlot.LEGS)).c("leggingsCloth"));
+        a(301, "leather_boots", (new ItemArmor(ItemArmor.EnumArmorMaterial.LEATHER, 0, EnumItemSlot.FEET)).c("bootsCloth"));
+        a(302, "chainmail_helmet", (new ItemArmor(ItemArmor.EnumArmorMaterial.CHAIN, 1, EnumItemSlot.HEAD)).c("helmetChain"));
+        a(303, "chainmail_chestplate", (new ItemArmor(ItemArmor.EnumArmorMaterial.CHAIN, 1, EnumItemSlot.CHEST)).c("chestplateChain"));
+        a(304, "chainmail_leggings", (new ItemArmor(ItemArmor.EnumArmorMaterial.CHAIN, 1, EnumItemSlot.LEGS)).c("leggingsChain"));
+        a(305, "chainmail_boots", (new ItemArmor(ItemArmor.EnumArmorMaterial.CHAIN, 1, EnumItemSlot.FEET)).c("bootsChain"));
+        a(306, "iron_helmet", (new ItemArmor(ItemArmor.EnumArmorMaterial.IRON, 2, EnumItemSlot.HEAD)).c("helmetIron"));
+        a(307, "iron_chestplate", (new ItemArmor(ItemArmor.EnumArmorMaterial.IRON, 2, EnumItemSlot.CHEST)).c("chestplateIron"));
+        a(308, "iron_leggings", (new ItemArmor(ItemArmor.EnumArmorMaterial.IRON, 2, EnumItemSlot.LEGS)).c("leggingsIron"));
+        a(309, "iron_boots", (new ItemArmor(ItemArmor.EnumArmorMaterial.IRON, 2, EnumItemSlot.FEET)).c("bootsIron"));
+        a(310, "diamond_helmet", (new ItemArmor(ItemArmor.EnumArmorMaterial.DIAMOND, 3, EnumItemSlot.HEAD)).c("helmetDiamond"));
+        a(311, "diamond_chestplate", (new ItemArmor(ItemArmor.EnumArmorMaterial.DIAMOND, 3, EnumItemSlot.CHEST)).c("chestplateDiamond"));
+        a(312, "diamond_leggings", (new ItemArmor(ItemArmor.EnumArmorMaterial.DIAMOND, 3, EnumItemSlot.LEGS)).c("leggingsDiamond"));
+        a(313, "diamond_boots", (new ItemArmor(ItemArmor.EnumArmorMaterial.DIAMOND, 3, EnumItemSlot.FEET)).c("bootsDiamond"));
+        a(314, "golden_helmet", (new ItemArmor(ItemArmor.EnumArmorMaterial.GOLD, 4, EnumItemSlot.HEAD)).c("helmetGold"));
+        a(315, "golden_chestplate", (new ItemArmor(ItemArmor.EnumArmorMaterial.GOLD, 4, EnumItemSlot.CHEST)).c("chestplateGold"));
+        a(316, "golden_leggings", (new ItemArmor(ItemArmor.EnumArmorMaterial.GOLD, 4, EnumItemSlot.LEGS)).c("leggingsGold"));
+        a(317, "golden_boots", (new ItemArmor(ItemArmor.EnumArmorMaterial.GOLD, 4, EnumItemSlot.FEET)).c("bootsGold"));
+        a(318, "flint", (new Item()).c("flint").b(CreativeModeTab.l));
+        a(319, "porkchop", (new ItemFood(3, 0.3F, true)).c("porkchopRaw"));
+        a(320, "cooked_porkchop", (new ItemFood(8, 0.8F, true)).c("porkchopCooked"));
+        a(321, "painting", (new ItemHanging(EntityPainting.class)).c("painting"));
+        a(322, "golden_apple", (new ItemGoldenApple(4, 1.2F, false)).h().c("appleGold"));
+        a(323, "sign", (new ItemSign()).c("sign"));
+        a(324, "wooden_door", (new ItemDoor(Blocks.WOODEN_DOOR)).c("doorOak"));
+        Item item = (new ItemBucket(Blocks.AIR)).c("bucket").d(16);
+
+        a(325, "bucket", item);
+        a(326, "water_bucket", (new ItemBucket(Blocks.FLOWING_WATER)).c("bucketWater").b(item));
+        a(327, "lava_bucket", (new ItemBucket(Blocks.FLOWING_LAVA)).c("bucketLava").b(item));
+        a(328, "minecart", (new ItemMinecart(EntityMinecartAbstract.EnumMinecartType.RIDEABLE)).c("minecart"));
+        a(329, "saddle", (new ItemSaddle()).c("saddle"));
+        a(330, "iron_door", (new ItemDoor(Blocks.IRON_DOOR)).c("doorIron"));
+        a(331, "redstone", (new ItemRedstone()).c("redstone"));
+        a(332, "snowball", (new ItemSnowball()).c("snowball"));
+        a(333, "boat", new ItemBoat(EntityBoat.EnumBoatType.OAK));
+        a(334, "leather", (new Item()).c("leather").b(CreativeModeTab.l));
+        a(335, "milk_bucket", (new ItemMilkBucket()).c("milk").b(item));
+        a(336, "brick", (new Item()).c("brick").b(CreativeModeTab.l));
+        a(337, "clay_ball", (new Item()).c("clay").b(CreativeModeTab.l));
+        a(338, "reeds", (new ItemReed(Blocks.REEDS)).c("reeds").b(CreativeModeTab.l));
+        a(339, "paper", (new Item()).c("paper").b(CreativeModeTab.f));
+        a(340, "book", (new ItemBook()).c("book").b(CreativeModeTab.f));
+        a(341, "slime_ball", (new Item()).c("slimeball").b(CreativeModeTab.f));
+        a(342, "chest_minecart", (new ItemMinecart(EntityMinecartAbstract.EnumMinecartType.CHEST)).c("minecartChest"));
+        a(343, "furnace_minecart", (new ItemMinecart(EntityMinecartAbstract.EnumMinecartType.FURNACE)).c("minecartFurnace"));
+        a(344, "egg", (new ItemEgg()).c("egg"));
+        a(345, "compass", (new ItemCompass()).c("compass").b(CreativeModeTab.i));
+        a(346, "fishing_rod", (new ItemFishingRod()).c("fishingRod"));
+        a(347, "clock", (new ItemClock()).c("clock").b(CreativeModeTab.i));
+        a(348, "glowstone_dust", (new Item()).c("yellowDust").b(CreativeModeTab.l));
+        a(349, "fish", (new ItemFish(false)).c("fish").a(true));
+        a(350, "cooked_fish", (new ItemFish(true)).c("fish").a(true));
+        a(351, "dye", (new ItemDye()).c("dyePowder"));
+        a(352, "bone", (new Item()).c("bone").n().b(CreativeModeTab.f));
+        a(353, "sugar", (new Item()).c("sugar").b(CreativeModeTab.l));
+        a(354, "cake", (new ItemReed(Blocks.CAKE)).d(1).c("cake").b(CreativeModeTab.h));
+        a(355, "bed", (new ItemBed()).d(1).c("bed"));
+        a(356, "repeater", (new ItemReed(Blocks.UNPOWERED_REPEATER)).c("diode").b(CreativeModeTab.d));
+        a(357, "cookie", (new ItemFood(2, 0.1F, false)).c("cookie"));
+        a(358, "filled_map", (new ItemWorldMap()).c("map"));
+        a(359, "shears", (new ItemShears()).c("shears"));
+        a(360, "melon", (new ItemFood(2, 0.3F, false)).c("melon"));
+        a(361, "pumpkin_seeds", (new ItemSeeds(Blocks.PUMPKIN_STEM, Blocks.FARMLAND)).c("seeds_pumpkin"));
+        a(362, "melon_seeds", (new ItemSeeds(Blocks.MELON_STEM, Blocks.FARMLAND)).c("seeds_melon"));
+        a(363, "beef", (new ItemFood(3, 0.3F, true)).c("beefRaw"));
+        a(364, "cooked_beef", (new ItemFood(8, 0.8F, true)).c("beefCooked"));
+        a(365, "chicken", (new ItemFood(2, 0.3F, true)).a(new MobEffect(MobEffects.HUNGER, 600, 0), 0.3F).c("chickenRaw"));
+        a(366, "cooked_chicken", (new ItemFood(6, 0.6F, true)).c("chickenCooked"));
+        a(367, "rotten_flesh", (new ItemFood(4, 0.1F, true)).a(new MobEffect(MobEffects.HUNGER, 600, 0), 0.8F).c("rottenFlesh"));
+        a(368, "ender_pearl", (new ItemEnderPearl()).c("enderPearl"));
+        a(369, "blaze_rod", (new Item()).c("blazeRod").b(CreativeModeTab.l).n());
+        a(370, "ghast_tear", (new Item()).c("ghastTear").b(CreativeModeTab.k));
+        a(371, "gold_nugget", (new Item()).c("goldNugget").b(CreativeModeTab.l));
+        a(372, "nether_wart", (new ItemSeeds(Blocks.NETHER_WART, Blocks.SOUL_SAND)).c("netherStalkSeeds"));
+        a(373, "potion", (new ItemPotion()).c("potion"));
+        Item item1 = (new ItemGlassBottle()).c("glassBottle");
+
+        a(374, "glass_bottle", item1);
+        a(375, "spider_eye", (new ItemFood(2, 0.8F, false)).a(new MobEffect(MobEffects.POISON, 100, 0), 1.0F).c("spiderEye"));
+        a(376, "fermented_spider_eye", (new Item()).c("fermentedSpiderEye").b(CreativeModeTab.k));
+        a(377, "blaze_powder", (new Item()).c("blazePowder").b(CreativeModeTab.k));
+        a(378, "magma_cream", (new Item()).c("magmaCream").b(CreativeModeTab.k));
+        a(379, "brewing_stand", (new ItemReed(Blocks.BREWING_STAND)).c("brewingStand").b(CreativeModeTab.k));
+        a(380, "cauldron", (new ItemReed(Blocks.cauldron)).c("cauldron").b(CreativeModeTab.k));
+        a(381, "ender_eye", (new ItemEnderEye()).c("eyeOfEnder"));
+        a(382, "speckled_melon", (new Item()).c("speckledMelon").b(CreativeModeTab.k));
+        a(383, "spawn_egg", (new ItemMonsterEgg()).c("monsterPlacer"));
+        a(384, "experience_bottle", (new ItemExpBottle()).c("expBottle"));
+        a(385, "fire_charge", (new ItemFireball()).c("fireball"));
+        a(386, "writable_book", (new ItemBookAndQuill()).c("writingBook").b(CreativeModeTab.f));
+        a(387, "written_book", (new ItemWrittenBook()).c("writtenBook").d(16));
+        a(388, "emerald", (new Item()).c("emerald").b(CreativeModeTab.l));
+        a(389, "item_frame", (new ItemHanging(EntityItemFrame.class)).c("frame"));
+        a(390, "flower_pot", (new ItemReed(Blocks.FLOWER_POT)).c("flowerPot").b(CreativeModeTab.c));
+        a(391, "carrot", (new ItemSeedFood(3, 0.6F, Blocks.CARROTS, Blocks.FARMLAND)).c("carrots"));
+        a(392, "potato", (new ItemSeedFood(1, 0.3F, Blocks.POTATOES, Blocks.FARMLAND)).c("potato"));
+        a(393, "baked_potato", (new ItemFood(5, 0.6F, false)).c("potatoBaked"));
+        a(394, "poisonous_potato", (new ItemFood(2, 0.3F, false)).a(new MobEffect(MobEffects.POISON, 100, 0), 0.6F).c("potatoPoisonous"));
+        a(395, "map", (new ItemMapEmpty()).c("emptyMap"));
+        a(396, "golden_carrot", (new ItemFood(6, 1.2F, false)).c("carrotGolden").b(CreativeModeTab.k));
+        a(397, "skull", (new ItemSkull()).c("skull"));
+        a(398, "carrot_on_a_stick", (new ItemCarrotStick()).c("carrotOnAStick"));
+        a(399, "nether_star", (new ItemNetherStar()).c("netherStar").b(CreativeModeTab.l));
+        a(400, "pumpkin_pie", (new ItemFood(8, 0.3F, false)).c("pumpkinPie").b(CreativeModeTab.h));
+        a(401, "fireworks", (new ItemFireworks()).c("fireworks"));
+        a(402, "firework_charge", (new ItemFireworksCharge()).c("fireworksCharge").b(CreativeModeTab.f));
+        a(403, "enchanted_book", (new ItemEnchantedBook()).d(1).c("enchantedBook"));
+        a(404, "comparator", (new ItemReed(Blocks.UNPOWERED_COMPARATOR)).c("comparator").b(CreativeModeTab.d));
+        a(405, "netherbrick", (new Item()).c("netherbrick").b(CreativeModeTab.l));
+        a(406, "quartz", (new Item()).c("netherquartz").b(CreativeModeTab.l));
+        a(407, "tnt_minecart", (new ItemMinecart(EntityMinecartAbstract.EnumMinecartType.TNT)).c("minecartTnt"));
+        a(408, "hopper_minecart", (new ItemMinecart(EntityMinecartAbstract.EnumMinecartType.HOPPER)).c("minecartHopper"));
+        a(409, "prismarine_shard", (new Item()).c("prismarineShard").b(CreativeModeTab.l));
+        a(410, "prismarine_crystals", (new Item()).c("prismarineCrystals").b(CreativeModeTab.l));
+        a(411, "rabbit", (new ItemFood(3, 0.3F, true)).c("rabbitRaw"));
+        a(412, "cooked_rabbit", (new ItemFood(5, 0.6F, true)).c("rabbitCooked"));
+        a(413, "rabbit_stew", (new ItemSoup(10)).c("rabbitStew"));
+        a(414, "rabbit_foot", (new Item()).c("rabbitFoot").b(CreativeModeTab.k));
+        a(415, "rabbit_hide", (new Item()).c("rabbitHide").b(CreativeModeTab.l));
+        a(416, "armor_stand", (new ItemArmorStand()).c("armorStand").d(16));
+        a(417, "iron_horse_armor", (new Item()).c("horsearmormetal").d(1).b(CreativeModeTab.f));
+        a(418, "golden_horse_armor", (new Item()).c("horsearmorgold").d(1).b(CreativeModeTab.f));
+        a(419, "diamond_horse_armor", (new Item()).c("horsearmordiamond").d(1).b(CreativeModeTab.f));
+        a(420, "lead", (new ItemLeash()).c("leash"));
+        a(421, "name_tag", (new ItemNameTag()).c("nameTag"));
+        a(422, "command_block_minecart", (new ItemMinecart(EntityMinecartAbstract.EnumMinecartType.COMMAND_BLOCK)).c("minecartCommandBlock").b((CreativeModeTab) null));
+        a(423, "mutton", (new ItemFood(2, 0.3F, true)).c("muttonRaw"));
+        a(424, "cooked_mutton", (new ItemFood(6, 0.8F, true)).c("muttonCooked"));
+        a(425, "banner", (new ItemBanner()).c("banner"));
+        a(426, "end_crystal", new ItemEndCrystal());
+        a(427, "spruce_door", (new ItemDoor(Blocks.SPRUCE_DOOR)).c("doorSpruce"));
+        a(428, "birch_door", (new ItemDoor(Blocks.BIRCH_DOOR)).c("doorBirch"));
+        a(429, "jungle_door", (new ItemDoor(Blocks.JUNGLE_DOOR)).c("doorJungle"));
+        a(430, "acacia_door", (new ItemDoor(Blocks.ACACIA_DOOR)).c("doorAcacia"));
+        a(431, "dark_oak_door", (new ItemDoor(Blocks.DARK_OAK_DOOR)).c("doorDarkOak"));
+        a(432, "chorus_fruit", (new ItemChorusFruit(4, 0.3F)).h().c("chorusFruit").b(CreativeModeTab.l));
+        a(433, "chorus_fruit_popped", (new Item()).c("chorusFruitPopped").b(CreativeModeTab.l));
+        a(434, "beetroot", (new ItemFood(1, 0.6F, false)).c("beetroot"));
+        a(435, "beetroot_seeds", (new ItemSeeds(Blocks.BEETROOT, Blocks.FARMLAND)).c("beetroot_seeds"));
+        a(436, "beetroot_soup", (new ItemSoup(6)).c("beetroot_soup"));
+        a(437, "dragon_breath", (new Item()).b(CreativeModeTab.k).c("dragon_breath").b(item1));
+        a(438, "splash_potion", (new ItemSplashPotion()).c("splash_potion"));
+        a(439, "spectral_arrow", (new ItemSpectralArrow()).c("spectral_arrow"));
+        a(440, "tipped_arrow", (new ItemTippedArrow()).c("tipped_arrow"));
+        a(441, "lingering_potion", (new ItemLingeringPotion()).c("lingering_potion"));
+        a(442, "shield", (new ItemShield()).c("shield"));
+        a(443, "elytra", (new ItemElytra()).c("elytra"));
+        a(444, "spruce_boat", new ItemBoat(EntityBoat.EnumBoatType.SPRUCE));
+        a(445, "birch_boat", new ItemBoat(EntityBoat.EnumBoatType.BIRCH));
+        a(446, "jungle_boat", new ItemBoat(EntityBoat.EnumBoatType.JUNGLE));
+        a(447, "acacia_boat", new ItemBoat(EntityBoat.EnumBoatType.ACACIA));
+        a(448, "dark_oak_boat", new ItemBoat(EntityBoat.EnumBoatType.DARK_OAK));
+        a(449, "totem_of_undying", (new Item()).c("totem").d(1).b(CreativeModeTab.j));
+        a(450, "shulker_shell", (new Item()).c("shulkerShell").b(CreativeModeTab.l));
+        a(452, "iron_nugget", (new Item()).c("ironNugget").b(CreativeModeTab.l));
+        a(453, "knowledge_book", (new ItemKnowledgeBook()).c("knowledgeBook"));
+        a(2256, "record_13", (new ItemRecord("13", SoundEffects.gb)).c("record"));
+        a(2257, "record_cat", (new ItemRecord("cat", SoundEffects.gd)).c("record"));
+        a(2258, "record_blocks", (new ItemRecord("blocks", SoundEffects.gc)).c("record"));
+        a(2259, "record_chirp", (new ItemRecord("chirp", SoundEffects.ge)).c("record"));
+        a(2260, "record_far", (new ItemRecord("far", SoundEffects.gf)).c("record"));
+        a(2261, "record_mall", (new ItemRecord("mall", SoundEffects.gg)).c("record"));
+        a(2262, "record_mellohi", (new ItemRecord("mellohi", SoundEffects.gh)).c("record"));
+        a(2263, "record_stal", (new ItemRecord("stal", SoundEffects.gi)).c("record"));
+        a(2264, "record_strad", (new ItemRecord("strad", SoundEffects.gj)).c("record"));
+        a(2265, "record_ward", (new ItemRecord("ward", SoundEffects.gl)).c("record"));
+        a(2266, "record_11", (new ItemRecord("11", SoundEffects.ga)).c("record"));
+        a(2267, "record_wait", (new ItemRecord("wait", SoundEffects.gk)).c("record"));
+    }
+
+    private static void b(Block block) {
+        a(block, (Item) (new ItemBlock(block)));
+    }
+
+    protected static void a(Block block, Item item) {
+        registerItem(Block.getId(block), (MinecraftKey) Block.REGISTRY.b(block), item);
+        Item.a.put(block, item);
+    }
+
+    private static void a(int i, String s, Item item) {
+        registerItem(i, new MinecraftKey(s), item);
+    }
+
+    //OilSpigot pail public registerItem
+    public static void registerItem(int i, MinecraftKey minecraftkey, Item item) {
+        highestId = Math.max(highestId, i);
+        Item.REGISTRY.a(i, minecraftkey, item);
+    }
+
+    //OilSpigot
+    public static int getHighestId() {
+        return highestId;
+    }
+
+    public static enum EnumToolMaterial {
+
+        WOOD(0, 59, 2.0F, 0.0F, 15), STONE(1, 131, 4.0F, 1.0F, 5), IRON(2, 250, 6.0F, 2.0F, 14), DIAMOND(3, 1561, 8.0F, 3.0F, 10), GOLD(0, 32, 12.0F, 0.0F, 22);
+
+        private final int f;
+        private final int g;
+        private final float h;
+        private final float i;
+        private final int j;
+
+        private EnumToolMaterial(int i, int j, float f, float f1, int k) {
+            this.f = i;
+            this.g = j;
+            this.h = f;
+            this.i = f1;
+            this.j = k;
+        }
+
+        public int a() {
+            return this.g;
+        }
+
+        public float b() {
+            return this.h;
+        }
+
+        public float c() {
+            return this.i;
+        }
+
+        public int d() {
+            return this.f;
+        }
+
+        public int e() {
+            return this.j;
+        }
+
+        public Item f() {
+            return this == EnumToolMaterial.WOOD ? Item.getItemOf(Blocks.PLANKS) : (this == EnumToolMaterial.STONE ? Item.getItemOf(Blocks.COBBLESTONE) : (this == EnumToolMaterial.GOLD ? Items.GOLD_INGOT : (this == EnumToolMaterial.IRON ? Items.IRON_INGOT : (this == EnumToolMaterial.DIAMOND ? Items.DIAMOND : null))));
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/ItemAxe.java b/src/main/java/net/minecraft/server/ItemAxe.java
new file mode 100644
index 00000000..7201ea0a
--- /dev/null
+++ b/src/main/java/net/minecraft/server/ItemAxe.java
@@ -0,0 +1,36 @@
+package net.minecraft.server;
+
+import com.google.common.collect.Sets;
+import org.oilmod.api.blocks.BlockType;
+import org.oilmod.spigot.util.OilSpigotUtil;
+
+import java.util.Set;
+
+public class ItemAxe extends ItemTool {
+
+    //OilSpigot Pail public BLOCKS
+    public static final Set<Block> BLOCKS = Sets.newHashSet(new Block[] { Blocks.PLANKS, Blocks.BOOKSHELF, Blocks.LOG, Blocks.LOG2, Blocks.CHEST, Blocks.PUMPKIN, Blocks.LIT_PUMPKIN, Blocks.MELON_BLOCK, Blocks.LADDER, Blocks.WOODEN_BUTTON, Blocks.WOODEN_PRESSURE_PLATE});
+    private static final float[] f = new float[] { 6.0F, 8.0F, 8.0F, 8.0F, 6.0F};
+    private static final float[] n = new float[] { -3.2F, -3.2F, -3.1F, -3.0F, -3.0F};
+
+    protected ItemAxe(EnumToolMaterial item_enumtoolmaterial) {
+        super(item_enumtoolmaterial, ItemAxe.BLOCKS);
+        this.b = ItemAxe.f[item_enumtoolmaterial.ordinal()];
+        this.c = ItemAxe.n[item_enumtoolmaterial.ordinal()];
+    }
+
+    public float getDestroySpeed(ItemStack itemstack, IBlockData iblockdata) {
+        Material material = iblockdata.getMaterial();
+
+        return material != Material.WOOD && material != Material.PLANT && material != Material.REPLACEABLE_PLANT  && !material.getOilBlockType().breakableAxe(OilSpigotUtil.toBukkit(iblockdata.getBlock())) ? super.getDestroySpeed(itemstack, iblockdata) : this.a;
+    }
+
+    //OilSpigot start
+    @Override
+    public boolean canDestroySpecialBlock(IBlockData iblockdata) {
+        Block block = iblockdata.getBlock();
+        BlockType blockType = iblockdata.getMaterial().getOilBlockType();
+        return (!block.isVanilla() && blockType.breakableAxe(OilSpigotUtil.toBukkit(block))) || super.canDestroySpecialBlock(iblockdata);
+    }
+    //OilSpigot end
+}
diff --git a/src/main/java/net/minecraft/server/ItemKnowledgeBook.java b/src/main/java/net/minecraft/server/ItemKnowledgeBook.java
new file mode 100644
index 00000000..57a8d13a
--- /dev/null
+++ b/src/main/java/net/minecraft/server/ItemKnowledgeBook.java
@@ -0,0 +1,55 @@
+package net.minecraft.server;
+
+import com.google.common.collect.Lists;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public class ItemKnowledgeBook extends Item {
+
+    private static final Logger a = LogManager.getLogger();
+
+    public ItemKnowledgeBook() {
+        this.d(1);
+    }
+
+    public InteractionResultWrapper<ItemStack> a(World world, EntityHuman entityhuman, EnumHand enumhand) {
+        ItemStack itemstack = entityhuman.b(enumhand);
+        NBTTagCompound nbttagcompound = itemstack.getTag();
+
+        if (!entityhuman.abilities.canInstantlyBuild) {
+            entityhuman.a(enumhand, ItemStack.a);
+        }
+
+        if (nbttagcompound != null && nbttagcompound.hasKeyOfType("Recipes", 9)) {
+            if (!world.isClientSide) {
+                NBTTagList nbttaglist = nbttagcompound.getList("Recipes", 8);
+                ArrayList arraylist = Lists.newArrayList();
+
+                for (int i = 0; i < nbttaglist.size(); ++i) {
+                    String s = nbttaglist.getString(i);
+                    //OilSpigot use getByKey
+                    IRecipe irecipe = CraftingManager.getByKey(new MinecraftKey(s));
+
+                    if (irecipe == null) {
+                        ItemKnowledgeBook.a.error("Invalid recipe: " + s);
+                        return new InteractionResultWrapper(EnumInteractionResult.FAIL, itemstack);
+                    }
+
+                    arraylist.add(irecipe);
+                }
+
+                //OilSpigot fix decompile error
+                entityhuman.a((Collection<MobEffect>) arraylist);
+                entityhuman.b(StatisticList.b((Item) this));
+            }
+
+            return new InteractionResultWrapper(EnumInteractionResult.SUCCESS, itemstack);
+        } else {
+            ItemKnowledgeBook.a.error("Tag not valid: " + nbttagcompound);
+            return new InteractionResultWrapper(EnumInteractionResult.FAIL, itemstack);
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/ItemPickaxe.java b/src/main/java/net/minecraft/server/ItemPickaxe.java
new file mode 100644
index 00000000..59fc5ac6
--- /dev/null
+++ b/src/main/java/net/minecraft/server/ItemPickaxe.java
@@ -0,0 +1,39 @@
+package net.minecraft.server;
+
+import com.google.common.collect.Sets;
+import org.oilmod.spigot.util.OilSpigotUtil;
+
+import java.util.Set;
+
+//OilSpigot KEEPSYNC
+public class ItemPickaxe extends ItemTool {
+
+    //OilSpigot Pail public BLOCKS
+    public static final Set<Block> BLOCKS = Sets.newHashSet(new Block[] { Blocks.ACTIVATOR_RAIL, Blocks.COAL_ORE, Blocks.COBBLESTONE, Blocks.DETECTOR_RAIL, Blocks.DIAMOND_BLOCK, Blocks.DIAMOND_ORE, Blocks.DOUBLE_STONE_SLAB, Blocks.GOLDEN_RAIL, Blocks.GOLD_BLOCK, Blocks.GOLD_ORE, Blocks.ICE, Blocks.IRON_BLOCK, Blocks.IRON_ORE, Blocks.LAPIS_BLOCK, Blocks.LAPIS_ORE, Blocks.LIT_REDSTONE_ORE, Blocks.MOSSY_COBBLESTONE, Blocks.NETHERRACK, Blocks.PACKED_ICE, Blocks.RAIL, Blocks.REDSTONE_ORE, Blocks.SANDSTONE, Blocks.RED_SANDSTONE, Blocks.STONE, Blocks.STONE_SLAB, Blocks.STONE_BUTTON, Blocks.STONE_PRESSURE_PLATE});
+
+    protected ItemPickaxe(EnumToolMaterial item_enumtoolmaterial) {
+        super(1.0F, -2.8F, item_enumtoolmaterial, ItemPickaxe.BLOCKS);
+    }
+
+    public boolean canDestroySpecialBlock(IBlockData iblockdata) {
+        Block block = iblockdata.getBlock();
+
+
+        //OilSpigot start
+        Material material = iblockdata.getMaterial();
+
+        //OilSpigot auto-simplify + added own check
+        boolean result = material == Material.STONE || material == Material.ORE || material == Material.HEAVY || //Materials
+                (!block.isVanilla() && material.getOilBlockType().breakablePickaxe(OilSpigotUtil.toBukkit(block))); //Modded support
+
+        //OilSpigot use new method getHardness instead of doing this weird if
+        return result && block.getHardness() >= 0 ? this.d.d() >= block.getHardness() : result;
+    }
+
+    public float getDestroySpeed(ItemStack itemstack, IBlockData iblockdata) {
+        Material material = iblockdata.getMaterial();
+
+        //OilSpigot added own check
+        return material != Material.ORE && material != Material.HEAVY && material != Material.STONE  && !(!iblockdata.getBlock().isVanilla() && material.getOilBlockType().breakablePickaxe(OilSpigotUtil.toBukkit(iblockdata.getBlock()))) ? super.getDestroySpeed(itemstack, iblockdata) : this.a;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/ItemShears.java b/src/main/java/net/minecraft/server/ItemShears.java
new file mode 100644
index 00000000..a1e6131b
--- /dev/null
+++ b/src/main/java/net/minecraft/server/ItemShears.java
@@ -0,0 +1,46 @@
+package net.minecraft.server;
+
+import com.google.common.collect.Sets;
+
+import java.util.Set;
+
+public class ItemShears extends Item {
+
+    public ItemShears() {
+        this.d(1);
+        this.setMaxDurability(238);
+        this.b(CreativeModeTab.i);
+    }
+
+    public boolean a(ItemStack itemstack, World world, IBlockData iblockdata, BlockPosition blockposition, EntityLiving entityliving) {
+        if (!world.isClientSide) {
+            itemstack.damage(1, entityliving);
+        }
+
+        Block block = iblockdata.getBlock();
+
+        return iblockdata.getMaterial() != Material.LEAVES && block != Blocks.WEB && block != Blocks.TALLGRASS && block != Blocks.VINE && block != Blocks.TRIPWIRE && block != Blocks.WOOL ? super.a(itemstack, world, iblockdata, blockposition, entityliving) : true;
+    }
+
+    public boolean canDestroySpecialBlock(IBlockData iblockdata) {
+        Block block = iblockdata.getBlock();
+        //OilSpigot start
+        Material material = iblockdata.getMaterial();
+
+        return block == Blocks.WEB || block == Blocks.REDSTONE_WIRE || block == Blocks.TRIPWIRE;
+    }
+
+    public float getDestroySpeed(ItemStack itemstack, IBlockData iblockdata) {
+        Block block = iblockdata.getBlock();
+        //OilSpigot start - use material and simplify code//TODO write a unit test for this
+        Material material = iblockdata.getMaterial();
+
+
+        if (block == Blocks.WOOL || material == Material.WOOL) {
+            return 5;
+        }
+
+        return material != Material.WEB && material != Material.LEAVES ? super.getDestroySpeed(itemstack, iblockdata) : 15.0F;
+        //OilSpigot end
+    }
+}
diff --git a/src/main/java/net/minecraft/server/ItemSpade.java b/src/main/java/net/minecraft/server/ItemSpade.java
new file mode 100644
index 00000000..e5007826
--- /dev/null
+++ b/src/main/java/net/minecraft/server/ItemSpade.java
@@ -0,0 +1,65 @@
+package net.minecraft.server;
+
+import com.google.common.collect.Sets;
+import org.oilmod.api.blocks.BlockType;
+import org.oilmod.spigot.util.OilSpigotUtil;
+
+import java.util.Set;
+
+public class ItemSpade extends ItemTool {
+
+    //OilSpigot Pail public BLOCKS
+    public static final Set<Block> BLOCKS = Sets.newHashSet(new Block[] { Blocks.CLAY, Blocks.DIRT, Blocks.FARMLAND, Blocks.GRASS, Blocks.GRAVEL, Blocks.MYCELIUM, Blocks.SAND, Blocks.SNOW, Blocks.SNOW_LAYER, Blocks.SOUL_SAND, Blocks.GRASS_PATH, Blocks.dS});
+
+    public ItemSpade(EnumToolMaterial item_enumtoolmaterial) {
+        super(1.5F, -3.0F, item_enumtoolmaterial, ItemSpade.BLOCKS);
+    }
+
+    public boolean canDestroySpecialBlock(IBlockData iblockdata) {
+        Block block = iblockdata.getBlock();
+
+        //OilSpigot use material.breakableShovel
+        return block == Blocks.SNOW_LAYER || block == Blocks.SNOW || (!block.isVanilla() && iblockdata.getMaterial().getOilBlockType().breakableShovel(OilSpigotUtil.toBukkit(block)));
+    }
+
+    //OilSpigot start
+    public EnumInteractionResult a(EntityHuman entityhuman, World world, BlockPosition blockposition, EnumHand enumhand, EnumDirection enumdirection, float f, float f1, float f2) {
+        ItemStack itemstack = entityhuman.b(enumhand);
+
+        //use static method  instead
+        return onItemUse(entityhuman, itemstack, world, blockposition, enumdirection);
+    }
+
+    //make static to avoid duplicated code
+
+    public static EnumInteractionResult onItemUse(EntityHuman entityhuman, ItemStack itemstack, World world, BlockPosition blockposition, EnumDirection enumdirection) {
+        if (!entityhuman.a(blockposition.shift(enumdirection), enumdirection, itemstack)) {
+            return EnumInteractionResult.FAIL;
+        } else {
+            IBlockData iblockdata = world.getType(blockposition);
+            Block block = iblockdata.getBlock();
+
+            if (enumdirection != EnumDirection.DOWN && world.getType(blockposition.up()).getMaterial() == Material.AIR && block == Blocks.GRASS) {
+                IBlockData iblockdata1 = Blocks.GRASS_PATH.getBlockData();
+
+                world.a(entityhuman, blockposition, SoundEffects.gz, SoundCategory.BLOCKS, 1.0F, 1.0F);
+                if (!world.isClientSide) {
+                    world.setTypeAndData(blockposition, iblockdata1, 11);
+                    itemstack.damage(1, entityhuman);
+                }
+
+                return EnumInteractionResult.SUCCESS;
+            } else {
+                return EnumInteractionResult.PASS;
+            }
+        }
+    }
+
+    //make sure it uses material.breakableShovel
+    public float getDestroySpeed(ItemStack itemstack, IBlockData iblockdata) {
+        Block block = iblockdata.getBlock();
+        BlockType blockType = iblockdata.getMaterial().getOilBlockType();
+        return !block.isVanilla() && blockType.breakableShovel(OilSpigotUtil.toBukkit(block)) ? this.a : super.getDestroySpeed(itemstack, iblockdata);
+    }
+    //OilSpigot end
+}
diff --git a/src/main/java/net/minecraft/server/ItemStack.java b/src/main/java/net/minecraft/server/ItemStack.java
index 53e0688d..28aa3b95 100644
--- a/src/main/java/net/minecraft/server/ItemStack.java
+++ b/src/main/java/net/minecraft/server/ItemStack.java
@@ -19,8 +19,20 @@ import org.bukkit.craftbukkit.util.CraftMagicNumbers;
 import org.bukkit.entity.Player;
 import org.bukkit.event.world.StructureGrowEvent;
 // CraftBukkit end
+//OilSpigot start
+import org.oilmod.api.config.Compound;
+import org.oilmod.api.config.DataType;
+import org.oilmod.spigot.config.nbttag.NBTCompound;
+import org.oilmod.spigot.enchantments.CustomEnchantment;
+import org.oilmod.spigot.items.*;
+import de.sirati97.spigot.optimisation.ItemStackFreeze;
 
-public final class ItemStack {
+import java.util.ArrayList;
+import org.apache.commons.lang3.Validate;
+import static org.spigotmc.ValidateUtils.limit;
+//OilSpigot end
+
+public class ItemStack { //OilSpigot - removed final
 
     public static final ItemStack a = new ItemStack((Item) null);
     public static final DecimalFormat b = new DecimalFormat("#.##");
@@ -78,6 +90,9 @@ public final class ItemStack {
     }
 
     public ItemStack(Item item, int i, int j, boolean convert) {
+        //OilSpigot this check is dirty but makes debugging easier
+        Validate.isTrue(item instanceof RealItem == this instanceof RealItemStack, "Illegal instance. Mod items need to go with Mod itemstacks");
+
         // CraftBukkit end
         this.item = item;
         this.damage = j;
@@ -86,7 +101,7 @@ public final class ItemStack {
         if (MinecraftServer.getServer() != null) {
             this.setData(j);
         }
-        if (convert) {
+        if (convert) { //TODO: possible break here - maybe exclude moditemstack
             this.convertStack();
         }
         // CraftBukkit end
@@ -112,37 +127,56 @@ public final class ItemStack {
             this.load(savedStack);
         }
     }
-
+    //OilSpigot void -> ItemStack
     private void F() {
         if (this.g && this == ItemStack.a) throw new AssertionError("TRAP"); // CraftBukkit
-        this.g = this.isEmpty();
+        if (!isDegenerate() && this.isEmpty()) {
+            setDegenerate(true);
+            //same as isEmpty but without degenerte
+        } else if (isDegenerate() && !this.isEmpty()) {
+            setDegenerate(false);
+        }
     }
 
-    // CraftBukkit - break into own method
-    public void load(NBTTagCompound nbttagcompound) {
-        this.item = nbttagcompound.hasKeyOfType("id", 8) ? Item.b(nbttagcompound.getString("id")) : Item.getItemOf(Blocks.AIR); // Paper - fix NumberFormatException caused by attempting to read an EMPTY ItemStack
-        this.count = nbttagcompound.getByte("Count");
-        // CraftBukkit start - Route through setData for filtering
-        // this.damage = Math.max(0, nbttagcompound.getShort("Damage"));
-        this.setData(nbttagcompound.getShort("Damage"));
-        // CraftBukkit end
+    public static ItemStack createStack(NBTTagCompound nbttagcompound) {
+        //OilSpigot start
+        return createStack(new NBTCompound(nbttagcompound));
+        //OilSpigot end
+    }
 
-        if (nbttagcompound.hasKeyOfType("tag", 10)) {
-            // CraftBukkit start - make defensive copy as this data may be coming from the save thread
-            this.tag = (NBTTagCompound) nbttagcompound.getCompound("tag").clone();
-            processEnchantOrder(this.tag); // Paper
-            if (this.item != null) {
-                this.item.a(this.tag);
-                // CraftBukkit end
-            }
+    //OilSpigot start
+    public static ItemStack createStack(Compound compound) {
+        Item item = compound.containsKey("id", DataType.String) ? Item.b(compound.getString("id")) : Item.getItemOf(Blocks.AIR); // Paper - fix NumberFormatException caused by attempting to read an EMPTY ItemStack
+        ItemStack itemstack;
+        if (item instanceof RealItem) {
+            itemstack =  ItemUtil.createNBT((RealItem) item, compound);
+            return itemstack == null ? ItemStack.a  : itemstack;
+        } else {
+            itemstack = new ItemStack(compound);
+            return itemstack.getItem() == null ? ItemStack.a  : itemstack;
+        }
+    }
+
+
+    public static ItemStack createStackVanilla(Item item, int count, int data, NBTTagCompound tag) {
+        ItemStack itemStack = new ItemStack(item, count, data);
+        if (tag != null) {
+            itemStack.setTag(tag);
         }
+        return itemStack;
     }
 
-    public ItemStack(NBTTagCompound nbttagcompound) {
+
+    private ItemStack(NBTTagCompound nbttagcompound) { // OilSpigot: protected -> privat
         this.load(nbttagcompound);
-        // CraftBukkit end
-        this.F();
+
+    }
+
+    protected ItemStack(Compound compound) {
+        this.load(compound);
+
     }
+    //OilSpigot end
 
     // Paper start - optimize isEmpty
     private static Item airItem;
@@ -343,6 +377,64 @@ public final class ItemStack {
         return nbttagcompound;
     }
 
+    //OilSpigot start
+    public Compound save(Compound compound) {
+        MinecraftKey minecraftkey = (MinecraftKey) Item.REGISTRY.b(this.item);
+
+        compound.setString("id", minecraftkey == null ? "minecraft:air" : minecraftkey.toString());
+        if (this.count != 1) {
+            compound.setByte("Count", (byte) this.count);
+        }
+        if (this.damage != 0) {
+            compound.setShort("Damage", (short) this.damage);
+        }
+
+        if (this.tag != null) {
+            compound.setNBT("tag", this.tag.clone()); // CraftBukkit - make defensive copy, data is going to another thread
+        }
+
+        return compound;
+    }
+    //OilSpigot end
+
+    //OilSpigot start
+    public void load(Compound compound) { //same name as  public void c(NBTTagCompound nbttagcompound) {...}
+
+        this.item = Item.b(compound.getString("id"));
+        this.count = compound.containsKey("Count")?compound.getByte("Count"):1; //key can be missing - optimization
+        this.setData(compound.getShort("Damage"));
+
+        if (compound.containsKey("tag")) {
+            // CraftBukkit - make defensive copy as this data may be coming from the save thread
+            this.tag = (NBTTagCompound) compound.getCompound("tag").nbtClone();
+            if (this.item != null) {
+                this.item.a(this.tag);
+            }
+        }
+
+        processEnchantOrder(this.tag); // Paper
+    }
+    //OilSpigot end
+
+    // CraftBukkit - break into own method
+    public void load(NBTTagCompound nbttagcompound) {
+        this.item = Item.b(nbttagcompound.getString("id"));
+        this.count = nbttagcompound.getByte("Count");
+        // CraftBukkit start - Route through setData for filtering
+        // this.damage = Math.max(0, nbttagcompound.getShort("Damage"));
+        this.setData(nbttagcompound.getShort("Damage"));
+        // CraftBukkit end
+
+        if (nbttagcompound.hasKeyOfType("tag", 10)) {
+            // CraftBukkit start - make defensive copy as this data may be coming from the save thread
+            this.tag = (NBTTagCompound) nbttagcompound.getCompound("tag").clone();
+            if (this.item != null) {
+                this.item.a(this.tag);
+                // CraftBukkit end
+            }
+        }
+    }
+
     public int getMaxStackSize() {
         return this.getItem().getMaxStackSize();
     }
@@ -404,11 +496,13 @@ public final class ItemStack {
         return this.getItem().getMaxDurability();
     }
 
-    public boolean isDamaged(int i, Random random, @Nullable EntityPlayer entityplayer) {
+    //OilSpigot changed to EntityLiving param
+    public boolean isDamaged(int i, Random random, EntityLiving entityliving) {
         if (!this.f()) {
             return false;
         } else {
             if (i > 0) {
+                @Nullable EntityPlayer entityplayer = entityliving instanceof EntityPlayer ? (EntityPlayer) entityliving : null;
                 int j = EnchantmentManager.getEnchantmentLevel(Enchantments.DURABILITY, this);
                 int k = 0;
 
@@ -436,14 +530,21 @@ public final class ItemStack {
                 }
             }
 
-            if (entityplayer != null && i != 0) {
-                CriterionTriggers.s.a(entityplayer, this, this.damage + i);
-            }
+            //OilSpigot moved to handleDamage
+            return handleDamage(i, entityliving);
+        }
+    }
 
-            this.damage += i;
-            return this.damage > this.k();
+    //OilSpigot start
+    protected boolean handleDamage(int damage, EntityLiving entityliving) {
+        if (entityliving instanceof EntityPlayer && damage != 0) {
+            CriterionTriggers.s.a((EntityPlayer) entityliving, this, this.damage + damage);
         }
+
+        this.damage += damage;
+        return this.damage > this.k();
     }
+    //OilSpigot end
 
     public void damage(int i, EntityLiving entityliving) {
         if (!(entityliving instanceof EntityHuman) || !((EntityHuman) entityliving).abilities.canInstantlyBuild) {
@@ -523,7 +624,10 @@ public final class ItemStack {
     // Spigot End
 
     public static boolean matches(ItemStack itemstack, ItemStack itemstack1) {
-        return itemstack.isEmpty() && itemstack1.isEmpty() ? true : (!itemstack.isEmpty() && !itemstack1.isEmpty() ? itemstack.d(itemstack1) : false);
+
+        //System.out.println((itemstack ==null?"nullstack":itemstack.toString()) + " and " + (itemstack1 ==null?"nullstack":itemstack1.toString())); //OilSpigot debug
+        //OilSpigot - just automatic simplification no logic change
+        return itemstack.isEmpty() && itemstack1.isEmpty() || ((!itemstack.isEmpty() && !itemstack1.isEmpty()) && itemstack.d(itemstack1));
     }
 
     private boolean d(ItemStack itemstack) {
@@ -546,6 +650,18 @@ public final class ItemStack {
         return !this.f() ? this.doMaterialsMatch(itemstack) : !itemstack.isEmpty() && this.item == itemstack.item;
     }
 
+    //OilSpigot start
+    public static boolean matchesIgnoresCount(ItemStack itemstack, ItemStack itemstack1) {
+        return itemstack == null && itemstack1 == null || ((itemstack != null && itemstack1 != null) && itemstack._matchesIgnoresCount(itemstack1));
+    }
+
+    private boolean _matchesIgnoresCount(ItemStack itemstack) {
+        return this.item == itemstack.item &&
+                this.damage == itemstack.damage &&
+                (this.hasTag()?(itemstack.hasTag()&&this.tag.equals(itemstack.tag)):!itemstack.hasTag());
+    }
+    //OilSpigot end
+
     public String a() {
         return this.getItem().a(this);
     }
@@ -592,7 +708,7 @@ public final class ItemStack {
         return this.tag;
     }
 
-    public NBTTagCompound c(String s) {
+    public NBTTagCompound c(String s) { //create or get nbt
         if (this.tag != null && this.tag.hasKeyOfType(s, 10)) {
             return this.tag.getCompound(s);
         } else {
@@ -604,7 +720,7 @@ public final class ItemStack {
     }
 
     @Nullable
-    public NBTTagCompound d(String s) {
+    public NBTTagCompound d(String s) {//get or null
         return this.tag != null && this.tag.hasKeyOfType(s, 10) ? this.tag.getCompound(s) : null;
     }
 
@@ -651,17 +767,23 @@ public final class ItemStack {
         return this.getItem().b(this);
     }
 
-    public ItemStack f(String s) {
+    public ItemStack f(String s) {//OilSpigot set localised display name
         this.c("display").setString("LocName", s);
         return this;
     }
 
-    public ItemStack g(String s) {
-        this.c("display").setString("Name", s);
+    //OilSpigot g -> setTitle
+    public final ItemStack g(String s) { //OilSpigot set display name
+        return setDisplayName(s);
+    }
+
+    public ItemStack setDisplayName(String displayName) {
+        this.c("display").setString("Name", displayName);
         return this;
     }
 
-    public void s() {
+
+    public void removeDisplayName() {
         NBTTagCompound nbttagcompound = this.d("display");
 
         if (nbttagcompound != null) {
@@ -674,6 +796,11 @@ public final class ItemStack {
         if (this.tag != null && this.tag.isEmpty()) {
             this.tag = null;
         }
+    }
+
+    //OilSpigot s -> removeDisplayName
+    public final void s() { //OilSpigot removeDisplayName?!????
+        removeDisplayName();
 
     }
 
@@ -691,17 +818,29 @@ public final class ItemStack {
         return !this.getItem().g_(this) ? false : !this.hasEnchantments();
     }
 
+    //OilSpigot start - add support for custom enchantments
     public void addEnchantment(Enchantment enchantment, int i) {
         if (this.tag == null) {
             this.setTag(new NBTTagCompound());
         }
+        if (enchantment instanceof CustomEnchantment) {
+            if (!this.tag.hasKeyOfType("cuEnch", 9)) {
+                this.tag.set("cuEnch", new NBTTagList());
+            }
 
-        if (!this.tag.hasKeyOfType("ench", 9)) {
-            this.tag.set("ench", new NBTTagList());
-        }
+            NBTTagList nbttaglist = this.tag.getList("cuEnch", 10);
+            NBTTagCompound nbttagcompound = new NBTTagCompound();
 
-        NBTTagList nbttaglist = this.tag.getList("ench", 10);
-        NBTTagCompound nbttagcompound = new NBTTagCompound();
+            nbttagcompound.setString("key", ((CustomEnchantment) enchantment).getEnchantKey());
+            nbttagcompound.setShort("lvl", (short) ((byte) i));
+            nbttaglist.add(nbttagcompound);
+        } else {
+            if (!this.tag.hasKeyOfType("ench", 9)) {
+                this.tag.set("ench", new NBTTagList());
+            }
+
+            NBTTagList nbttaglist = this.tag.getList("ench", 10);
+            NBTTagCompound nbttagcompound = new NBTTagCompound();
 
         nbttagcompound.setShort("id", (short) Enchantment.getId(enchantment));
         nbttagcompound.setShort("lvl", (short) ((byte) i));
@@ -709,10 +848,73 @@ public final class ItemStack {
         processEnchantOrder(nbttagcompound); // Paper
     }
 
+
+    }
+
     public boolean hasEnchantments() {
-        return this.tag != null && this.tag.hasKeyOfType("ench", 9) ? !this.tag.getList("ench", 10).isEmpty() : false;
+        //OilSpigot add support for custom enchantments
+        return this.tag != null &&
+                ((this.tag.hasKeyOfType("ench", 9) && !this.tag.getList("ench", 10).isEmpty()) ||
+                (this.tag.hasKeyOfType("cuEnch", 9) && !this.tag.getList("cuEnch", 10).isEmpty())) ;
     }
 
+    public NBTTagList getCustomEnchantments() {
+        return this.tag == null ? null : this.tag.getList("cuEnch", 10);
+    }
+    //OilSpigot end - add support for custom enchantments
+
+    //OilSpigot start
+    public List<String> getLore() {
+        List<String> lore = null;
+        NBTTagCompound tag = getTagSafe();
+        if (tag.hasKey("display")) {
+            NBTTagCompound display = tag.getCompound("display");
+
+            if (display.hasKey("Lore")) {
+                NBTTagList list = display.getList("Lore", 8);
+                lore = new ArrayList<String>(list.size());
+
+                for (int index = 0; index < list.size(); index++) {
+                    String line = limit( list.getString(index), 1024 ); // Spigot
+                    lore.add(line);
+                }
+            }
+        }
+        return lore==null?new ArrayList<String>():lore;
+    }
+
+    public void setLore(List<String> lore) {
+        NBTTagCompound tag = getTagSafe();
+        final NBTTagCompound display = tag.getCompound("display");
+
+        if (!tag.hasKey("display")) {
+            tag.set("display", display);
+        }
+
+        NBTTagList loreNbt = null;
+        if (lore != null && !lore.isEmpty()) {
+            loreNbt  = new NBTTagList();
+            for (String value : lore) {
+                loreNbt.add(new NBTTagString(value));
+            }
+        }
+        display.set("Lore", loreNbt);
+    }
+
+    public NBTTagCompound getTagSafe() {
+        NBTTagCompound result = getTag();
+        if (result == null) {
+            result = new NBTTagCompound();
+            setTag(result);
+        }
+        return result;
+    }
+
+    public boolean hasLore() {
+        return getTag() != null && getTag().hasKey("display") && getTag().getCompound("display").hasKey("Lore");
+    }
+    //OilSpigot end
+
     public void a(String s, NBTBase nbtbase) {
         if (this.tag == null) {
             this.setTag(new NBTTagCompound());
@@ -758,12 +960,19 @@ public final class ItemStack {
         this.tag.setInt("RepairCost", i);
     }
 
+    //OilSpigot start - make static method
     public Multimap<String, AttributeModifier> a(EnumItemSlot enumitemslot) {
+        return getEntityHoldingAttributes(getTag(), getItem(), enumitemslot);
+    }
+
+    public static Multimap<String, AttributeModifier> getEntityHoldingAttributes(NBTTagCompound tag, Item item, EnumItemSlot enumitemslot) {
+        //OilSpigot end
         Object object;
 
-        if (this.hasTag() && this.tag.hasKeyOfType("AttributeModifiers", 9)) {
+        if (tag != null && tag.hasKeyOfType("AttributeModifiers", 9)) {
             object = HashMultimap.create();
-            NBTTagList nbttaglist = this.tag.getList("AttributeModifiers", 10);
+            NBTTagList nbttaglist = tag.getList("AttributeModifiers", 10);
+
 
             for (int i = 0; i < nbttaglist.size(); ++i) {
                 NBTTagCompound nbttagcompound = nbttaglist.get(i);
@@ -774,7 +983,7 @@ public final class ItemStack {
                 }
             }
         } else {
-            object = this.getItem().a(enumitemslot);
+            object = item.a(enumitemslot);
         }
 
         return (Multimap) object;
@@ -895,4 +1104,19 @@ public final class ItemStack {
     public void subtract(int i) {
         this.add(-i);
     }
+
+    //OilSpigot start
+    public ItemStackFreeze createFreeze() {
+        return isEmpty()?ItemStackFreeze.EMPTY: new ItemStackFreeze(getTag(), getItem(), getCount(), getData());
+    }
+
+    public boolean isDegenerate() {
+        return g;
+    }
+
+    protected void setDegenerate(boolean v) {
+        this.g = v;
+    }
+
+    //OilSpigot end
 }
diff --git a/src/main/java/net/minecraft/server/ItemSword.java b/src/main/java/net/minecraft/server/ItemSword.java
new file mode 100644
index 00000000..64ce0e79
--- /dev/null
+++ b/src/main/java/net/minecraft/server/ItemSword.java
@@ -0,0 +1,73 @@
+package net.minecraft.server;
+
+import com.google.common.collect.Multimap;
+
+public class ItemSword extends Item {
+
+    private final float a;
+    private final EnumToolMaterial b;
+
+    public ItemSword(EnumToolMaterial item_enumtoolmaterial) {
+        this.b = item_enumtoolmaterial;
+        this.maxStackSize = 1;
+        this.setMaxDurability(item_enumtoolmaterial.a());
+        this.b(CreativeModeTab.j);
+        this.a = 3.0F + item_enumtoolmaterial.c();
+    }
+
+    public float g() {
+        return this.b.c();
+    }
+
+    public float getDestroySpeed(ItemStack itemstack, IBlockData iblockdata) {
+        Block block = iblockdata.getBlock();
+
+        if (block == Blocks.WEB) {
+            return 15.0F;
+        } else {
+            Material material = iblockdata.getMaterial();
+
+            return material != Material.PLANT && material != Material.REPLACEABLE_PLANT && material != Material.CORAL && material != Material.LEAVES && material != Material.PUMPKIN ? 1.0F : 1.5F;
+        }
+    }
+
+    public boolean a(ItemStack itemstack, EntityLiving entityliving, EntityLiving entityliving1) {
+        itemstack.damage(1, entityliving1);
+        return true;
+    }
+
+    public boolean a(ItemStack itemstack, World world, IBlockData iblockdata, BlockPosition blockposition, EntityLiving entityliving) {
+        if ((double) iblockdata.b(world, blockposition) != 0.0D) {
+            itemstack.damage(2, entityliving);
+        }
+
+        return true;
+    }
+
+    public boolean canDestroySpecialBlock(IBlockData iblockdata) {
+        return iblockdata.getBlock() == Blocks.WEB;
+    }
+
+    public int c() {
+        return this.b.e();
+    }
+
+    public String h() {
+        return this.b.toString();
+    }
+
+    public boolean a(ItemStack itemstack, ItemStack itemstack1) {
+        return this.b.f() == itemstack1.getItem() ? true : super.a(itemstack, itemstack1);
+    }
+
+    public Multimap<String, AttributeModifier> a(EnumItemSlot enumitemslot) {
+        Multimap multimap = super.a(enumitemslot);
+
+        if (enumitemslot == EnumItemSlot.MAINHAND) {
+            multimap.put(GenericAttributes.ATTACK_DAMAGE.getName(), new AttributeModifier(ItemSword.h, "Weapon modifier", (double) this.a, 0));
+            multimap.put(GenericAttributes.g.getName(), new AttributeModifier(ItemSword.i, "Weapon modifier", -2.4000000953674316D, 0));
+        }
+
+        return multimap;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Material.java b/src/main/java/net/minecraft/server/Material.java
new file mode 100644
index 00000000..a8f45a6c
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Material.java
@@ -0,0 +1,159 @@
+package net.minecraft.server;
+
+import gnu.trove.set.hash.THashSet;
+import org.apache.commons.lang3.Validate;
+import org.oilmod.api.blocks.BlockType;
+import org.oilmod.api.blocks.nms.NMSBlockType;
+import org.oilmod.spigot.block.RealBlockType;
+
+import java.util.Set;
+
+//OilSpigot KEEPSYNC implement NMSBlockType
+public class Material implements NMSBlockType {
+
+    public static final Material AIR = new MaterialGas(MaterialMapColor.c);
+    public static final Material GRASS = new Material(MaterialMapColor.d);
+    public static final Material EARTH = new Material(MaterialMapColor.m);
+    public static final Material WOOD = (new Material(MaterialMapColor.p)).g();
+    public static final Material STONE = (new Material(MaterialMapColor.n)).f();
+    public static final Material ORE = (new Material(MaterialMapColor.i)).f();
+    public static final Material HEAVY = (new Material(MaterialMapColor.i)).f().o();
+    public static final Material WATER = (new MaterialLiquid(MaterialMapColor.o)).n();
+    public static final Material LAVA = (new MaterialLiquid(MaterialMapColor.g)).n();
+    public static final Material LEAVES = (new Material(MaterialMapColor.j)).g().s().n();
+    public static final Material PLANT = (new MaterialDecoration(MaterialMapColor.j)).n();
+    public static final Material REPLACEABLE_PLANT = (new MaterialDecoration(MaterialMapColor.j)).g().n().i();
+    public static final Material SPONGE = new Material(MaterialMapColor.u);
+    public static final Material CLOTH = (new Material(MaterialMapColor.f)).g();
+    public static final Material FIRE = (new MaterialGas(MaterialMapColor.c)).n();
+    public static final Material SAND = new Material(MaterialMapColor.e);
+    public static final Material ORIENTABLE = (new MaterialDecoration(MaterialMapColor.c)).n();
+    public static final Material WOOL = (new MaterialDecoration(MaterialMapColor.f)).g();
+    public static final Material SHATTERABLE = (new Material(MaterialMapColor.c)).s().p();
+    public static final Material BUILDABLE_GLASS = (new Material(MaterialMapColor.c)).p();
+    public static final Material TNT = (new Material(MaterialMapColor.g)).g().s();
+    public static final Material CORAL = (new Material(MaterialMapColor.j)).n();
+    public static final Material ICE = (new Material(MaterialMapColor.h)).s().p();
+    public static final Material PACKED_ICE = (new Material(MaterialMapColor.h)).p(); //OilSpigot PAIL (already done) Bukkit messed up here and swapped SNOW_LAYER and PACKED_ICE
+    public static final Material SNOW_LAYER = (new MaterialDecoration(MaterialMapColor.k)).i().s().f().n();
+    public static final Material SNOW_BLOCK = (new Material(MaterialMapColor.k)).f();
+    public static final Material CACTUS = (new Material(MaterialMapColor.j)).s().n();
+    public static final Material CLAY = new Material(MaterialMapColor.l);
+    public static final Material PUMPKIN = (new Material(MaterialMapColor.j)).n();
+    public static final Material DRAGON_EGG = (new Material(MaterialMapColor.j)).n();
+    public static final Material PORTAL = (new MaterialPortal(MaterialMapColor.c)).o();
+    public static final Material CAKE = (new Material(MaterialMapColor.c)).n();
+    public static final Material WEB = (new Material(MaterialMapColor.f) {
+        public boolean isSolid() {
+            return false;
+        }
+    }).f().n();
+    public static final Material PISTON = (new Material(MaterialMapColor.n)).o();
+    public static final Material BANNER = (new Material(MaterialMapColor.c)).f().o();
+    public static final Material J = new MaterialGas(MaterialMapColor.c);
+    private boolean canBurn;
+    private boolean L;
+    private boolean M;
+    private final MaterialMapColor N;
+    private boolean O = true;
+    private EnumPistonReaction P;
+    private boolean Q;
+    //OilSpigot start
+    //private static final Set<Material> registered = new THashSet<>(); jkda
+    private BlockType oilBlockType;
+
+    public BlockType getOilBlockType() {
+        return oilBlockType;
+    }
+
+    public void initOil(BlockType.BlockTypeEnum oilBlockType) {
+        Validate.isTrue(this.oilBlockType ==null, "Cannot set OilBlockType twice");
+        this.oilBlockType = new RealBlockType(this, oilBlockType);
+    }
+    public void initOil(BlockType oilBlockType) {
+        Validate.isTrue(this.oilBlockType ==null, "Cannot set OilBlockType twice");
+        this.oilBlockType = oilBlockType;
+    }
+
+    //OilSpigot end
+
+    public Material(MaterialMapColor materialmapcolor) {
+        this.P = EnumPistonReaction.NORMAL;
+        this.N = materialmapcolor;
+    }
+
+    public boolean isLiquid() {
+        return false;
+    }
+
+    public boolean isBuildable() {
+        return true;
+    }
+
+    public boolean blocksLight() {
+        return true;
+    }
+
+    public boolean isSolid() {
+        return true;
+    }
+
+    private Material s() {
+        this.M = true;
+        return this;
+    }
+
+    protected Material f() {
+        this.O = false;
+        return this;
+    }
+
+    protected Material g() {
+        this.canBurn = true;
+        return this;
+    }
+
+    public boolean isBurnable() {
+        return this.canBurn;
+    }
+
+    public Material i() {
+        this.L = true;
+        return this;
+    }
+
+    public boolean isReplaceable() {
+        return this.L;
+    }
+
+    public boolean k() {
+        return this.M ? false : this.isSolid();
+    }
+
+    public boolean isAlwaysDestroyable() {
+        return this.O;
+    }
+
+    public EnumPistonReaction getPushReaction() {
+        return this.P;
+    }
+
+    protected Material n() {
+        this.P = EnumPistonReaction.DESTROY;
+        return this;
+    }
+
+    protected Material o() {
+        this.P = EnumPistonReaction.BLOCK;
+        return this;
+    }
+
+    protected Material p() {
+        this.Q = true;
+        return this;
+    }
+
+    public MaterialMapColor r() {
+        return this.N;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/MerchantRecipe.java b/src/main/java/net/minecraft/server/MerchantRecipe.java
index 96f3e16d..b1e50f70 100644
--- a/src/main/java/net/minecraft/server/MerchantRecipe.java
+++ b/src/main/java/net/minecraft/server/MerchantRecipe.java
@@ -97,12 +97,15 @@ public class MerchantRecipe {
     public void a(NBTTagCompound nbttagcompound) {
         NBTTagCompound nbttagcompound1 = nbttagcompound.getCompound("buy");
 
-        this.buyingItem1 = new ItemStack(nbttagcompound1);
+        //OilSpigot use factory method instead
+        this.buyingItem1 = ItemStack.createStack(nbttagcompound1); //OilSpigot
         NBTTagCompound nbttagcompound2 = nbttagcompound.getCompound("sell");
 
-        this.sellingItem = new ItemStack(nbttagcompound2);
+        //OilSpigot use factory method instead
+        this.sellingItem = ItemStack.createStack(nbttagcompound2); //OilSpigot
         if (nbttagcompound.hasKeyOfType("buyB", 10)) {
-            this.buyingItem2 = new ItemStack(nbttagcompound.getCompound("buyB"));
+            //OilSpigot use factory method instead
+            this.buyingItem2 = ItemStack.createStack(nbttagcompound.getCompound("buyB")); //OilSpigot
         }
 
         if (nbttagcompound.hasKeyOfType("uses", 99)) {
diff --git a/src/main/java/net/minecraft/server/MinecraftKey.java b/src/main/java/net/minecraft/server/MinecraftKey.java
new file mode 100644
index 00000000..df9eee6d
--- /dev/null
+++ b/src/main/java/net/minecraft/server/MinecraftKey.java
@@ -0,0 +1,112 @@
+package net.minecraft.server;
+
+import com.google.gson.JsonDeserializationContext;
+import com.google.gson.JsonDeserializer;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonParseException;
+import com.google.gson.JsonPrimitive;
+import com.google.gson.JsonSerializationContext;
+import com.google.gson.JsonSerializer;
+import java.lang.reflect.Type;
+import java.util.Locale;
+import org.apache.commons.lang3.StringUtils;
+import org.apache.commons.lang3.Validate;
+import org.oilmod.api.util.NMSKey;
+
+//OilSpigot implement NMSKey - only change KEEPSYNC
+public class MinecraftKey implements Comparable<MinecraftKey>, NMSKey {
+
+    protected final String a;
+    protected final String b;
+
+    protected MinecraftKey(int i, String... astring) {
+        this.a = StringUtils.isEmpty(astring[0]) ? "minecraft" : astring[0].toLowerCase(Locale.ROOT);
+        this.b = astring[1].toLowerCase(Locale.ROOT);
+        Validate.notNull(this.b);
+    }
+
+    public MinecraftKey(String s) {
+        this(0, a(s));
+    }
+
+    public MinecraftKey(String s, String s1) {
+        this(0, new String[] { s, s1});
+    }
+
+    protected static String[] a(String s) {
+        String[] astring = new String[] { "minecraft", s};
+        int i = s.indexOf(58);
+
+        if (i >= 0) {
+            astring[1] = s.substring(i + 1, s.length());
+            if (i > 1) {
+                astring[0] = s.substring(0, i);
+            }
+        }
+
+        return astring;
+    }
+
+    public String getKey() {
+        return this.b;
+    }
+
+    public String b() {
+        return this.a;
+    }
+
+    public String toString() {
+        return this.a + ':' + this.b;
+    }
+
+    public boolean equals(Object object) {
+        if (this == object) {
+            return true;
+        } else if (!(object instanceof MinecraftKey)) {
+            return false;
+        } else {
+            MinecraftKey minecraftkey = (MinecraftKey) object;
+
+            return this.a.equals(minecraftkey.a) && this.b.equals(minecraftkey.b);
+        }
+    }
+
+    public int hashCode() {
+        return 31 * this.a.hashCode() + this.b.hashCode();
+    }
+
+    public int a(MinecraftKey minecraftkey) {
+        int i = this.a.compareTo(minecraftkey.a);
+
+        if (i == 0) {
+            i = this.b.compareTo(minecraftkey.b);
+        }
+
+        return i;
+    }
+
+    public int compareTo(MinecraftKey object) {
+        return this.a(object);
+    }
+
+    public static class a implements JsonDeserializer<MinecraftKey>, JsonSerializer<MinecraftKey> {
+
+        public a() {}
+
+        public MinecraftKey a(JsonElement jsonelement, Type type, JsonDeserializationContext jsondeserializationcontext) throws JsonParseException {
+            return new MinecraftKey(ChatDeserializer.a(jsonelement, "location"));
+        }
+
+        public JsonElement a(MinecraftKey minecraftkey, Type type, JsonSerializationContext jsonserializationcontext) {
+            return new JsonPrimitive(minecraftkey.toString());
+        }
+
+        public JsonElement serialize(MinecraftKey object, Type type, JsonSerializationContext jsonserializationcontext) {
+            return this.a((MinecraftKey) object, type, jsonserializationcontext);
+        }
+
+        public MinecraftKey deserialize(JsonElement jsonelement, Type type, JsonDeserializationContext jsondeserializationcontext) throws JsonParseException {
+            return this.a(jsonelement, type, jsondeserializationcontext);
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 3b982f99..1a3e0334 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -1156,7 +1156,7 @@ public abstract class MinecraftServer implements ICommandListener, Runnable, IAs
     }
 
     public String getServerModName() {
-        return "Paper"; //Paper - Paper > // Spigot - Spigot > // CraftBukkit - cb > vanilla!
+        return "OilyPaper"; //OilyPaper - OilyPaper > // Spigot - Spigot > // CraftBukkit - cb > vanilla!
     }
 
     public CrashReport b(CrashReport crashreport) {
diff --git a/src/main/java/net/minecraft/server/PacketDataSerializer.java b/src/main/java/net/minecraft/server/PacketDataSerializer.java
index d71734df..d3f6055f 100644
--- a/src/main/java/net/minecraft/server/PacketDataSerializer.java
+++ b/src/main/java/net/minecraft/server/PacketDataSerializer.java
@@ -25,6 +25,13 @@ import javax.annotation.Nullable;
 
 import org.bukkit.craftbukkit.inventory.CraftItemStack; // CraftBukkit
 
+//OilSpigot start
+import org.oilmod.api.items.OilItemStack;
+import org.oilmod.spigot.config.nbttag.NBTCompound;
+import org.oilmod.spigot.items.RealItem;
+import org.oilmod.spigot.items.RealItemStack;
+//OilSpigot end
+
 public class PacketDataSerializer extends ByteBuf {
 
     private final ByteBuf a;
@@ -239,6 +246,39 @@ public class PacketDataSerializer extends ByteBuf {
     public PacketDataSerializer a(ItemStack itemstack) {
         if (itemstack.isEmpty() || itemstack.getItem() == null) { // CraftBukkit - NPE fix itemstack.getItem()
             this.writeShort(-1);
+
+            //OilSpigot start
+        } else if (itemstack.getItem() instanceof RealItem) {
+            RealItemStack stack = (RealItemStack) itemstack;
+            RealItem item = stack.getRealItem();
+
+            this.writeShort(Item.getId(item.getVanillaFakeItem(stack)));
+            this.writeByte(stack.getCount());
+            this.writeShort(item.getVanillaFakeData(stack));
+            NBTTagCompound nbttagcompound = stack.getTag();
+
+            boolean renamed = false;
+            if (nbttagcompound == null) {
+                nbttagcompound = new NBTTagCompound();
+            } else {
+                nbttagcompound = nbttagcompound.g();
+                renamed = nbttagcompound.hasKeyOfType("display", 10);
+            }
+            NBTTagCompound oilTag = new NBTTagCompound();
+            oilTag.setString("id", item.getKey().toString());
+            oilTag.setShort("Damage", (short) stack.getData());
+            if (!renamed) {
+                NBTTagCompound display = new NBTTagCompound();
+                display.setString("Name", "" + stack.getItem().g(stack).e.character + item.getApiItem().getDisplayName());
+                display.setBoolean("Oil", true);
+                nbttagcompound.set("display", display);
+            }
+            stack.saveModBaseCompound(new NBTCompound(oilTag));
+            nbttagcompound.set("oil", oilTag);
+
+            this.a(nbttagcompound);
+
+            //OilSpigot end
         } else {
             this.writeShort(Item.getId(itemstack.getItem()));
             this.writeByte(itemstack.getCount());
@@ -259,25 +299,59 @@ public class PacketDataSerializer extends ByteBuf {
         return this;
     }
 
+    //OilSpigot start - build modded itemstacks if needed
     public ItemStack k() {
-        short short0 = this.readShort();
+        short itemId = this.readShort();
 
-        if (short0 < 0) {
+        if (itemId < 0) {
             return ItemStack.a;
         } else {
-            byte b0 = this.readByte();
-            short short1 = this.readShort();
-            ItemStack itemstack = new ItemStack(Item.getById(short0), b0, short1);
+            byte count = this.readByte();
+            short data = this.readShort();
+            NBTTagCompound tag = this.j();
+            NBTTagCompound oilTag = null;
+            Item item ;
+
+            if (tag != null && tag.hasKeyOfType("oil",10)) {
+                oilTag = tag.getCompound("oil");
+                tag.remove("oil");
+                item = Item.b(oilTag.getString("id"));
+                data = oilTag.getShort("Damage");
+                if (tag.hasKeyOfType("display",10) && tag.getCompound("display").hasKey("Oil")) {
+                    tag.remove("display");
+                }
+            } else {
+                item = Item.getById(itemId);
+            }
+
+
+
+            ItemStack itemstack;
+            if (oilTag != null) {
+                itemstack = RealItemStack.createModdedStack((RealItem) item, count, data, tag, oilTag); //todo: find way to reduce overhead (it reads in all of mTag)
+            } else {
+                itemstack = ItemStack.createStackVanilla(item, count, data, tag);
+            }
+
+
+            if (itemstack == null) {
+                if (oilTag != null) {
+                    throw new IllegalStateException("Received invalid OilMod Itemstack from client!");
+                } else {
+                    throw new IllegalStateException("Created null-itemstack?! This should not happen!");
+                }
+            }
 
-            itemstack.setTag(this.j());
             // CraftBukkit start
-            if (itemstack.getTag() != null) {
-                CraftItemStack.setItemMeta(itemstack, CraftItemStack.getItemMeta(itemstack));
+            if (oilTag != null && itemstack.getTag() != null) {
+                CraftItemStack.setItemMeta(itemstack, CraftItemStack.getItemMeta(itemstack)); //TODO maybe have support for this later as well
             }
             // CraftBukkit end
             return itemstack;
         }
+
     }
+    //OilSpigot end
 
     public String e(int i) {
         int j = this.g();
diff --git a/src/main/java/net/minecraft/server/PacketPlayInAutoRecipe.java b/src/main/java/net/minecraft/server/PacketPlayInAutoRecipe.java
new file mode 100644
index 00000000..3e6fb713
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayInAutoRecipe.java
@@ -0,0 +1,42 @@
+package net.minecraft.server;
+
+import java.io.IOException;
+
+public class PacketPlayInAutoRecipe implements Packet<PacketListenerPlayIn> {
+
+    private int a;
+    private IRecipe b;
+    private boolean c;
+
+    public PacketPlayInAutoRecipe() {}
+
+    public void a(PacketDataSerializer packetdataserializer) throws IOException {
+        this.a = packetdataserializer.readByte();
+        //OilSpigot use getById()
+        this.b = CraftingManager.getById(packetdataserializer.g());
+        this.c = packetdataserializer.readBoolean();
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) throws IOException {
+        packetdataserializer.writeByte(this.a);
+        //OilSpigot recipes now store their id no need to look it up
+        packetdataserializer.d(this.b.getGlobalId());
+        packetdataserializer.writeBoolean(this.c);
+    }
+
+    public void a(PacketListenerPlayIn packetlistenerplayin) {
+        packetlistenerplayin.a(this);
+    }
+
+    public int a() {
+        return this.a;
+    }
+
+    public IRecipe b() {
+        return this.b;
+    }
+
+    public boolean c() {
+        return this.c;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayInRecipeDisplayed.java b/src/main/java/net/minecraft/server/PacketPlayInRecipeDisplayed.java
new file mode 100644
index 00000000..461e7766
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayInRecipeDisplayed.java
@@ -0,0 +1,69 @@
+package net.minecraft.server;
+
+import java.io.IOException;
+
+public class PacketPlayInRecipeDisplayed implements Packet<PacketListenerPlayIn> {
+
+    private Status a;
+    private IRecipe b;
+    private boolean c;
+    private boolean d;
+
+    public PacketPlayInRecipeDisplayed() {}
+
+    public PacketPlayInRecipeDisplayed(IRecipe irecipe) {
+        this.a = Status.SHOWN;
+        this.b = irecipe;
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) throws IOException {
+        this.a = (Status) packetdataserializer.a(Status.class);
+        if (this.a == Status.SHOWN) {
+            //OilSpigot use getById
+            this.b = CraftingManager.getById(packetdataserializer.readInt());
+        } else if (this.a == Status.SETTINGS) {
+            this.c = packetdataserializer.readBoolean();
+            this.d = packetdataserializer.readBoolean();
+        }
+
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) throws IOException {
+        packetdataserializer.a((Enum) this.a);
+        if (this.a == Status.SHOWN) {
+            //OilSpigot id is saved in recipe - no need to look it up
+            packetdataserializer.writeInt(this.b.getGlobalId());
+        } else if (this.a == Status.SETTINGS) {
+            packetdataserializer.writeBoolean(this.c);
+            packetdataserializer.writeBoolean(this.d);
+        }
+
+    }
+
+    public void a(PacketListenerPlayIn packetlistenerplayin) {
+        packetlistenerplayin.a(this);
+    }
+
+    public Status a() {
+        return this.a;
+    }
+
+    public IRecipe b() {
+        return this.b;
+    }
+
+    public boolean c() {
+        return this.c;
+    }
+
+    public boolean d() {
+        return this.d;
+    }
+
+    public static enum Status {
+
+        SHOWN, SETTINGS;
+
+        private Status() {}
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutAutoRecipe.java b/src/main/java/net/minecraft/server/PacketPlayOutAutoRecipe.java
new file mode 100644
index 00000000..d751edbd
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayOutAutoRecipe.java
@@ -0,0 +1,32 @@
+package net.minecraft.server;
+
+import java.io.IOException;
+
+public class PacketPlayOutAutoRecipe implements Packet<PacketListenerPlayOut> {
+
+    private int a;
+    private IRecipe b;
+
+    public PacketPlayOutAutoRecipe() {}
+
+    public PacketPlayOutAutoRecipe(int i, IRecipe irecipe) {
+        this.a = i;
+        this.b = irecipe;
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) throws IOException {
+        this.a = packetdataserializer.readByte();
+        //OilSpigot use getById
+        this.b = CraftingManager.getById(packetdataserializer.g());
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) throws IOException {
+        packetdataserializer.writeByte(this.a);
+        //OilSpigot recipes store their id themselves now
+        packetdataserializer.d(this.b.getGlobalId());
+    }
+
+    public void a(PacketListenerPlayOut packetlistenerplayout) {
+        packetlistenerplayout.a(this);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutRecipes.java b/src/main/java/net/minecraft/server/PacketPlayOutRecipes.java
new file mode 100644
index 00000000..1f7f7e07
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayOutRecipes.java
@@ -0,0 +1,92 @@
+package net.minecraft.server;
+
+import com.google.common.collect.Lists;
+import java.io.IOException;
+import java.util.Iterator;
+import java.util.List;
+
+public class PacketPlayOutRecipes implements Packet<PacketListenerPlayOut> {
+
+    private Action a;
+    private List<IRecipe> b;
+    private List<IRecipe> c;
+    private boolean d;
+    private boolean e;
+
+    public PacketPlayOutRecipes() {}
+
+    public PacketPlayOutRecipes(Action packetplayoutrecipes_action, List<IRecipe> list, List<IRecipe> list1, boolean flag, boolean flag1) {
+        this.a = packetplayoutrecipes_action;
+        this.b = list;
+        this.c = list1;
+        this.d = flag;
+        this.e = flag1;
+    }
+
+    public void a(PacketListenerPlayOut packetlistenerplayout) {
+        packetlistenerplayout.a(this);
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) throws IOException {
+        this.a = (Action) packetdataserializer.a(Action.class);
+        this.d = packetdataserializer.readBoolean();
+        this.e = packetdataserializer.readBoolean();
+        int i = packetdataserializer.g();
+
+        this.b = Lists.newArrayList();
+
+        int j;
+
+
+        for (j = 0; j < i; ++j) {
+            //OilSpigot use getById
+            this.b.add(CraftingManager.getById(packetdataserializer.g()));
+        }
+
+        if (this.a == Action.INIT) {
+            i = packetdataserializer.g();
+            this.c = Lists.newArrayList();
+
+            for (j = 0; j < i; ++j) {
+                //OilSpigot use getById
+                this.c.add(CraftingManager.getById(packetdataserializer.g()));
+            }
+        }
+
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) throws IOException {
+        packetdataserializer.a((Enum) this.a);
+        packetdataserializer.writeBoolean(this.d);
+        packetdataserializer.writeBoolean(this.e);
+        packetdataserializer.d(this.b.size());
+        Iterator iterator = this.b.iterator();
+
+        IRecipe irecipe;
+
+        while (iterator.hasNext()) {
+            irecipe = (IRecipe) iterator.next();
+            //OilSpigot id is saved in recipe - no need to look it up
+            packetdataserializer.d(irecipe.getGlobalId());
+        }
+
+        if (this.a == Action.INIT) {
+            packetdataserializer.d(this.c.size());
+            iterator = this.c.iterator();
+
+            while (iterator.hasNext()) {
+                irecipe = (IRecipe) iterator.next();
+                //OilSpigot id is saved in recipe - no need to look it up
+                packetdataserializer.d(irecipe.getGlobalId());
+            }
+        }
+
+    }
+
+    public static enum Action {
+
+        INIT, ADD, REMOVE;
+
+        private Action() {}
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PlayerConnection.java b/src/main/java/net/minecraft/server/PlayerConnection.java
index de62c3b7..727f18cc 100644
--- a/src/main/java/net/minecraft/server/PlayerConnection.java
+++ b/src/main/java/net/minecraft/server/PlayerConnection.java
@@ -62,6 +62,11 @@ import com.destroystokyo.paper.event.player.PlayerJumpEvent; // Paper
 import co.aikar.timings.MinecraftTimings; // Paper
 // CraftBukkit end
 
+//OilSpigot start
+import org.bukkit.craftbukkit.inventory.CraftInventory;
+import org.oilmod.spigot.inventory.FilteredInventory;
+//OilSpigot end
+
 public class PlayerConnection implements PacketListenerPlayIn, ITickable {
 
     private static final Logger LOGGER = LogManager.getLogger();
@@ -854,7 +859,8 @@ public class PlayerConnection implements PacketListenerPlayIn, ITickable {
                 ItemStack itemstack = this.player.b(EnumHand.OFF_HAND);
 
                 // CraftBukkit start
-                PlayerSwapHandItemsEvent swapItemsEvent = new PlayerSwapHandItemsEvent(getPlayer(), CraftItemStack.asBukkitCopy(itemstack), CraftItemStack.asBukkitCopy(this.player.b(EnumHand.MAIN_HAND)));
+                //OilSpigot - use asCraftMirror
+                PlayerSwapHandItemsEvent swapItemsEvent = new PlayerSwapHandItemsEvent(getPlayer(), CraftItemStack.asCraftMirror(itemstack), CraftItemStack.asCraftMirror(this.player.b(EnumHand.MAIN_HAND)));
                 this.server.getPluginManager().callEvent(swapItemsEvent);
                 if (swapItemsEvent.isCancelled()) {
                     return;
@@ -1830,7 +1836,12 @@ public class PlayerConnection implements PacketListenerPlayIn, ITickable {
                                             if (clickedItem.doMaterialsMatch(cursor) && ItemStack.equals(clickedItem, cursor)) {
                                                 int toPlace = packetplayinwindowclick.c() == 0 ? cursor.getCount() : 1;
                                                 toPlace = Math.min(toPlace, clickedItem.getMaxStackSize() - clickedItem.getCount());
-                                                toPlace = Math.min(toPlace, slot.inventory.getMaxStackSize() - clickedItem.getCount());
+                                                //OilSpigot start
+                                                toPlace = Math.min(toPlace, slot.getMaxStackSize() - clickedItem.getCount()); //TODO: check if this leads to desync
+
+                                                //TODO: why double allocation
+                                                toPlace = Math.min(toPlace, slot.getInventory().getMaxStackSize() - clickedItem.getCount()); //OilSpigot - changed .inventory to .getInventory()
+                                                //OilSpigot end
                                                 if (toPlace == 1) {
                                                     action = InventoryAction.PLACE_ONE;
                                                 } else if (toPlace == cursor.getCount()) {
@@ -1882,7 +1893,8 @@ public class PlayerConnection implements PacketListenerPlayIn, ITickable {
                             Slot clickedSlot = this.player.activeContainer.getSlot(packetplayinwindowclick.b());
                             if (clickedSlot.isAllowed(player)) {
                                 ItemStack hotbar = this.player.inventory.getItem(packetplayinwindowclick.c());
-                                boolean canCleanSwap = hotbar.isEmpty() || (clickedSlot.inventory == player.inventory && clickedSlot.isAllowed(hotbar)); // the slot will accept the hotbar item
+                                //OilSpigot - changed .inventory to .getInventory()
+                                boolean canCleanSwap = hotbar.isEmpty() || (clickedSlot.getInventory() == player.inventory && clickedSlot.isAllowed(hotbar)); // the slot will accept the hotbar item
                                 if (clickedSlot.hasItem()) {
                                     if (canCleanSwap) {
                                         action = InventoryAction.HOTBAR_SWAP;
@@ -1985,6 +1997,21 @@ public class PlayerConnection implements PacketListenerPlayIn, ITickable {
 
                     event.setCancelled(cancelled);
                     Container oldContainer = this.player.activeContainer; // SPIGOT-1224
+
+                    //OilSpigot start - TODO:what is this doing?
+                    if (!event.isCancelled() && ((action == InventoryAction.MOVE_TO_OTHER_INVENTORY) || (event.getInventory()==event.getClickedInventory())) && inventory.getTopInventory() != null && inventory.getTopInventory() instanceof CraftInventory) {
+                        IInventory nmsInventory = ((CraftInventory)inventory.getTopInventory()).getInventory();
+                        if (nmsInventory instanceof FilteredInventory) {
+                            FilteredInventory filteredInventory = (FilteredInventory)nmsInventory;
+                            ItemStack itemStack2 = CraftItemStack.asNMSCopy(event.getCursor());
+                            ItemStack itemStack3 = packetplayinwindowclick.e();
+                            if ((itemStack2!= null && !itemStack2.isEmpty() && !filteredInventory.itemstackAddable(itemStack2)) || (itemStack3!= null && !itemStack3.isEmpty() && !filteredInventory.itemstackAddable(itemStack3))) {
+                                event.setCancelled(true);
+                            }
+                        }
+                    }
+                    //OilSpigot end
+
                     server.getPluginManager().callEvent(event);
                     if (this.player.activeContainer != oldContainer) {
                         return;
@@ -2128,7 +2155,7 @@ public class PlayerConnection implements PacketListenerPlayIn, ITickable {
             if (flag || (flag1 && !ItemStack.matches(this.player.defaultContainer.getSlot(packetplayinsetcreativeslot.a()).getItem(), packetplayinsetcreativeslot.getItemStack()))) { // Insist on valid slot
                 // CraftBukkit start - Call click event
                 InventoryView inventory = this.player.defaultContainer.getBukkitView();
-                org.bukkit.inventory.ItemStack item = CraftItemStack.asBukkitCopy(packetplayinsetcreativeslot.getItemStack());
+                org.bukkit.inventory.ItemStack item = CraftItemStack.asCraftMirror(packetplayinsetcreativeslot.getItemStack()); //OilSpigot - use asCraftMirror
 
                 SlotType type = SlotType.QUICKBAR;
                 if (flag) {
@@ -2709,7 +2736,25 @@ public class PlayerConnection implements PacketListenerPlayIn, ITickable {
                         } catch (Exception exception7) {
                             IllegalPacketEvent.process(player.getBukkitEntity(), "InvalidPickItem", "Invalid PickItem", exception7); // Paper
                         }
-                    }
+
+                                //OilSpigot start
+                        //TODO: this is supposed to eventually allow client support. currently removed
+                           /* } else if ("OILMOD|INIT".equals(packetplayincustompayload.a())) {
+                                OilConnection c = ConnectionManager.INSTANCE.registerConnection(getPlayer().getHandle());
+                                if (c != null) {
+                                    getPlayer().sendMessage("aThis server is using the oilmod!");
+                                    de.sirati97.bex_proto.v2.Packet p = new de.sirati97.bex_proto.v2.Packet(ConnectionManager.TEST_PACKET, "TEST PAYLOAD MUHAHAHA ");
+                                    p.sendTo(c);
+                                }
+                                return;
+                            } else if ("OILMOD|MAIN".equals(packetplayincustompayload.a())) {
+                                byte[] data = new byte[packetplayincustompayload.b().readableBytes()];
+                                packetplayincustompayload.b().readBytes(data);
+                                ConnectionManager.INSTANCE.executeInput(getPlayer().getHandle(), data);
+                                return;
+                            */}
+                            //OilSpigot end
+
                     // CraftBukkit start
                     else if (packetplayincustompayload.a().equals("REGISTER")) {
                         try {
diff --git a/src/main/java/net/minecraft/server/PlayerInteractManager.java b/src/main/java/net/minecraft/server/PlayerInteractManager.java
index 3d867982..6baf4eb9 100644
--- a/src/main/java/net/minecraft/server/PlayerInteractManager.java
+++ b/src/main/java/net/minecraft/server/PlayerInteractManager.java
@@ -7,6 +7,8 @@ import org.bukkit.craftbukkit.event.CraftEventFactory;
 import org.bukkit.event.Event;
 import org.bukkit.event.block.Action;
 import org.bukkit.event.player.PlayerInteractEvent;
+import org.oilmod.spigot.OilMain;
+import org.oilmod.spigot.items.RealItem;
 // CraftBukkit end
 
 public class PlayerInteractManager {
@@ -22,6 +24,8 @@ public class PlayerInteractManager {
     private BlockPosition i;
     private int j;
     private int k;
+    //OilSpigot
+    private boolean awaitNextTry;
 
     public PlayerInteractManager(World world) {
         this.gamemode = EnumGamemode.NOT_SET;
@@ -64,10 +68,23 @@ public class PlayerInteractManager {
         float f;
         int i;
 
+        //OilSpigot start - players need to swing their arm to break blocks (fixes slower tool than vanilla bug, no swing hack)
+        if ((h || d) && MinecraftServer.currentTick-this.player.lastSwing > 2) { //allow for 3 ticks lag
+            System.out.println("Cancelled item breaking because of no swing for " + (MinecraftServer.currentTick-this.player.lastSwing) + " ticks");
+            e();
+            return;
+        }
+
+        boolean isModItem = this.player.getItemInMainHand().getItem() instanceof RealItem;
+        //OilSpigot end
+
         if (this.h) {
+
             int j = this.currentTick - this.j;
             IBlockData iblockdata = this.world.getType(this.i);
 
+
+
             if (iblockdata.getMaterial() == Material.AIR) {
                 this.h = false;
             } else {
@@ -84,6 +101,7 @@ public class PlayerInteractManager {
                 }
             }
         } else if (this.d) {
+
             IBlockData iblockdata1 = this.world.getType(this.f);
 
             if (iblockdata1.getMaterial() == Material.AIR) {
@@ -100,13 +118,44 @@ public class PlayerInteractManager {
                     this.k = i;
                 }
             }
+
+            //OilSpigot start - break block even if client didn't say so in case mod item is faster than client expects
+            IBlockData iblockdata = this.world.getType(this.f);
+            float progress = iblockdata.a((EntityHuman) this.player, this.player.world, this.f) * (float) (this.currentTick - this.lastDigTick + 1);
+            if (isModItem &&  progress >= 1.0F) {
+                breakBlock(this.f);
+            }
+            //OilSpigot end
         }
 
     }
 
     public void a(BlockPosition blockposition, EnumDirection enumdirection) {
+
+        //OilSpigot start - if the modded item is slower than the client expects it will try breaking the block multiple times, we need to catch this
+        boolean isModItem = this.player.getItemInMainHand().getItem() instanceof RealItem;
+        if (awaitNextTry) {
+            awaitNextTry = false;
+            //isModItem here is not really needed and will actually behave unexpectedly for a oilmod considerate client. For vanilla it looks smoother this way tho. (also simplifies all custom race conditions here as we don't need the worry about a block partially broken by a modded item and partially by a vanilla item.)
+            if (isModItem && blockposition.equals(this.f) && MinecraftServer.currentTick-this.player.lastSwing <= 2) {
+                System.out.println("next try gap: " + (MinecraftServer.currentTick-this.player.lastSwing) );
+                a(); //call normal progress function
+                return;
+            } else {
+                e(); //reset client
+            }
+        }
+        //OilSpigot end
+
+
         // CraftBukkit start
         PlayerInteractEvent event = CraftEventFactory.callPlayerInteractEvent(this.player, Action.LEFT_CLICK_BLOCK, blockposition, enumdirection, this.player.inventory.getItemInHand(), EnumHand.MAIN_HAND);
+
+        //OilSpigot start - allow item to react to LEFT_CLICK_BLOCK
+        //TODO
+
+        //OilSpigot end
+
         if (event.isCancelled()) {
             // Let the client know the block still exists
             ((EntityPlayer) this.player).playerConnection.sendPacket(new PacketPlayOutBlockChange(this.world, blockposition));
@@ -171,7 +220,7 @@ public class PlayerInteractManager {
 
             if (event.useItemInHand() == Event.Result.DENY) {
                 // If we 'insta destroyed' then the client needs to be informed.
-                if (f > 1.0f) {
+                if (f > 1.0f) { //OilSpigpt TODO: ensure that moditems dont create a desync
                     ((EntityPlayer) this.player).playerConnection.sendPacket(new PacketPlayOutBlockChange(this.world, blockposition));
                 }
                 return;
@@ -215,11 +264,21 @@ public class PlayerInteractManager {
             if (iblockdata.getMaterial() != Material.AIR) {
                 float f = iblockdata.a((EntityHuman) this.player, this.player.world, blockposition) * (float) (i + 1);
 
-                if (f >= 0.7F) {
+                //OilSpigot start - is it a mod item
+                boolean isModItem = this.player.getItemInMainHand().getItem() instanceof RealItem;
+                //OilSpigot end
+
+                //OilSpigot: That's where the 30% speed hack comes from. We are stricter with modItems as they probably have a speed the client does not expect
+                if (f >= (isModItem?0.95F:0.7F)) {
                     this.d = false;
                     this.world.c(this.player.getId(), blockposition, -1);
                     this.breakBlock(blockposition);
-                } else if (!this.h) {
+                    //OilSpigot moditems can take longer so just ignore that the client thinks is done and await its next try
+                } else if (isModItem) {
+                    this.h = false;
+                    this.d = true; //just making sure
+                    this.awaitNextTry = true;
+                } else if (!isModItem && !this.h) {
                     this.d = false;
                     this.h = true;
                     this.i = blockposition;
@@ -236,6 +295,10 @@ public class PlayerInteractManager {
 
     public void e() {
         this.d = false;
+        //OilSpigot start
+        this.h = false;
+        this.awaitNextTry = false;
+        //OilSpigot end
         this.world.c(this.player.getId(), this.f, -1);
     }
 
diff --git a/src/main/java/net/minecraft/server/PlayerInventory.java b/src/main/java/net/minecraft/server/PlayerInventory.java
index 84f59b75..5ecb8f6e 100644
--- a/src/main/java/net/minecraft/server/PlayerInventory.java
+++ b/src/main/java/net/minecraft/server/PlayerInventory.java
@@ -236,7 +236,9 @@ public class PlayerInventory implements IInventory {
         ItemStack itemstack1 = this.getItem(i);
 
         if (itemstack1.isEmpty()) {
-            itemstack1 = new ItemStack(item, 0, itemstack.getData());
+            //OilSpigot use cloneAndSubtract instead of constructor
+            itemstack1 = itemstack.cloneAndSubtract(0);
+            itemstack1.setDegenerate(false); //yes this is very weird code where we have non degenerate stacks of size 0. probably a bug that never caused any problem nms usually uses the constructor
             if (itemstack.hasTag()) {
                 itemstack1.setTag(itemstack.getTag().g());
             }
@@ -509,7 +511,8 @@ public class PlayerInventory implements IInventory {
         for (int i = 0; i < nbttaglist.size(); ++i) {
             NBTTagCompound nbttagcompound = nbttaglist.get(i);
             int j = nbttagcompound.getByte("Slot") & 255;
-            ItemStack itemstack = new ItemStack(nbttagcompound);
+            //OilSpigot use factory method
+            ItemStack itemstack = ItemStack.createStack(nbttagcompound);
 
             if (!itemstack.isEmpty()) {
                 if (j >= 0 && j < this.items.size()) {
diff --git a/src/main/java/net/minecraft/server/PlayerList.java b/src/main/java/net/minecraft/server/PlayerList.java
index 44ced604..e65490b1 100644
--- a/src/main/java/net/minecraft/server/PlayerList.java
+++ b/src/main/java/net/minecraft/server/PlayerList.java
@@ -44,6 +44,10 @@ import org.bukkit.util.Vector;
 import org.spigotmc.event.player.PlayerSpawnLocationEvent;
 // CraftBukkit end
 
+//OilSpigot start
+import org.oilmod.spigot.OilMain;
+//OilSpigot end
+
 public abstract class PlayerList {
 
     public static final File a = new File("banned-players.json");
@@ -411,6 +415,8 @@ public abstract class PlayerList {
             this.a(entityplayer, (WorldServer) null);
         }
         // CraftBukkit end
+
+        OilMain.sendUnregisteredPluginMessage(entityplayer, "INIT", new byte[]{}); //OilSpigot - Tell client that we are running oilmod
     }
 
     public void d(EntityPlayer entityplayer) {
@@ -422,6 +428,8 @@ public abstract class PlayerList {
 
         entityplayer.b(StatisticList.f);
 
+        //ConnectionManager.INSTANCE.unregisterConnection(entityplayer); //OilSpigot close open connections //TODO client support
+
         // CraftBukkit start - Quitting must be before we do final save of data, in case plugins need to modify it
         org.bukkit.craftbukkit.event.CraftEventFactory.handleInventoryCloseEvent(entityplayer, org.bukkit.event.inventory.InventoryCloseEvent.Reason.DISCONNECT); // Paper
 
diff --git a/src/main/java/net/minecraft/server/RecipeArmorDye.java b/src/main/java/net/minecraft/server/RecipeArmorDye.java
index 123002ec..55d60afc 100644
--- a/src/main/java/net/minecraft/server/RecipeArmorDye.java
+++ b/src/main/java/net/minecraft/server/RecipeArmorDye.java
@@ -3,6 +3,11 @@ package net.minecraft.server;
 import com.google.common.collect.Lists;
 import java.util.ArrayList;
 
+//OilSpigot start
+import org.oilmod.spigot.items.itemstackimpl.crafting.help.CHView;
+import org.oilmod.spigot.items.itemstackimpl.crafting.help.VanillaArmorDyeChView;
+//OilSpigot end
+
 public class RecipeArmorDye extends ShapelessRecipes implements IRecipe { // CraftBukkit - added extends
 
     // CraftBukkit start - Delegate to new parent class with bogus info
@@ -136,4 +141,12 @@ public class RecipeArmorDye extends ShapelessRecipes implements IRecipe { // Cra
     public boolean c() {
         return true;
     }
+
+
+            //OilSpigot start
+            @Override
+            protected CHView createCraftingHelp() {
+                return new VanillaArmorDyeChView();
+            }
+            //OilSpigot end
 }
diff --git a/src/main/java/net/minecraft/server/RecipeBook.java b/src/main/java/net/minecraft/server/RecipeBook.java
new file mode 100644
index 00000000..b3cc71fe
--- /dev/null
+++ b/src/main/java/net/minecraft/server/RecipeBook.java
@@ -0,0 +1,61 @@
+package net.minecraft.server;
+
+import java.util.BitSet;
+import javax.annotation.Nullable;
+
+//OilSpigot KEEPSYNC
+public class RecipeBook {
+
+    protected final BitSet a = new BitSet();
+    protected final BitSet b = new BitSet();
+    protected boolean c;
+    protected boolean d;
+
+    public RecipeBook() {}
+
+    public void a(RecipeBook recipebook) {
+        this.a.clear();
+        this.b.clear();
+        this.a.or(recipebook.a);
+        this.b.or(recipebook.b);
+    }
+
+    public void a(IRecipe irecipe) {
+        if (!irecipe.c()) {
+            this.a.set(d(irecipe));
+        }
+
+    }
+
+    public boolean b(@Nullable IRecipe irecipe) {
+        return this.a.get(d(irecipe));
+    }
+
+    public void c(IRecipe irecipe) {
+        int i = d(irecipe);
+
+        this.a.clear(i);
+        this.b.clear(i);
+    }
+
+    protected static int d(@Nullable IRecipe irecipe) {
+        //OilSpigot use vanilla instance only for now //TODO: find solution to keep the ids unique while only offering some
+        return CraftingManager.getInstance().getRecipeId(irecipe);
+    }
+
+    public void f(IRecipe irecipe) {
+        this.b.clear(d(irecipe));
+    }
+
+    public void g(IRecipe irecipe) {
+        this.b.set(d(irecipe));
+    }
+
+    public void a(boolean flag) {
+        this.c = flag;
+    }
+
+    public void b(boolean flag) {
+        this.d = flag;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/RecipeBookClone.java b/src/main/java/net/minecraft/server/RecipeBookClone.java
index a2e62eb7..0221ce31 100644
--- a/src/main/java/net/minecraft/server/RecipeBookClone.java
+++ b/src/main/java/net/minecraft/server/RecipeBookClone.java
@@ -1,5 +1,11 @@
 package net.minecraft.server;
 
+//OilSpigot start
+import net.minecraft.server.oilmod.IInventoryCrafting;
+import org.oilmod.spigot.items.itemstackimpl.crafting.help.CHView;
+import org.oilmod.spigot.items.itemstackimpl.internal.ModItemStack;
+//OilSpigot end
+
 public class RecipeBookClone extends ShapelessRecipes implements IRecipe { // CraftBukkit - added extends
 
     public RecipeBookClone() {
@@ -7,7 +13,7 @@ public class RecipeBookClone extends ShapelessRecipes implements IRecipe { // Cr
     }
     // CraftBukkit end
 
-    public boolean a(InventoryCrafting inventorycrafting, World world) {
+    public boolean a(IInventoryCrafting inventorycrafting, World world) {//OilSpigot changed from InventoryCrafting to IInventoryCrafting
         int i = 0;
         ItemStack itemstack = ItemStack.a;
 
@@ -15,6 +21,9 @@ public class RecipeBookClone extends ShapelessRecipes implements IRecipe { // Cr
             ItemStack itemstack1 = inventorycrafting.getItem(j);
 
             if (!itemstack1.isEmpty()) {
+                if (itemstack instanceof ModItemStack) { //OilSpigot disallow normal crafting with custom items
+                    return false;
+                }
                 if (itemstack1.getItem() == Items.WRITTEN_BOOK) {
                     if (!itemstack.isEmpty()) {
                         return false;
@@ -34,7 +43,7 @@ public class RecipeBookClone extends ShapelessRecipes implements IRecipe { // Cr
         return !itemstack.isEmpty() && itemstack.hasTag() && i > 0;
     }
 
-    public ItemStack craftItem(InventoryCrafting inventorycrafting) {
+    public ItemStack craftItem(IInventoryCrafting inventorycrafting) { //OilSpigot changed from InventoryCrafting to IInventoryCrafting
         int i = 0;
         ItemStack itemstack = ItemStack.a;
 
@@ -77,7 +86,7 @@ public class RecipeBookClone extends ShapelessRecipes implements IRecipe { // Cr
         return ItemStack.a;
     }
 
-    public NonNullList<ItemStack> b(InventoryCrafting inventorycrafting) {
+    public NonNullList<ItemStack> b(IInventoryCrafting inventorycrafting) { //OilSpigot changed from InventoryCrafting to IInventoryCrafting
         NonNullList nonnulllist = NonNullList.a(inventorycrafting.getSize(), ItemStack.a);
 
         for (int i = 0; i < nonnulllist.size(); ++i) {
@@ -98,4 +107,11 @@ public class RecipeBookClone extends ShapelessRecipes implements IRecipe { // Cr
     public boolean c() {
         return true;
     }
+
+    //OilSpigot start
+    @Override
+    protected CHView createCraftingHelp() {
+        return null;
+    }
+    //OilSpigot end
 }
diff --git a/src/main/java/net/minecraft/server/RecipeBookServer.java b/src/main/java/net/minecraft/server/RecipeBookServer.java
index f65e74eb..67c5d001 100644
--- a/src/main/java/net/minecraft/server/RecipeBookServer.java
+++ b/src/main/java/net/minecraft/server/RecipeBookServer.java
@@ -63,11 +63,12 @@ public class RecipeBookServer extends RecipeBook {
         while (iterator.hasNext()) {
             IRecipe irecipe = (IRecipe) iterator.next();
 
-            // Paper start - ignore missing recipes
-            MinecraftKey key = CraftingManager.recipes.b(irecipe);
-            if (key == null) continue;
-            nbttaglist.add(new NBTTagString(key.toString()));
+            // Paper start - ignore missing recipes //OilyPaper changed
+            if (irecipe.getKey() == null) continue;
             // Paper end
+
+            //OilSpigot recipes now hold their key
+            nbttaglist.add(new NBTTagString(irecipe.getKey().toString()));
         }
 
         nbttagcompound.set("recipes", nbttaglist);
@@ -75,13 +76,14 @@ public class RecipeBookServer extends RecipeBook {
         Iterator iterator1 = this.e().iterator();
 
         while (iterator1.hasNext()) {
-            // Paper start - ignore missing recipes
-            IRecipe irecipe = (IRecipe) iterator1.next();
+            IRecipe irecipe1 = (IRecipe) iterator1.next();
 
-            MinecraftKey key = CraftingManager.recipes.b(irecipe);
-            if (key == null) continue;
-            nbttaglist1.add(new NBTTagString(key.toString()));
+            // Paper start - ignore missing recipes //OilyPaper changed
+            if (irecipe.getKey() == null) continue;
             // Paper end
+
+            //OilSpigot recipes now hold their key
+            nbttaglist1.add(new NBTTagString(irecipe1.getKey().toString()));
         }
 
         nbttagcompound.set("toBeDisplayed", nbttaglist1);
@@ -95,7 +97,8 @@ public class RecipeBookServer extends RecipeBook {
 
         for (int i = 0; i < nbttaglist.size(); ++i) {
             MinecraftKey minecraftkey = new MinecraftKey(nbttaglist.getString(i));
-            IRecipe irecipe = CraftingManager.a(minecraftkey);
+            //OilSpigot use getByKey
+            IRecipe irecipe = CraftingManager.getByKey(minecraftkey);
 
             if (irecipe == null) {
                 RecipeBookServer.e.info("Tried to load unrecognized recipe: {} removed now.", minecraftkey);
@@ -108,7 +111,8 @@ public class RecipeBookServer extends RecipeBook {
 
         for (int j = 0; j < nbttaglist1.size(); ++j) {
             MinecraftKey minecraftkey1 = new MinecraftKey(nbttaglist1.getString(j));
-            IRecipe irecipe1 = CraftingManager.a(minecraftkey1);
+            //OilSpigot use getByKey
+            IRecipe irecipe1 = CraftingManager.getByKey(minecraftkey1);
 
             if (irecipe1 == null) {
                 RecipeBookServer.e.info("Tried to load unrecognized recipe: {} removed now.", minecraftkey1);
@@ -123,7 +127,8 @@ public class RecipeBookServer extends RecipeBook {
         ArrayList arraylist = Lists.newArrayList();
 
         for (int i = this.a.nextSetBit(0); i >= 0; i = this.a.nextSetBit(i + 1)) {
-            arraylist.add(CraftingManager.recipes.getId(i));
+            //OilSpigot use getById
+            arraylist.add(CraftingManager.getById(i));
         }
 
         return arraylist;
@@ -133,7 +138,8 @@ public class RecipeBookServer extends RecipeBook {
         ArrayList arraylist = Lists.newArrayList();
 
         for (int i = this.b.nextSetBit(0); i >= 0; i = this.b.nextSetBit(i + 1)) {
-            arraylist.add(CraftingManager.recipes.getId(i));
+            //OilSpigot use getById
+            arraylist.add(CraftingManager.getById(i));
         }
 
         return arraylist;
diff --git a/src/main/java/net/minecraft/server/RecipeFireworks.java b/src/main/java/net/minecraft/server/RecipeFireworks.java
index 859900d5..fb9d13be 100644
--- a/src/main/java/net/minecraft/server/RecipeFireworks.java
+++ b/src/main/java/net/minecraft/server/RecipeFireworks.java
@@ -1,6 +1,8 @@
 package net.minecraft.server;
 
 import com.google.common.collect.Lists;
+import net.minecraft.server.oilmod.IInventoryCrafting;
+
 import java.util.ArrayList;
 
 public class RecipeFireworks extends ShapelessRecipes implements IRecipe { // CraftBukkit - added extends
@@ -14,7 +16,7 @@ public class RecipeFireworks extends ShapelessRecipes implements IRecipe { // Cr
     }
     // CraftBukkit end
 
-    public boolean a(InventoryCrafting inventorycrafting, World world) {
+    public boolean a(IInventoryCrafting inventorycrafting, World world) { //OilSpigot changed from InventoryCrafting to IInventoryCrafting
         this.a = ItemStack.a;
         int i = 0;
         int j = 0;
@@ -165,7 +167,7 @@ public class RecipeFireworks extends ShapelessRecipes implements IRecipe { // Cr
         }
     }
 
-    public ItemStack craftItem(InventoryCrafting inventorycrafting) {
+    public ItemStack craftItem(IInventoryCrafting inventorycrafting) {  //OilSpigot changed from InventoryCrafting to IInventoryCrafting
         return this.a.cloneItemStack();
     }
 
@@ -173,7 +175,7 @@ public class RecipeFireworks extends ShapelessRecipes implements IRecipe { // Cr
         return this.a;
     }
 
-    public NonNullList<ItemStack> b(InventoryCrafting inventorycrafting) {
+    public NonNullList<ItemStack> b(IInventoryCrafting inventorycrafting) {  //OilSpigot changed from InventoryCrafting to IInventoryCrafting
         NonNullList nonnulllist = NonNullList.a(inventorycrafting.getSize(), ItemStack.a);
 
         for (int i = 0; i < nonnulllist.size(); ++i) {
diff --git a/src/main/java/net/minecraft/server/RecipeItemStack.java b/src/main/java/net/minecraft/server/RecipeItemStack.java
new file mode 100644
index 00000000..21450411
--- /dev/null
+++ b/src/main/java/net/minecraft/server/RecipeItemStack.java
@@ -0,0 +1,111 @@
+package net.minecraft.server;
+
+import com.google.common.base.Predicate;
+import org.oilmod.spigot.items.itemstackimpl.internal.ModItemStack;
+import it.unimi.dsi.fastutil.ints.IntArrayList;
+import it.unimi.dsi.fastutil.ints.IntComparators;
+import it.unimi.dsi.fastutil.ints.IntList;
+import javax.annotation.Nullable;
+
+//OilSpigot - KEEPSYNC
+public class RecipeItemStack implements Predicate<ItemStack> {
+
+    public static final RecipeItemStack a = new RecipeItemStack(new ItemStack[0], null) {
+        public boolean a(@Nullable ItemStack itemstack) {
+            return itemstack.isEmpty();
+        }
+
+    };
+    public final ItemStack[] choices;
+    private IntList c;
+
+    private RecipeItemStack(ItemStack... aitemstack) {
+        this.choices = aitemstack;
+    }
+
+    public boolean a(@Nullable ItemStack itemstack) {
+        if (itemstack == null) {
+            return false;
+        } else {
+            ItemStack[] aitemstack = this.choices;
+            int i = aitemstack.length;
+
+            for (int j = 0; j < i; ++j) {
+                ItemStack itemstack1 = aitemstack[j];
+                //OilSpigot disallow normal crafting with custom items
+                if (itemstack instanceof ModItemStack && (!(itemstack1 instanceof ModItemStack) || !ItemStack.matchesIgnoresCount(itemstack1, itemstack))) {
+                    return false;
+                }
+
+                if (itemstack1.getItem() == itemstack.getItem()) {
+                    int k = itemstack1.getData();
+
+                    if (k == 32767 || k == itemstack.getData()) {
+                        return true;
+                    }
+                }
+            }
+
+            return false;
+        }
+    }
+
+    public IntList b() {
+        if (this.c == null) {
+            this.c = new IntArrayList(this.choices.length);
+            ItemStack[] aitemstack = this.choices;
+            int i = aitemstack.length;
+
+            for (int j = 0; j < i; ++j) {
+                ItemStack itemstack = aitemstack[j];
+
+                this.c.add(AutoRecipeStackManager.b(itemstack));
+            }
+
+            this.c.sort(IntComparators.NATURAL_COMPARATOR);
+        }
+
+        return this.c;
+    }
+
+    public static RecipeItemStack a(Item item) {
+        return a(new ItemStack[] { new ItemStack(item, 1, 32767)});
+    }
+
+    public static RecipeItemStack a(Item... aitem) {
+        ItemStack[] aitemstack = new ItemStack[aitem.length];
+
+        for (int i = 0; i < aitem.length; ++i) {
+            aitemstack[i] = new ItemStack(aitem[i]);
+        }
+
+        return a(aitemstack);
+    }
+
+    public static RecipeItemStack a(ItemStack... aitemstack) {
+        if (aitemstack.length > 0) {
+            ItemStack[] aitemstack1 = aitemstack;
+            int i = aitemstack.length;
+
+            for (int j = 0; j < i; ++j) {
+                ItemStack itemstack = aitemstack1[j];
+
+                if (!itemstack.isEmpty()) {
+                    return new RecipeItemStack(aitemstack);
+                }
+            }
+        }
+
+        return RecipeItemStack.a;
+    }
+
+
+    RecipeItemStack(ItemStack[] aitemstack, Object object) {
+        this(aitemstack);
+    }
+
+    @Override
+    public boolean apply(@Nullable ItemStack itemStack) {
+        return this.a(itemStack);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/RecipeMapClone.java b/src/main/java/net/minecraft/server/RecipeMapClone.java
index 0e68d9b0..db6424d0 100644
--- a/src/main/java/net/minecraft/server/RecipeMapClone.java
+++ b/src/main/java/net/minecraft/server/RecipeMapClone.java
@@ -1,5 +1,12 @@
 package net.minecraft.server;
 
+
+//OilSpigot start
+import net.minecraft.server.oilmod.IInventoryCrafting;
+import org.oilmod.spigot.items.itemstackimpl.crafting.help.CHView;
+import org.oilmod.spigot.items.itemstackimpl.internal.ModItemStack;
+//OilSpigot end
+
 public class RecipeMapClone extends ShapelessRecipes implements IRecipe { // CraftBukkit - added extends
 
     // CraftBukkit start - Delegate to new parent class
@@ -8,7 +15,7 @@ public class RecipeMapClone extends ShapelessRecipes implements IRecipe { // Cra
     }
     // CraftBukkit end
 
-    public boolean a(InventoryCrafting inventorycrafting, World world) {
+    public boolean a(IInventoryCrafting inventorycrafting, World world) {  //OilSpigot changed from InventoryCrafting to IInventoryCrafting
         int i = 0;
         ItemStack itemstack = ItemStack.a;
 
@@ -16,6 +23,9 @@ public class RecipeMapClone extends ShapelessRecipes implements IRecipe { // Cra
             ItemStack itemstack1 = inventorycrafting.getItem(j);
 
             if (!itemstack1.isEmpty()) {
+                if (itemstack instanceof ModItemStack) { //OilSpigot disallow normal crafting with custom items
+                    return false;
+                }
                 if (itemstack1.getItem() == Items.FILLED_MAP) {
                     if (!itemstack.isEmpty()) {
                         return false;
@@ -35,7 +45,7 @@ public class RecipeMapClone extends ShapelessRecipes implements IRecipe { // Cra
         return !itemstack.isEmpty() && i > 0;
     }
 
-    public ItemStack craftItem(InventoryCrafting inventorycrafting) {
+    public ItemStack craftItem(IInventoryCrafting inventorycrafting) {  //OilSpigot changed from InventoryCrafting to IInventoryCrafting
         int i = 0;
         ItemStack itemstack = ItemStack.a;
 
@@ -80,7 +90,7 @@ public class RecipeMapClone extends ShapelessRecipes implements IRecipe { // Cra
         return ItemStack.a;
     }
 
-    public NonNullList<ItemStack> b(InventoryCrafting inventorycrafting) {
+    public NonNullList<ItemStack> b(IInventoryCrafting inventorycrafting) { //OilSpigot changed from InventoryCrafting to IInventoryCrafting
         NonNullList nonnulllist = NonNullList.a(inventorycrafting.getSize(), ItemStack.a);
 
         for (int i = 0; i < nonnulllist.size(); ++i) {
@@ -97,4 +107,12 @@ public class RecipeMapClone extends ShapelessRecipes implements IRecipe { // Cra
     public boolean c() {
         return true;
     }
+
+
+    //OilSpigot start
+    @Override
+    protected CHView createCraftingHelp() {
+        return null;
+    }
+    //OilSpigot end
 }
diff --git a/src/main/java/net/minecraft/server/RecipeMapExtend.java b/src/main/java/net/minecraft/server/RecipeMapExtend.java
new file mode 100644
index 00000000..3d8b8271
--- /dev/null
+++ b/src/main/java/net/minecraft/server/RecipeMapExtend.java
@@ -0,0 +1,78 @@
+package net.minecraft.server;
+
+
+import net.minecraft.server.oilmod.IInventoryCrafting;
+
+import java.util.Iterator;
+
+public class RecipeMapExtend extends ShapedRecipes {
+
+    public RecipeMapExtend() {
+        super("", 3, 3, NonNullList.a(RecipeItemStack.a, RecipeItemStack.a(new Item[] { Items.PAPER}), RecipeItemStack.a(new Item[] { Items.PAPER}), RecipeItemStack.a(new Item[] { Items.PAPER}), RecipeItemStack.a(new Item[] { Items.PAPER}), RecipeItemStack.a((Item) Items.FILLED_MAP), RecipeItemStack.a(new Item[] { Items.PAPER}), RecipeItemStack.a(new Item[] { Items.PAPER}), RecipeItemStack.a(new Item[] { Items.PAPER}), RecipeItemStack.a(new Item[] { Items.PAPER})), new ItemStack(Items.MAP));
+    }
+
+    public boolean a(IInventoryCrafting inventorycrafting, World world) {//OilSpigot changed from InventoryCrafting to IInventoryCrafting
+        if (!super.a(inventorycrafting, world)) {
+            return false;
+        } else {
+            ItemStack itemstack = ItemStack.a;
+
+            for (int i = 0; i < inventorycrafting.getSize() && itemstack.isEmpty(); ++i) {
+                ItemStack itemstack1 = inventorycrafting.getItem(i);
+
+                if (itemstack1.getItem() == Items.FILLED_MAP) {
+                    itemstack = itemstack1;
+                }
+            }
+
+            if (itemstack.isEmpty()) {
+                return false;
+            } else {
+                WorldMap worldmap = Items.FILLED_MAP.getSavedMap(itemstack, world);
+
+                return worldmap == null ? false : (this.a(worldmap) ? false : worldmap.scale < 4);
+            }
+        }
+    }
+
+    private boolean a(WorldMap worldmap) {
+        if (worldmap.decorations != null) {
+            Iterator iterator = worldmap.decorations.values().iterator();
+
+            while (iterator.hasNext()) {
+                MapIcon mapicon = (MapIcon) iterator.next();
+
+                if (mapicon.b() == MapIcon.Type.MANSION || mapicon.b() == MapIcon.Type.MONUMENT) {
+                    return true;
+                }
+            }
+        }
+
+        return false;
+    }
+
+    public ItemStack craftItem(IInventoryCrafting inventorycrafting) {//OilSpigot changed from InventoryCrafting to IInventoryCrafting
+        ItemStack itemstack = ItemStack.a;
+
+        for (int i = 0; i < inventorycrafting.getSize() && itemstack.isEmpty(); ++i) {
+            ItemStack itemstack1 = inventorycrafting.getItem(i);
+
+            if (itemstack1.getItem() == Items.FILLED_MAP) {
+                itemstack = itemstack1;
+            }
+        }
+
+        itemstack = itemstack.cloneItemStack();
+        itemstack.setCount(1);
+        if (itemstack.getTag() == null) {
+            itemstack.setTag(new NBTTagCompound());
+        }
+
+        itemstack.getTag().setInt("map_scale_direction", 1);
+        return itemstack;
+    }
+
+    public boolean c() {
+        return true;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/net/minecraft/server/RecipeRepair.java b/src/main/java/net/minecraft/server/RecipeRepair.java
index fb47f3e1..b1506bad 100644
--- a/src/main/java/net/minecraft/server/RecipeRepair.java
+++ b/src/main/java/net/minecraft/server/RecipeRepair.java
@@ -3,6 +3,13 @@ package net.minecraft.server;
 import com.google.common.collect.Lists;
 import java.util.ArrayList;
 
+//OilSpigot start
+import net.minecraft.server.oilmod.IInventoryCrafting;
+import org.oilmod.spigot.items.itemstackimpl.crafting.help.CHView;
+import org.oilmod.spigot.items.itemstackimpl.crafting.help.VanillaRepairCHView;
+import org.oilmod.spigot.items.itemstackimpl.internal.ModItemStack;
+//OilSpigot end
+
 public class RecipeRepair extends ShapelessRecipes implements IRecipe { // CraftBukkit - added extends
 
     // CraftBukkit start - Delegate to new parent class
@@ -11,13 +18,16 @@ public class RecipeRepair extends ShapelessRecipes implements IRecipe { // Craft
     }
     // CraftBukkit end
 
-    public boolean a(InventoryCrafting inventorycrafting, World world) {
+    public boolean a(IInventoryCrafting inventorycrafting, World world) { //OilSpigot changed from InventoryCrafting to IInventoryCrafting
         ArrayList arraylist = Lists.newArrayList();
 
         for (int i = 0; i < inventorycrafting.getSize(); ++i) {
             ItemStack itemstack = inventorycrafting.getItem(i);
 
             if (!itemstack.isEmpty()) {
+                if (itemstack instanceof ModItemStack) { //OilSpigot disallow normal crafting with custom items
+                    return false;
+                }
                 arraylist.add(itemstack);
                 if (arraylist.size() > 1) {
                     ItemStack itemstack1 = (ItemStack) arraylist.get(0);
@@ -32,7 +42,7 @@ public class RecipeRepair extends ShapelessRecipes implements IRecipe { // Craft
         return arraylist.size() == 2;
     }
 
-    public ItemStack craftItem(InventoryCrafting inventorycrafting) {
+    public ItemStack craftItem(IInventoryCrafting inventorycrafting) { //OilSpigot changed from InventoryCrafting to IInventoryCrafting
         ArrayList arraylist = Lists.newArrayList();
 
         ItemStack itemstack;
@@ -72,9 +82,11 @@ public class RecipeRepair extends ShapelessRecipes implements IRecipe { // Craft
                 ingredients.add(RecipeItemStack.a(new ItemStack[]{itemstack2.cloneItemStack()}));
                 ingredients.add(RecipeItemStack.a(new ItemStack[]{itemstack.cloneItemStack()}));
                 ShapelessRecipes recipe = new ShapelessRecipes("", result.cloneItemStack(), ingredients);
-                recipe.key = new MinecraftKey("repairitem");
-                inventorycrafting.currentRecipe = recipe;
-                result = org.bukkit.craftbukkit.event.CraftEventFactory.callPreCraftEvent(inventorycrafting, result, inventorycrafting.container.getBukkitView(), true);
+                //OilSpigot start
+                recipe.registered(new MinecraftKey("repairitem"), getGlobalId());
+                inventorycrafting.setCurrentRecipe(recipe);
+                result = org.bukkit.craftbukkit.event.CraftEventFactory.callPreCraftEvent(inventorycrafting, result, inventorycrafting.getContainer().getBukkitView(), true);
+                //OilSpigot end
                 return result;
                 // return new ItemStack(itemstack2.getItem(), 1, i1);
                 // CraftBukkit end
@@ -88,7 +100,7 @@ public class RecipeRepair extends ShapelessRecipes implements IRecipe { // Craft
         return ItemStack.a;
     }
 
-    public NonNullList<ItemStack> b(InventoryCrafting inventorycrafting) {
+    public NonNullList<ItemStack> b(IInventoryCrafting inventorycrafting) { //OilSpigot changed from InventoryCrafting to IInventoryCrafting
         NonNullList nonnulllist = NonNullList.a(inventorycrafting.getSize(), ItemStack.a);
 
         for (int i = 0; i < nonnulllist.size(); ++i) {
@@ -105,4 +117,11 @@ public class RecipeRepair extends ShapelessRecipes implements IRecipe { // Craft
     public boolean c() {
         return true;
     }
+
+    //OilSpigot start
+    @Override
+    protected CHView createCraftingHelp() {
+        return new VanillaRepairCHView();
+    }
+    //OilSpigot end
 }
diff --git a/src/main/java/net/minecraft/server/RecipeTippedArrow.java b/src/main/java/net/minecraft/server/RecipeTippedArrow.java
index 31c004f1..54d898f7 100644
--- a/src/main/java/net/minecraft/server/RecipeTippedArrow.java
+++ b/src/main/java/net/minecraft/server/RecipeTippedArrow.java
@@ -2,6 +2,12 @@ package net.minecraft.server;
 
 import java.util.Collection;
 
+//OilSpigot start
+import net.minecraft.server.oilmod.IInventoryCrafting;
+import org.oilmod.spigot.items.itemstackimpl.crafting.help.CHView;
+import org.oilmod.spigot.items.itemstackimpl.crafting.help.VanillaTippedArrowCHView;
+//OilSpigot end
+
 public class RecipeTippedArrow extends ShapedRecipes implements IRecipe { // CraftBukkit
 
     // CraftBukkit start
@@ -14,7 +20,7 @@ public class RecipeTippedArrow extends ShapedRecipes implements IRecipe { // Cra
     }
     // CraftBukkit end
 
-    public boolean a(InventoryCrafting inventorycrafting, World world) {
+    public boolean a(IInventoryCrafting inventorycrafting, World world) { //OilSpigot changed from InventoryCrafting to IInventoryCrafting
         if (inventorycrafting.j() == 3 && inventorycrafting.i() == 3) {
             for (int i = 0; i < inventorycrafting.j(); ++i) {
                 for (int j = 0; j < inventorycrafting.i(); ++j) {
@@ -42,7 +48,7 @@ public class RecipeTippedArrow extends ShapedRecipes implements IRecipe { // Cra
         }
     }
 
-    public ItemStack craftItem(InventoryCrafting inventorycrafting) {
+    public ItemStack craftItem(IInventoryCrafting inventorycrafting) { //OilSpigot changed from InventoryCrafting to IInventoryCrafting
         ItemStack itemstack = inventorycrafting.c(1, 1);
 
         if (itemstack.getItem() != Items.LINGERING_POTION) {
@@ -60,11 +66,18 @@ public class RecipeTippedArrow extends ShapedRecipes implements IRecipe { // Cra
         return ItemStack.a;
     }
 
-    public NonNullList<ItemStack> b(InventoryCrafting inventorycrafting) {
+    public NonNullList<ItemStack> b(IInventoryCrafting inventorycrafting) { //OilSpigot changed from InventoryCrafting to IInventoryCrafting
         return NonNullList.a(inventorycrafting.getSize(), ItemStack.a);
     }
 
     public boolean c() {
         return true;
     }
+
+    //OilSpigot start
+    @Override
+    protected CHView createCraftingHelp() {
+        return new VanillaTippedArrowCHView();
+    }
+    //OilSpigot end
 }
diff --git a/src/main/java/net/minecraft/server/RecipiesShield.java b/src/main/java/net/minecraft/server/RecipiesShield.java
index 5f2b8308..4626b6bc 100644
--- a/src/main/java/net/minecraft/server/RecipiesShield.java
+++ b/src/main/java/net/minecraft/server/RecipiesShield.java
@@ -1,5 +1,11 @@
 package net.minecraft.server;
 
+/*OilSpigo1t start*/
+import net.minecraft.server.oilmod.IInventoryCrafting;
+import org.oilmod.spigot.items.itemstackimpl.crafting.help.CHView;
+import org.oilmod.spigot.items.itemstackimpl.crafting.help.VanillaShieldBannerCHView;
+//OilSpigot end
+
 // CraftBukkit - decompile weirdness
 public class RecipiesShield {
 
@@ -11,7 +17,7 @@ public class RecipiesShield {
         }
         // CraftBukkit end
 
-        public boolean a(InventoryCrafting inventorycrafting, World world) {
+        public boolean a(IInventoryCrafting inventorycrafting, World world) { //OilSpigot changed from InventoryCrafting to IInventoryCrafting
             ItemStack itemstack = ItemStack.a;
             ItemStack itemstack1 = ItemStack.a;
 
@@ -50,7 +56,7 @@ public class RecipiesShield {
             }
         }
 
-        public ItemStack craftItem(InventoryCrafting inventorycrafting) {
+        public ItemStack craftItem(IInventoryCrafting inventorycrafting) { //OilSpigot changed from InventoryCrafting to IInventoryCrafting
             ItemStack itemstack = ItemStack.a;
             ItemStack itemstack1 = ItemStack.a;
 
@@ -82,7 +88,7 @@ public class RecipiesShield {
             return ItemStack.a;
         }
 
-        public NonNullList<ItemStack> b(InventoryCrafting inventorycrafting) {
+        public NonNullList<ItemStack> b(IInventoryCrafting inventorycrafting) { //OilSpigot changed from InventoryCrafting to IInventoryCrafting
             NonNullList nonnulllist = NonNullList.a(inventorycrafting.getSize(), ItemStack.a);
 
             for (int i = 0; i < nonnulllist.size(); ++i) {
@@ -99,5 +105,12 @@ public class RecipiesShield {
         public boolean c() {
             return true;
         }
+
+        //OilSpigot start
+        @Override
+        protected CHView createCraftingHelp() {
+            return new VanillaShieldBannerCHView();
+        }
+        //OilSpigot end
     }
 }
diff --git a/src/main/java/net/minecraft/server/ShapedRecipes.java b/src/main/java/net/minecraft/server/ShapedRecipes.java
index dd42c47d..797b1bea 100644
--- a/src/main/java/net/minecraft/server/ShapedRecipes.java
+++ b/src/main/java/net/minecraft/server/ShapedRecipes.java
@@ -14,11 +14,19 @@ import java.util.Iterator;
 import java.util.Map;
 import java.util.Map.Entry;
 import javax.annotation.Nullable;
+
 // CraftBukkit start
+import net.minecraft.server.oilmod.IInventoryCrafting;
+import org.apache.commons.lang3.Validate;
 import org.bukkit.craftbukkit.inventory.CraftItemStack;
 import org.bukkit.craftbukkit.inventory.CraftShapedRecipe;
 // CraftBukkit end
 
+//OilSpigot start
+import org.oilmod.spigot.items.itemstackimpl.crafting.help.CHView;
+import org.oilmod.spigot.items.itemstackimpl.crafting.help.VanillaShapedCHView;
+//OilSpigot end
+
 public class ShapedRecipes implements IRecipe {
 
     private final int width;
@@ -26,14 +34,35 @@ public class ShapedRecipes implements IRecipe {
     private final NonNullList<RecipeItemStack> items;
     private final ItemStack result;
     private final String e;
+
+    //OilSpigot start - key and global id
     // CraftBukkit start
-    public MinecraftKey key;
+    private MinecraftKey key; //OilSpigot PAIL public private
+
+    public MinecraftKey getKey() {
+        return key;
+    }
+    // CraftBukkit end
+    private int globalId= -1;
+
+    @Override
+    public int getGlobalId() {
+        return globalId;
+    }
 
     @Override
-    public void setKey(MinecraftKey key) {
+    public boolean isRegistered() {
+        return globalId >= 0;
+    }
+
+    @Override
+    public void registered(MinecraftKey key, int globalId) {
+        Validate.isTrue(!isRegistered(), "Cannot register recipe into global register twice");
+        Validate.isTrue(globalId >= 0, "global id needs to bigger than 0");
         this.key = key;
+        this.globalId = globalId;
     }
-    // CraftBukkit end
+    //OilSpigot end
 
     public ShapedRecipes(String s, int i, int j, NonNullList<RecipeItemStack> nonnulllist, ItemStack itemstack) {
         this.e = s;
@@ -41,8 +70,22 @@ public class ShapedRecipes implements IRecipe {
         this.height = j;
         this.items = nonnulllist;
         this.result = itemstack;
+        this.chViews = createCraftingHelps();//OilSpigot
     }
 
+    //OilSpigot start
+    public int getWidth() {
+        return width;
+    }
+
+    public int getHeight() {
+        return height;
+    }
+    public int getSize() {
+        return height*width;
+    }
+    //OilSpigot end
+
     // CraftBukkit start
     public org.bukkit.inventory.ShapedRecipe toBukkitRecipe() {
         CraftItemStack result = CraftItemStack.asCraftMirror(this.result);
@@ -104,7 +147,7 @@ public class ShapedRecipes implements IRecipe {
         return this.result;
     }
 
-    public NonNullList<ItemStack> b(InventoryCrafting inventorycrafting) {
+    public NonNullList<ItemStack> b(IInventoryCrafting inventorycrafting) { //OilSpigot changed from InventoryCrafting to IInventoryCrafting
         NonNullList nonnulllist = NonNullList.a(inventorycrafting.getSize(), ItemStack.a);
 
         for (int i = 0; i < nonnulllist.size(); ++i) {
@@ -122,7 +165,7 @@ public class ShapedRecipes implements IRecipe {
         return this.items;
     }
 
-    public boolean a(InventoryCrafting inventorycrafting, World world) {
+    public boolean a(IInventoryCrafting inventorycrafting, World world) { //OilSpigot changed from InventoryCrafting to IInventoryCrafting
         for (int i = 0; i <= 3 - this.width; ++i) {
             for (int j = 0; j <= 3 - this.height; ++j) {
                 if (this.a(inventorycrafting, i, j, true)) {
@@ -138,7 +181,7 @@ public class ShapedRecipes implements IRecipe {
         return false;
     }
 
-    private boolean a(InventoryCrafting inventorycrafting, int i, int j, boolean flag) {
+    private boolean a(IInventoryCrafting inventorycrafting, int i, int j, boolean flag) { //OilSpigot changed from InventoryCrafting to IInventoryCrafting
         for (int k = 0; k < 3; ++k) {
             for (int l = 0; l < 3; ++l) {
                 int i1 = k - i;
@@ -153,7 +196,9 @@ public class ShapedRecipes implements IRecipe {
                     }
                 }
 
-                if (!recipeitemstack.a(inventorycrafting.c(k, l))) {
+
+                ItemStack itemstack1 = inventorycrafting.c(k, l);
+                if (!recipeitemstack.a(itemstack1)) {
                     return false;
                 }
             }
@@ -162,7 +207,7 @@ public class ShapedRecipes implements IRecipe {
         return true;
     }
 
-    public ItemStack craftItem(InventoryCrafting inventorycrafting) {
+    public ItemStack craftItem(IInventoryCrafting inventorycrafting) { //OilSpigot changed from InventoryCrafting to IInventoryCrafting
         return this.b().cloneItemStack();
     }
 
@@ -360,4 +405,22 @@ public class ShapedRecipes implements IRecipe {
             return new ItemStack(item, j, i);
         }
     }
+
+    //OilSpigot start
+
+    private final CHView[] chViews;
+    @Override
+    public final CHView[] getCraftingHelps() {
+        return chViews;
+    }
+
+    protected CHView[] createCraftingHelps() {
+        CHView view = createCraftingHelp();
+        return view == null?new CHView[]{}:new CHView[]{view};
+    }
+
+    protected CHView createCraftingHelp() {
+        return new VanillaShapedCHView(this);
+    }
+    //OilSpigot end
 }
diff --git a/src/main/java/net/minecraft/server/ShapelessRecipes.java b/src/main/java/net/minecraft/server/ShapelessRecipes.java
index 9c69f92f..39aa1d0f 100644
--- a/src/main/java/net/minecraft/server/ShapelessRecipes.java
+++ b/src/main/java/net/minecraft/server/ShapelessRecipes.java
@@ -7,28 +7,57 @@ import com.google.gson.JsonParseException;
 import java.util.ArrayList;
 import java.util.Iterator;
 // CraftBukkit start
+import net.minecraft.server.oilmod.IInventoryCrafting;
+import org.apache.commons.lang3.Validate;
 import org.bukkit.craftbukkit.inventory.CraftItemStack;
 import org.bukkit.craftbukkit.inventory.CraftShapelessRecipe;
 // CraftBukkit end
 
+//OilSpigot start
+import org.oilmod.spigot.items.itemstackimpl.crafting.help.CHView;
+import org.oilmod.spigot.items.itemstackimpl.crafting.help.VanillaShapelessCHView;
+//OilSpigot end
+
 public class ShapelessRecipes implements IRecipe {
 
     private final ItemStack result;
     private final NonNullList<RecipeItemStack> ingredients;
     private final String c;
+
+    //OilSpigot start - key and global id
     // CraftBukkit start
-    public MinecraftKey key;
+    private MinecraftKey key; //OilSpigot PAIL public private
+
+    public MinecraftKey getKey() {
+        return key;
+    }
+    // CraftBukkit end
+    private int globalId= -1;
+
+    @Override
+    public int getGlobalId() {
+        return globalId;
+    }
+
+    @Override
+    public boolean isRegistered() {
+        return globalId >= 0;
+    }
 
     @Override
-    public void setKey(MinecraftKey key) {
+    public void registered(MinecraftKey key, int globalId) {
+        Validate.isTrue(!isRegistered(), "Cannot register recipe into global register twice");
+        Validate.isTrue(globalId >= 0, "global id needs to bigger than 0");
         this.key = key;
+        this.globalId = globalId;
     }
-    // CraftBukkit end
+    //OilSpigot end
 
     public ShapelessRecipes(String s, ItemStack itemstack, NonNullList<RecipeItemStack> nonnulllist) {
         this.c = s;
         this.result = itemstack;
         this.ingredients = nonnulllist;
+        this.chViews = createCraftingHelps();//OilSpigot
     }
 
     // CraftBukkit start
@@ -54,7 +83,7 @@ public class ShapelessRecipes implements IRecipe {
         return this.ingredients;
     }
 
-    public NonNullList<ItemStack> b(InventoryCrafting inventorycrafting) {
+    public NonNullList<ItemStack> b(IInventoryCrafting inventorycrafting) { //OilSpigot changed from InventoryCrafting to IInventoryCrafting
         NonNullList nonnulllist = NonNullList.a(inventorycrafting.getSize(), ItemStack.a);
 
         for (int i = 0; i < nonnulllist.size(); ++i) {
@@ -68,7 +97,7 @@ public class ShapelessRecipes implements IRecipe {
         return nonnulllist;
     }
 
-    public boolean a(InventoryCrafting inventorycrafting, World world) {
+    public boolean a(IInventoryCrafting inventorycrafting, World world) { //OilSpigot changed from InventoryCrafting to IInventoryCrafting
         ArrayList arraylist = Lists.newArrayList(this.ingredients);
 
         for (int i = 0; i < inventorycrafting.i(); ++i) {
@@ -82,7 +111,7 @@ public class ShapelessRecipes implements IRecipe {
                     while (iterator.hasNext()) {
                         RecipeItemStack recipeitemstack = (RecipeItemStack) iterator.next();
 
-                        if (recipeitemstack.a(itemstack)) {
+                        if (recipeitemstack.a(itemstack)) { //OilSpigot check to exclude mod-items in in here
                             flag = true;
                             arraylist.remove(recipeitemstack);
                             break;
@@ -99,7 +128,7 @@ public class ShapelessRecipes implements IRecipe {
         return arraylist.isEmpty();
     }
 
-    public ItemStack craftItem(InventoryCrafting inventorycrafting) {
+    public ItemStack craftItem(IInventoryCrafting inventorycrafting) { //OilSpigot changed from InventoryCrafting to IInventoryCrafting
         return this.result.cloneItemStack();
     }
 
@@ -131,4 +160,30 @@ public class ShapelessRecipes implements IRecipe {
 
         return nonnulllist;
     }
+
+    //OilSpigot start
+    public java.util.Collection<RecipeItemStack> getIngredients()
+    {
+        return java.util.Collections.unmodifiableList( ingredients );
+    }
+
+    private final CHView[] chViews;
+    @Override
+    public final CHView[] getCraftingHelps() {
+        return chViews;
+    }
+
+    protected CHView[] createCraftingHelps() {
+        CHView view = createCraftingHelp();
+        return view == null?new CHView[]{}:new CHView[]{view};
+    }
+
+    protected CHView createCraftingHelp() {
+        return new VanillaShapelessCHView(this);
+    }
+
+    public int getSize() {
+        return ingredients.size();
+    }
+    //OilSpigot end
 }
diff --git a/src/main/java/net/minecraft/server/Slot.java b/src/main/java/net/minecraft/server/Slot.java
new file mode 100644
index 00000000..b79106b6
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Slot.java
@@ -0,0 +1,84 @@
+package net.minecraft.server;
+
+public class Slot {
+
+    public final int index;
+    private final IInventory inventory; //OilSpigot changed to private
+    public int rawSlotIndex;
+    public int f;
+    public int g;
+
+    public Slot(IInventory iinventory, int i, int j, int k) {
+        this.inventory = iinventory;
+        this.index = i;
+        this.f = j;
+        this.g = k;
+    }
+
+    public void a(ItemStack itemstack, ItemStack itemstack1) {
+        int i = itemstack1.getCount() - itemstack.getCount();
+
+        if (i > 0) {
+            this.a(itemstack1, i);
+        }
+
+    }
+
+    protected void a(ItemStack itemstack, int i) {}
+
+    protected void b(int i) {}
+
+    protected void c(ItemStack itemstack) {}
+
+    public ItemStack a(EntityHuman entityhuman, ItemStack itemstack) {
+        this.f();
+        return itemstack;
+    }
+
+    public boolean isAllowed(ItemStack itemstack) {
+        return true;
+    }
+
+    public ItemStack getItem() {
+        return this.inventory.getItem(this.index);
+    }
+
+    public boolean hasItem() {
+        return !this.getItem().isEmpty();
+    }
+
+    public void set(ItemStack itemstack) {
+        this.inventory.setItem(this.index, itemstack);
+        this.f();
+    }
+
+    public void f() {
+        this.inventory.update();
+    }
+
+    public int getMaxStackSize() {
+        return this.inventory.getMaxStackSize();
+    }
+
+    public int getMaxStackSize(ItemStack itemstack) {
+        return this.getMaxStackSize();
+    }
+
+    public ItemStack a(int i) {
+        return this.inventory.splitStack(this.index, i);
+    }
+
+    public boolean a(IInventory iinventory, int i) {
+        return iinventory == this.inventory && i == this.index;
+    }
+
+    public boolean isAllowed(EntityHuman entityhuman) {
+        return true;
+    }
+
+    //OilSpigot start
+    public IInventory getInventory() {
+        return inventory;
+    }
+    //OilSpigot end
+}
diff --git a/src/main/java/net/minecraft/server/SlotFurnaceResult.java b/src/main/java/net/minecraft/server/SlotFurnaceResult.java
index ed394f7a..fa20dfa6 100644
--- a/src/main/java/net/minecraft/server/SlotFurnaceResult.java
+++ b/src/main/java/net/minecraft/server/SlotFurnaceResult.java
@@ -7,8 +7,9 @@ import org.bukkit.event.inventory.FurnaceExtractEvent;
 
 public class SlotFurnaceResult extends Slot {
 
-    private final EntityHuman a;public EntityHuman getPlayer() { return a; } // Paper OBFHELPER
-    private int b;
+    protected final EntityHuman a; //OilSpigot PAIL private -> protected //TODO: undo
+    public EntityHuman getPlayer() { return a; } // Paper OBFHELPER
+    protected int b; //OilSpigot PAIL private -> protected
 
     public SlotFurnaceResult(EntityHuman entityhuman, IInventory iinventory, int i, int j, int k) {
         super(iinventory, i, j, k);
@@ -58,7 +59,7 @@ public class SlotFurnaceResult extends Slot {
 
             // CraftBukkit start - fire FurnaceExtractEvent
             Player player = (Player) a.getBukkitEntity();
-            TileEntityFurnace furnace = ((TileEntityFurnace) this.inventory);
+            TileEntityFurnace furnace = ((TileEntityFurnace) this.getInventory());  //OilSpigot - changed .inventory to .getInventory()
             org.bukkit.block.Block block = a.world.getWorld().getBlockAt(furnace.position.getX(), furnace.position.getY(), furnace.position.getZ());
 
             if (b != 0) {
diff --git a/src/main/java/net/minecraft/server/SlotResult.java b/src/main/java/net/minecraft/server/SlotResult.java
new file mode 100644
index 00000000..d5768266
--- /dev/null
+++ b/src/main/java/net/minecraft/server/SlotResult.java
@@ -0,0 +1,85 @@
+package net.minecraft.server;
+
+import com.google.common.collect.Lists;
+import net.minecraft.server.oilmod.IInventoryCraftResult;
+import net.minecraft.server.oilmod.IInventoryCrafting;
+
+public class SlotResult extends Slot {
+
+    private final IInventoryCrafting a; //OilSpigot InventoryCrafting->IInventoryCrafting
+    private final EntityHuman b;
+    private int c;
+
+    public SlotResult(EntityHuman entityhuman, IInventoryCrafting inventorycrafting, IInventory iinventory, int i, int j, int k) { //OilSpigot InventoryCrafting->IInventoryCrafting
+        super(iinventory, i, j, k);
+        this.b = entityhuman;
+        this.a = inventorycrafting;
+    }
+
+    public boolean isAllowed(ItemStack itemstack) {
+        return false;
+    }
+
+    public ItemStack a(int i) {
+        if (this.hasItem()) {
+            this.c += Math.min(i, this.getItem().getCount());
+        }
+
+        return super.a(i);
+    }
+
+    protected void a(ItemStack itemstack, int i) {
+        this.c += i;
+        this.c(itemstack);
+    }
+
+    protected void b(int i) {
+        this.c += i;
+    }
+
+    protected void c(ItemStack itemstack) {
+        if (this.c > 0) {
+            itemstack.a(this.b.world, this.b, this.c);
+        }
+
+        this.c = 0;
+        //OilSPigot changed to Oil variants (class->interface, field->method)
+        IInventoryCraftResult inventorycraftresult = (IInventoryCraftResult) this.getInventory();
+        IRecipe irecipe = inventorycraftresult.i();
+
+        if (irecipe != null && !irecipe.c()) {
+            this.b.a(Lists.newArrayList(irecipe)); //fix decompile error
+            inventorycraftresult.a((IRecipe) null);
+        }
+
+    }
+
+    public ItemStack a(EntityHuman entityhuman, ItemStack itemstack) {
+        this.c(itemstack);
+        //OilSpigot use correct CraftingManager
+        NonNullList nonnulllist = a.getCraftingManager().c(this.a, entityhuman.world);
+
+        for (int i = 0; i < nonnulllist.size(); ++i) {
+            ItemStack itemstack1 = this.a.getItem(i);
+            ItemStack itemstack2 = (ItemStack) nonnulllist.get(i);
+
+            if (!itemstack1.isEmpty()) {
+                this.a.splitStack(i, 1);
+                itemstack1 = this.a.getItem(i);
+            }
+
+            if (!itemstack2.isEmpty()) {
+                if (itemstack1.isEmpty()) {
+                    this.a.setItem(i, itemstack2);
+                } else if (ItemStack.c(itemstack1, itemstack2) && ItemStack.equals(itemstack1, itemstack2)) {
+                    itemstack2.add(itemstack1.getCount());
+                    this.a.setItem(i, itemstack2);
+                } else if (!this.b.inventory.pickup(itemstack2)) {
+                    this.b.drop(itemstack2, false);
+                }
+            }
+        }
+
+        return itemstack;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/StatisticList.java b/src/main/java/net/minecraft/server/StatisticList.java
new file mode 100644
index 00000000..6578851e
--- /dev/null
+++ b/src/main/java/net/minecraft/server/StatisticList.java
@@ -0,0 +1,288 @@
+package net.minecraft.server;
+
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Sets;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import javax.annotation.Nullable;
+
+public class StatisticList {
+
+    protected static final Map<String, Statistic> a = Maps.newHashMap();
+    public static final List<Statistic> stats = Lists.newArrayList();
+    public static final List<Statistic> c = Lists.newArrayList();
+    public static final List<CraftingStatistic> d = Lists.newArrayList();
+    public static final List<CraftingStatistic> e = Lists.newArrayList();
+    public static final Statistic f = (new CounterStatistic("stat.leaveGame", new ChatMessage("stat.leaveGame", new Object[0]))).c().a();
+    public static final Statistic g = (new CounterStatistic("stat.playOneMinute", new ChatMessage("stat.playOneMinute", new Object[0]), Statistic.d)).c().a();
+    public static final Statistic h = (new CounterStatistic("stat.timeSinceDeath", new ChatMessage("stat.timeSinceDeath", new Object[0]), Statistic.d)).c().a();
+    public static final Statistic i = (new CounterStatistic("stat.sneakTime", new ChatMessage("stat.sneakTime", new Object[0]), Statistic.d)).c().a();
+    public static final Statistic j = (new CounterStatistic("stat.walkOneCm", new ChatMessage("stat.walkOneCm", new Object[0]), Statistic.e)).c().a();
+    public static final Statistic k = (new CounterStatistic("stat.crouchOneCm", new ChatMessage("stat.crouchOneCm", new Object[0]), Statistic.e)).c().a();
+    public static final Statistic l = (new CounterStatistic("stat.sprintOneCm", new ChatMessage("stat.sprintOneCm", new Object[0]), Statistic.e)).c().a();
+    public static final Statistic m = (new CounterStatistic("stat.swimOneCm", new ChatMessage("stat.swimOneCm", new Object[0]), Statistic.e)).c().a();
+    public static final Statistic n = (new CounterStatistic("stat.fallOneCm", new ChatMessage("stat.fallOneCm", new Object[0]), Statistic.e)).c().a();
+    public static final Statistic o = (new CounterStatistic("stat.climbOneCm", new ChatMessage("stat.climbOneCm", new Object[0]), Statistic.e)).c().a();
+    public static final Statistic p = (new CounterStatistic("stat.flyOneCm", new ChatMessage("stat.flyOneCm", new Object[0]), Statistic.e)).c().a();
+    public static final Statistic q = (new CounterStatistic("stat.diveOneCm", new ChatMessage("stat.diveOneCm", new Object[0]), Statistic.e)).c().a();
+    public static final Statistic r = (new CounterStatistic("stat.minecartOneCm", new ChatMessage("stat.minecartOneCm", new Object[0]), Statistic.e)).c().a();
+    public static final Statistic s = (new CounterStatistic("stat.boatOneCm", new ChatMessage("stat.boatOneCm", new Object[0]), Statistic.e)).c().a();
+    public static final Statistic t = (new CounterStatistic("stat.pigOneCm", new ChatMessage("stat.pigOneCm", new Object[0]), Statistic.e)).c().a();
+    public static final Statistic u = (new CounterStatistic("stat.horseOneCm", new ChatMessage("stat.horseOneCm", new Object[0]), Statistic.e)).c().a();
+    public static final Statistic v = (new CounterStatistic("stat.aviateOneCm", new ChatMessage("stat.aviateOneCm", new Object[0]), Statistic.e)).c().a();
+    public static final Statistic w = (new CounterStatistic("stat.jump", new ChatMessage("stat.jump", new Object[0]))).c().a();
+    public static final Statistic x = (new CounterStatistic("stat.drop", new ChatMessage("stat.drop", new Object[0]))).c().a();
+    public static final Statistic y = (new CounterStatistic("stat.damageDealt", new ChatMessage("stat.damageDealt", new Object[0]), Statistic.f)).a();
+    public static final Statistic z = (new CounterStatistic("stat.damageTaken", new ChatMessage("stat.damageTaken", new Object[0]), Statistic.f)).a();
+    public static final Statistic A = (new CounterStatistic("stat.deaths", new ChatMessage("stat.deaths", new Object[0]))).a();
+    public static final Statistic B = (new CounterStatistic("stat.mobKills", new ChatMessage("stat.mobKills", new Object[0]))).a();
+    public static final Statistic C = (new CounterStatistic("stat.animalsBred", new ChatMessage("stat.animalsBred", new Object[0]))).a();
+    public static final Statistic D = (new CounterStatistic("stat.playerKills", new ChatMessage("stat.playerKills", new Object[0]))).a();
+    public static final Statistic E = (new CounterStatistic("stat.fishCaught", new ChatMessage("stat.fishCaught", new Object[0]))).a();
+    public static final Statistic F = (new CounterStatistic("stat.talkedToVillager", new ChatMessage("stat.talkedToVillager", new Object[0]))).a();
+    public static final Statistic G = (new CounterStatistic("stat.tradedWithVillager", new ChatMessage("stat.tradedWithVillager", new Object[0]))).a();
+    public static final Statistic H = (new CounterStatistic("stat.cakeSlicesEaten", new ChatMessage("stat.cakeSlicesEaten", new Object[0]))).a();
+    public static final Statistic I = (new CounterStatistic("stat.cauldronFilled", new ChatMessage("stat.cauldronFilled", new Object[0]))).a();
+    public static final Statistic J = (new CounterStatistic("stat.cauldronUsed", new ChatMessage("stat.cauldronUsed", new Object[0]))).a();
+    public static final Statistic K = (new CounterStatistic("stat.armorCleaned", new ChatMessage("stat.armorCleaned", new Object[0]))).a();
+    public static final Statistic L = (new CounterStatistic("stat.bannerCleaned", new ChatMessage("stat.bannerCleaned", new Object[0]))).a();
+    public static final Statistic M = (new CounterStatistic("stat.brewingstandInteraction", new ChatMessage("stat.brewingstandInteraction", new Object[0]))).a();
+    public static final Statistic N = (new CounterStatistic("stat.beaconInteraction", new ChatMessage("stat.beaconInteraction", new Object[0]))).a();
+    public static final Statistic O = (new CounterStatistic("stat.dropperInspected", new ChatMessage("stat.dropperInspected", new Object[0]))).a();
+    public static final Statistic P = (new CounterStatistic("stat.hopperInspected", new ChatMessage("stat.hopperInspected", new Object[0]))).a();
+    public static final Statistic Q = (new CounterStatistic("stat.dispenserInspected", new ChatMessage("stat.dispenserInspected", new Object[0]))).a();
+    public static final Statistic R = (new CounterStatistic("stat.noteblockPlayed", new ChatMessage("stat.noteblockPlayed", new Object[0]))).a();
+    public static final Statistic S = (new CounterStatistic("stat.noteblockTuned", new ChatMessage("stat.noteblockTuned", new Object[0]))).a();
+    public static final Statistic T = (new CounterStatistic("stat.flowerPotted", new ChatMessage("stat.flowerPotted", new Object[0]))).a();
+    public static final Statistic U = (new CounterStatistic("stat.trappedChestTriggered", new ChatMessage("stat.trappedChestTriggered", new Object[0]))).a();
+    public static final Statistic V = (new CounterStatistic("stat.enderchestOpened", new ChatMessage("stat.enderchestOpened", new Object[0]))).a();
+    public static final Statistic W = (new CounterStatistic("stat.itemEnchanted", new ChatMessage("stat.itemEnchanted", new Object[0]))).a();
+    public static final Statistic X = (new CounterStatistic("stat.recordPlayed", new ChatMessage("stat.recordPlayed", new Object[0]))).a();
+    public static final Statistic Y = (new CounterStatistic("stat.furnaceInteraction", new ChatMessage("stat.furnaceInteraction", new Object[0]))).a();
+    public static final Statistic Z = (new CounterStatistic("stat.craftingTableInteraction", new ChatMessage("stat.workbenchInteraction", new Object[0]))).a();
+    public static final Statistic aa = (new CounterStatistic("stat.chestOpened", new ChatMessage("stat.chestOpened", new Object[0]))).a();
+    public static final Statistic ab = (new CounterStatistic("stat.sleepInBed", new ChatMessage("stat.sleepInBed", new Object[0]))).a();
+    public static final Statistic ac = (new CounterStatistic("stat.shulkerBoxOpened", new ChatMessage("stat.shulkerBoxOpened", new Object[0]))).a();
+    private static final Statistic[] ad = new Statistic[4096];
+    private static final Statistic[] ae = new Statistic[32000];
+    private static final Statistic[] af = new Statistic[32000];
+    private static final Statistic[] ag = new Statistic[32000];
+    private static final Statistic[] ah = new Statistic[32000];
+    private static final Statistic[] ai = new Statistic[32000];
+
+    @Nullable
+    public static Statistic a(Block block) {
+        return StatisticList.ad[Block.getId(block)];
+    }
+
+    @Nullable
+    public static Statistic a(Item item) {
+        return StatisticList.ae[Item.getId(item)];
+    }
+
+    @Nullable
+    public static Statistic b(Item item) {
+        return StatisticList.af[Item.getId(item)];
+    }
+
+    @Nullable
+    public static Statistic c(Item item) {
+        return StatisticList.ag[Item.getId(item)];
+    }
+
+    @Nullable
+    public static Statistic d(Item item) {
+        return StatisticList.ah[Item.getId(item)];
+    }
+
+    @Nullable
+    public static Statistic e(Item item) {
+        return StatisticList.ai[Item.getId(item)];
+    }
+
+    public static void a() {
+        c();
+        d();
+        e();
+        b();
+        f();
+    }
+
+    private static void b() {
+        HashSet hashset = Sets.newHashSet();
+        Iterator iterator = CraftingManager.allRecipeIterator(); //OilSpigot iterate over all crafting managers
+
+        while (iterator.hasNext()) {
+            IRecipe irecipe = (IRecipe) iterator.next();
+            ItemStack itemstack = irecipe.b();
+
+            if (!itemstack.isEmpty()) {
+                hashset.add(irecipe.b().getItem());
+            }
+        }
+
+        iterator = RecipesFurnace.getInstance().getRecipes().values().iterator();
+
+        while (iterator.hasNext()) {
+            ItemStack itemstack1 = (ItemStack) iterator.next();
+
+            hashset.add(itemstack1.getItem());
+        }
+
+        iterator = hashset.iterator();
+
+        while (iterator.hasNext()) {
+            Item item = (Item) iterator.next();
+
+            if (item != null) {
+                int i = Item.getId(item);
+                String s = f(item);
+
+                if (s != null) {
+                    StatisticList.ae[i] = (new CraftingStatistic("stat.craftItem.", s, new ChatMessage("stat.craftItem", new Object[] { (new ItemStack(item)).C()}), item)).a();
+                }
+            }
+        }
+
+        a(StatisticList.ae);
+    }
+
+    private static void c() {
+        Iterator iterator = Block.REGISTRY.iterator();
+
+        while (iterator.hasNext()) {
+            Block block = (Block) iterator.next();
+            Item item = Item.getItemOf(block);
+
+            if (item != Items.a) {
+                int i = Block.getId(block);
+                String s = f(item);
+
+                if (s != null && block.o()) {
+                    StatisticList.ad[i] = (new CraftingStatistic("stat.mineBlock.", s, new ChatMessage("stat.mineBlock", new Object[] { (new ItemStack(block)).C()}), item)).a();
+                    StatisticList.e.add((CraftingStatistic) StatisticList.ad[i]);
+                }
+            }
+        }
+
+        a(StatisticList.ad);
+    }
+
+    private static void d() {
+        Iterator iterator = Item.REGISTRY.iterator();
+
+        while (iterator.hasNext()) {
+            Item item = (Item) iterator.next();
+
+            if (item != null) {
+                int i = Item.getId(item);
+                String s = f(item);
+
+                if (s != null) {
+                    StatisticList.af[i] = (new CraftingStatistic("stat.useItem.", s, new ChatMessage("stat.useItem", new Object[] { (new ItemStack(item)).C()}), item)).a();
+                    if (!(item instanceof ItemBlock)) {
+                        StatisticList.d.add((CraftingStatistic) StatisticList.af[i]);
+                    }
+                }
+            }
+        }
+
+        a(StatisticList.af);
+    }
+
+    private static void e() {
+        Iterator iterator = Item.REGISTRY.iterator();
+
+        while (iterator.hasNext()) {
+            Item item = (Item) iterator.next();
+
+            if (item != null) {
+                int i = Item.getId(item);
+                String s = f(item);
+
+                if (s != null && item.usesDurability()) {
+                    StatisticList.ag[i] = (new CraftingStatistic("stat.breakItem.", s, new ChatMessage("stat.breakItem", new Object[] { (new ItemStack(item)).C()}), item)).a();
+                }
+            }
+        }
+
+        a(StatisticList.ag);
+    }
+
+    private static void f() {
+        Iterator iterator = Item.REGISTRY.iterator();
+
+        while (iterator.hasNext()) {
+            Item item = (Item) iterator.next();
+
+            if (item != null) {
+                int i = Item.getId(item);
+                String s = f(item);
+
+                if (s != null) {
+                    StatisticList.ah[i] = (new CraftingStatistic("stat.pickup.", s, new ChatMessage("stat.pickup", new Object[] { (new ItemStack(item)).C()}), item)).a();
+                    StatisticList.ai[i] = (new CraftingStatistic("stat.drop.", s, new ChatMessage("stat.drop", new Object[] { (new ItemStack(item)).C()}), item)).a();
+                }
+            }
+        }
+
+        a(StatisticList.ag);
+    }
+
+    private static String f(Item item) {
+        MinecraftKey minecraftkey = (MinecraftKey) Item.REGISTRY.b(item);
+
+        return minecraftkey != null ? minecraftkey.toString().replace(':', '.') : null;
+    }
+
+    private static void a(Statistic[] astatistic) {
+        a(astatistic, Blocks.WATER, Blocks.FLOWING_WATER);
+        a(astatistic, Blocks.LAVA, Blocks.FLOWING_LAVA);
+        a(astatistic, Blocks.LIT_PUMPKIN, Blocks.PUMPKIN);
+        a(astatistic, Blocks.LIT_FURNACE, Blocks.FURNACE);
+        a(astatistic, Blocks.LIT_REDSTONE_ORE, Blocks.REDSTONE_ORE);
+        a(astatistic, Blocks.POWERED_REPEATER, Blocks.UNPOWERED_REPEATER);
+        a(astatistic, Blocks.POWERED_COMPARATOR, Blocks.UNPOWERED_COMPARATOR);
+        a(astatistic, Blocks.REDSTONE_TORCH, Blocks.UNLIT_REDSTONE_TORCH);
+        a(astatistic, Blocks.LIT_REDSTONE_LAMP, Blocks.REDSTONE_LAMP);
+        a(astatistic, Blocks.DOUBLE_STONE_SLAB, Blocks.STONE_SLAB);
+        a(astatistic, Blocks.DOUBLE_WOODEN_SLAB, Blocks.WOODEN_SLAB);
+        a(astatistic, Blocks.DOUBLE_STONE_SLAB2, Blocks.STONE_SLAB2);
+        a(astatistic, Blocks.GRASS, Blocks.DIRT);
+        a(astatistic, Blocks.FARMLAND, Blocks.DIRT);
+    }
+
+    private static void a(Statistic[] astatistic, Block block, Block block1) {
+        int i = Block.getId(block);
+        int j = Block.getId(block1);
+
+        if (astatistic[i] != null && astatistic[j] == null) {
+            astatistic[j] = astatistic[i];
+        } else {
+            StatisticList.stats.remove(astatistic[i]);
+            StatisticList.e.remove(astatistic[i]);
+            StatisticList.c.remove(astatistic[i]);
+            astatistic[i] = astatistic[j];
+        }
+    }
+
+    public static Statistic a(EntityTypes.MonsterEggInfo entitytypes_monsteregginfo) {
+        String s = EntityTypes.a(entitytypes_monsteregginfo.a);
+
+        return s == null ? null : (new Statistic("stat.killEntity." + s, new ChatMessage("stat.entityKill", new Object[] { new ChatMessage("entity." + s + ".name", new Object[0])}))).a();
+    }
+
+    public static Statistic b(EntityTypes.MonsterEggInfo entitytypes_monsteregginfo) {
+        String s = EntityTypes.a(entitytypes_monsteregginfo.a);
+
+        return s == null ? null : (new Statistic("stat.entityKilledBy." + s, new ChatMessage("stat.entityKilledBy", new Object[] { new ChatMessage("entity." + s + ".name", new Object[0])}))).a();
+    }
+
+    @Nullable
+    public static Statistic getStatistic(String s) {
+        return (Statistic) StatisticList.a.get(s);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/TileEntityBanner.java b/src/main/java/net/minecraft/server/TileEntityBanner.java
index f1670696..32058789 100644
--- a/src/main/java/net/minecraft/server/TileEntityBanner.java
+++ b/src/main/java/net/minecraft/server/TileEntityBanner.java
@@ -132,4 +132,12 @@ public class TileEntityBanner extends TileEntity implements INamableTileEntity {
 
         return nbttagcompound != null && nbttagcompound.hasKey("Base") ? EnumColor.fromInvColorIndex(nbttagcompound.getInt("Base")) : EnumColor.BLACK;
     }
+
+    //OilSpigot start
+    public static void setBaseColor(ItemStack itemstack, EnumColor enumcolor) {
+        NBTTagCompound nbttagcompound = itemstack.c("BlockEntityTag");
+
+        nbttagcompound.setInt("Base", enumcolor.getInvColorIndex());
+    }
+    //OilSpigot end
 }
diff --git a/src/main/java/net/minecraft/server/TileEntityFurnace.java b/src/main/java/net/minecraft/server/TileEntityFurnace.java
index 7a142810..40ddb5e5 100644
--- a/src/main/java/net/minecraft/server/TileEntityFurnace.java
+++ b/src/main/java/net/minecraft/server/TileEntityFurnace.java
@@ -234,7 +234,7 @@ public class TileEntityFurnace extends TileEntityContainer implements ITickable,
             if (flag != this.isBurning()) {
                 flag1 = true;
                 BlockFurnace.a(this.isBurning(), this.world, this.position);
-                this.invalidateBlockCache(); // CraftBukkit - Invalidate tile entity's cached block type 
+                this.invalidateBlockCache(); // CraftBukkit - Invalidate tile entity's cached block type
             }
         }
 
@@ -248,22 +248,28 @@ public class TileEntityFurnace extends TileEntityContainer implements ITickable,
         return 200;
     }
 
+    //OilSpigot start - made static to share code with OilInventoryFurnace
     private boolean canBurn() {
-        if (((ItemStack) this.items.get(0)).isEmpty()) {
+        return canBurn(this.items.get(0), this.items.get(2), getMaxStackSize());
+    }
+
+
+    public static boolean canBurn(ItemStack ore, ItemStack resultSlot, int maxStackSize) {
+        if (ore.isEmpty()) {
             return false;
         } else {
-            ItemStack itemstack = RecipesFurnace.getInstance().getResult((ItemStack) this.items.get(0));
+            ItemStack result = RecipesFurnace.getInstance().getResult(ore);
 
-            if (itemstack.isEmpty()) {
+            if (result.isEmpty()) {
                 return false;
             } else {
-                ItemStack itemstack1 = (ItemStack) this.items.get(2);
 
                 // CraftBukkit - consider resultant count instead of current count
-                return itemstack1.isEmpty() ? true : (!itemstack1.doMaterialsMatch(itemstack) ? false : (itemstack1.getCount() + itemstack.getCount() <= this.getMaxStackSize() && itemstack1.getCount() + itemstack.getCount() < itemstack1.getMaxStackSize() ? true : itemstack1.getCount() + itemstack.getCount() <= itemstack.getMaxStackSize()));
+                return resultSlot.isEmpty() ? true : (!resultSlot.doMaterialsMatch(result) ? false : (resultSlot.getCount() + result.getCount() <= maxStackSize && resultSlot.getCount() + result.getCount() < resultSlot.getMaxStackSize() ? true : resultSlot.getCount() + result.getCount() <= result.getMaxStackSize()));
             }
         }
     }
+    //OilSpigot end
 
     public void burn() {
         if (this.canBurn()) {
@@ -273,7 +279,7 @@ public class TileEntityFurnace extends TileEntityContainer implements ITickable,
 
             // CraftBukkit start - fire FurnaceSmeltEvent
             CraftItemStack source = CraftItemStack.asCraftMirror(itemstack);
-            org.bukkit.inventory.ItemStack result = CraftItemStack.asBukkitCopy(itemstack1);
+            org.bukkit.inventory.ItemStack result = CraftItemStack.asCraftMirror(itemstack1); //OilSpigot - use asCraftMirror
 
             FurnaceSmeltEvent furnaceSmeltEvent = new FurnaceSmeltEvent(this.world.getWorld().getBlockAt(position.getX(), position.getY(), position.getZ()), source, result);
             this.world.getServer().getPluginManager().callEvent(furnaceSmeltEvent);
diff --git a/src/main/java/net/minecraft/server/TileEntitySkull.java b/src/main/java/net/minecraft/server/TileEntitySkull.java
index dd266588..4fe71cf3 100644
--- a/src/main/java/net/minecraft/server/TileEntitySkull.java
+++ b/src/main/java/net/minecraft/server/TileEntitySkull.java
@@ -182,7 +182,7 @@ public class TileEntitySkull extends TileEntity /*implements ITickable*/ { // Pa
                 }
                 return false;
             }
-        }, false); 
+        }, false);
         // Spigot end
     }
 
diff --git a/src/main/java/net/minecraft/server/World.java b/src/main/java/net/minecraft/server/World.java
index bc231c7f..093d0d26 100644
--- a/src/main/java/net/minecraft/server/World.java
+++ b/src/main/java/net/minecraft/server/World.java
@@ -31,6 +31,7 @@ import org.bukkit.event.block.BlockCanBuildEvent;
 import org.bukkit.event.block.BlockPhysicsEvent;
 import org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;
 import org.bukkit.generator.ChunkGenerator;
+import org.oilmod.spigot.OilMain;
 // CraftBukkit end
 
 // Paper start
diff --git a/src/main/java/net/minecraft/server/WorldManager.java b/src/main/java/net/minecraft/server/WorldManager.java
index bfe003f6..eddae742 100644
--- a/src/main/java/net/minecraft/server/WorldManager.java
+++ b/src/main/java/net/minecraft/server/WorldManager.java
@@ -1,5 +1,7 @@
 package net.minecraft.server;
 
+import org.oilmod.spigot.items.RealItem;
+
 import java.util.Iterator;
 import javax.annotation.Nullable;
 
@@ -51,7 +53,16 @@ public class WorldManager implements IWorldAccess {
 
     public void a(EntityHuman entityhuman, int i, BlockPosition blockposition, int j) {
         // CraftBukkit - this.world.dimension
-        this.a.getPlayerList().sendPacketNearby(entityhuman, (double) blockposition.getX(), (double) blockposition.getY(), (double) blockposition.getZ(), 64.0D, this.world, new PacketPlayOutWorldEvent(i, blockposition, j, false));
+        //OilSpigot start send particles
+        PacketPlayOutWorldEvent packet = new PacketPlayOutWorldEvent(i, blockposition, j, false);
+
+        this.a.getPlayerList().sendPacketNearby(entityhuman, (double) blockposition.getX(), (double) blockposition.getY(), (double) blockposition.getZ(), 64.0D, this.world.dimension, packet);
+
+        //If we have a modded item also send to actor
+        if (entityhuman instanceof EntityPlayer &&  entityhuman.getItemInMainHand().getItem() instanceof RealItem) {
+            ((EntityPlayer) entityhuman).playerConnection.sendPacket(packet);
+        }
+        //OilSpigot end
     }
 
     public void a(int i, BlockPosition blockposition, int j) {
@@ -67,6 +78,10 @@ public class WorldManager implements IWorldAccess {
         if (entity instanceof EntityHuman) entityhuman = (EntityHuman) entity;
         // CraftBukkit end
 
+        //OilSpigot start
+        boolean isModItem = entityhuman!=null&&entityhuman.getItemInMainHand().getItem() instanceof RealItem;
+        //OilSpigot end
+
         // Paper start
         java.util.List<? extends EntityHuman> list = entity != null ? entity.world.players : this.a.getPlayerList().v();
         Iterator<? extends EntityHuman> iterator = list.iterator();
@@ -76,7 +91,8 @@ public class WorldManager implements IWorldAccess {
             EntityPlayer entityplayer = (EntityPlayer) human;
             // Paper end
 
-            if (entityplayer != null && entityplayer.world == this.world && entityplayer.getId() != i) {
+            //OilSpigot send anyway if mod item
+            if (entityplayer != null && entityplayer.world == this.world && (isModItem ||entityplayer.getId() != i)) {
                 double d0 = (double) blockposition.getX() - entityplayer.locX;
                 double d1 = (double) blockposition.getY() - entityplayer.locY;
                 double d2 = (double) blockposition.getZ() - entityplayer.locZ;
diff --git a/src/main/java/net/minecraft/server/oilmod/ICraftingContainer.java b/src/main/java/net/minecraft/server/oilmod/ICraftingContainer.java
new file mode 100644
index 00000000..b391a215
--- /dev/null
+++ b/src/main/java/net/minecraft/server/oilmod/ICraftingContainer.java
@@ -0,0 +1,6 @@
+package net.minecraft.server.oilmod;
+
+public interface ICraftingContainer {
+    IInventoryCrafting getCraftingInventory();
+    IInventoryCraftResult getResultInventory();
+}
diff --git a/src/main/java/net/minecraft/server/oilmod/IInventoryCraftResult.java b/src/main/java/net/minecraft/server/oilmod/IInventoryCraftResult.java
new file mode 100644
index 00000000..397f739e
--- /dev/null
+++ b/src/main/java/net/minecraft/server/oilmod/IInventoryCraftResult.java
@@ -0,0 +1,11 @@
+package net.minecraft.server.oilmod;
+
+import net.minecraft.server.IInventory;
+import net.minecraft.server.IRecipe;
+
+import javax.annotation.Nullable;
+
+public interface IInventoryCraftResult extends IInventory {
+    void a(@Nullable IRecipe irecipe);//setRecipe
+    IRecipe i(); //getRecipe
+}
diff --git a/src/main/java/net/minecraft/server/oilmod/IInventoryCrafting.java b/src/main/java/net/minecraft/server/oilmod/IInventoryCrafting.java
new file mode 100644
index 00000000..66356694
--- /dev/null
+++ b/src/main/java/net/minecraft/server/oilmod/IInventoryCrafting.java
@@ -0,0 +1,42 @@
+package net.minecraft.server.oilmod;
+
+import net.minecraft.server.AutoRecipeStackManager;
+import net.minecraft.server.BukkitIInventory;
+import net.minecraft.server.Container;
+import net.minecraft.server.CraftingManager;
+import net.minecraft.server.IInventory;
+import net.minecraft.server.IRecipe;
+import net.minecraft.server.ItemStack;
+import org.bukkit.craftbukkit.inventory.CraftInventoryCrafting;
+import org.bukkit.event.inventory.InventoryType;
+import org.bukkit.inventory.InventoryView;
+
+import java.util.Iterator;
+
+//OilSpigot start - KEEPSYNC with InventoryCrafting.java
+public interface IInventoryCrafting extends BukkitIInventory {
+    void setCurrentRecipe(IRecipe currentRecipe);
+    IRecipe getCurrentRecipe();
+    IInventory getResultInventory();
+    void setResultInventory(IInventory resultInventory);
+    int j(); //width
+    int i(); //height
+    default int getWidth() {
+        return j();
+    }
+    default int getHeigth() {
+        return i();
+    }
+    ItemStack c(int left, int top);
+    void setItem(int left, int top, ItemStack itemStack, boolean update);
+    void updateResult();
+    InventoryType getInvType();
+    CraftInventoryCrafting getBukkitInventory();
+
+    CraftingManager getCraftingManager();
+
+    Container getContainer();
+
+    void a(AutoRecipeStackManager autorecipestackmanager);
+}
+/*OilSpigot stop*/
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index 7c82e18b..204e3355 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -1183,7 +1183,7 @@ public final class CraftServer implements Server {
 
     @Override
     public void clearRecipes() {
-        CraftingManager.recipes = new RegistryMaterials();
+        CraftingManager.getInstance().clear(); //OilSpigot - Use own clear method
         RecipesFurnace.getInstance().recipes.clear();
         RecipesFurnace.getInstance().customRecipes.clear();
         RecipesFurnace.getInstance().customExperience.clear();
@@ -1191,9 +1191,11 @@ public final class CraftServer implements Server {
 
     @Override
     public void resetRecipes() {
-        CraftingManager.recipes = new RegistryMaterials();
-        CraftingManager.init();
+        //OilSpigot start
+        clearRecipes();
+        CraftingManager.initVanilla(CraftingManager.getInstance());
         RecipesFurnace.getInstance().recipes = new RecipesFurnace().recipes;
+        //OilSpigot end
         RecipesFurnace.getInstance().customRecipes.clear();
         RecipesFurnace.getInstance().customExperience.clear();
     }
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CraftBlock.java b/src/main/java/org/bukkit/craftbukkit/block/CraftBlock.java
index a9d3f12b..9ee44698 100644
--- a/src/main/java/org/bukkit/craftbukkit/block/CraftBlock.java
+++ b/src/main/java/org/bukkit/craftbukkit/block/CraftBlock.java
@@ -37,7 +37,7 @@ public class CraftBlock implements Block {
         this.chunk = chunk;
     }
 
-    private net.minecraft.server.Block getNMSBlock() {
+    public net.minecraft.server.Block getNMSBlock() { //OilSpigot - PAIL private -> public
         return CraftMagicNumbers.getBlock(this); // TODO: UPDATE THIS
     }
 
@@ -513,7 +513,7 @@ public class CraftBlock implements Block {
                             nmsStack.getTag().set("SkullOwner", nbttagcompound);
                         }
 
-                        drops.add(CraftItemStack.asBukkitCopy(nmsStack));
+                        drops.add(CraftItemStack.asCraftMirror(nmsStack)); //OilSpigot - use asCraftMirror
                         // We don't want to drop cocoa blocks, we want to drop cocoa beans.
                     } else if (Blocks.COCOA == block) {
                         int age = (Integer) data.get(BlockCocoa.AGE);
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CraftFlowerPot.java b/src/main/java/org/bukkit/craftbukkit/block/CraftFlowerPot.java
index c9097ac8..9ed48329 100644
--- a/src/main/java/org/bukkit/craftbukkit/block/CraftFlowerPot.java
+++ b/src/main/java/org/bukkit/craftbukkit/block/CraftFlowerPot.java
@@ -24,7 +24,8 @@ public class CraftFlowerPot extends CraftBlockEntityState<TileEntityFlowerPot> i
     public void load(TileEntityFlowerPot pot) {
         super.load(pot);
 
-        contents = (pot.getItem() == null) ? null : CraftItemStack.asBukkitCopy(pot.getContents()).getData();
+        //OilSpigot use asCraftMirror
+        contents = (pot.getItem() == null) ? null : CraftItemStack.asCraftMirror(pot.getContents()).getData();
     }
 
     @Override
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftAbstractHorse.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftAbstractHorse.java
index cc9d432e..6fea5d1f 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftAbstractHorse.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftAbstractHorse.java
@@ -1,6 +1,7 @@
 package org.bukkit.craftbukkit.entity;
 
 import java.util.UUID;
+
 import net.minecraft.server.EntityHorse;
 import net.minecraft.server.EntityHorseAbstract;
 import org.apache.commons.lang.Validate;
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
index 47edc049..4d449452 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
@@ -220,6 +220,7 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
         else if (entity instanceof EntityEvokerFangs) { return new CraftEvokerFangs(server, (EntityEvokerFangs) entity); }
         else if (entity instanceof EntityLlamaSpit) { return new CraftLlamaSpit(server, (EntityLlamaSpit) entity); }
 
+        //OilSpigot TODO: if we ever allow custom entities we need catch this here or above the block
         throw new AssertionError("Unknown entity " + (entity == null ? null : entity.getClass()));
     }
 
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftHumanEntity.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftHumanEntity.java
index 05ca403e..ffd90512 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftHumanEntity.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftHumanEntity.java
@@ -34,6 +34,12 @@ import org.bukkit.permissions.PermissionAttachment;
 import org.bukkit.permissions.PermissionAttachmentInfo;
 import org.bukkit.plugin.Plugin;
 
+//OilSpigot start
+import org.oilmod.spigot.inventory.OilInventoryChest;
+import org.oilmod.spigot.inventory.OilInventoryFurnace;
+import org.oilmod.spigot.inventory.OilInventoryPortableCrafting;
+//OilSpigot end
+
 public class CraftHumanEntity extends CraftLivingEntity implements HumanEntity {
     private CraftInventoryPlayer inventory;
     private final CraftInventory enderChest;
@@ -211,12 +217,22 @@ public class CraftHumanEntity extends CraftLivingEntity implements HumanEntity {
             case FURNACE:
                 if (iinventory instanceof TileEntityFurnace) {
                     getHandle().openContainer((TileEntityFurnace) iinventory);
+                    //OilSpigot start
+                } else if (iinventory instanceof OilInventoryFurnace) {
+                    getHandle().openContainer((OilInventoryFurnace) iinventory);
+                    //OilSpigot end
                 } else {
                     openCustomInventory(inventory, player, "minecraft:furnace");
                 }
                 break;
             case WORKBENCH:
-                openCustomInventory(inventory, player, "minecraft:crafting_table");
+                //OilSpigot start
+                if (iinventory instanceof OilInventoryPortableCrafting) {
+                    getHandle().openTileEntity((OilInventoryPortableCrafting) iinventory);
+                } else {
+                    openCustomInventory(inventory, player, "minecraft:crafting_table");
+                }
+                //OilSpigot end
                 break;
             case BREWING:
                 if (iinventory instanceof TileEntityBrewingStand) {
@@ -233,6 +249,8 @@ public class CraftHumanEntity extends CraftLivingEntity implements HumanEntity {
                     getHandle().openContainer((TileEntityHopper) iinventory);
                 } else if (iinventory instanceof EntityMinecartHopper) {
                     getHandle().openContainer((EntityMinecartHopper) iinventory);
+                } else if (iinventory instanceof OilInventoryChest) {
+                    getHandle().openContainer((OilInventoryChest) iinventory);
                 } else {
                     openCustomInventory(inventory, player, "minecraft:hopper");
                 }
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftItemFrame.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftItemFrame.java
index 95647efc..227fb806 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftItemFrame.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftItemFrame.java
@@ -52,7 +52,7 @@ public class CraftItemFrame extends CraftHanging implements ItemFrame {
     }
 
     public org.bukkit.inventory.ItemStack getItem() {
-        return CraftItemStack.asBukkitCopy(getHandle().getItem());
+        return CraftItemStack.asCraftMirror(getHandle().getItem()); //OilSpigot - use asCraftMirror
     }
 
     public Rotation getRotation() {
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftThrownPotion.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftThrownPotion.java
index b1953993..805a1917 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftThrownPotion.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftThrownPotion.java
@@ -1,21 +1,17 @@
 package org.bukkit.craftbukkit.entity;
 
-import java.util.Collection;
+import com.google.common.collect.ImmutableList;
 import net.minecraft.server.EntityPotion;
 import net.minecraft.server.MobEffect;
 import net.minecraft.server.PotionUtil;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.Material;
 import org.bukkit.craftbukkit.CraftServer;
 import org.bukkit.craftbukkit.inventory.CraftItemStack;
 import org.bukkit.craftbukkit.potion.CraftPotionUtil;
-import org.bukkit.entity.EntityType;
 import org.bukkit.entity.ThrownPotion;
 import org.bukkit.inventory.ItemStack;
 import org.bukkit.potion.PotionEffect;
 
-import com.google.common.collect.ImmutableList;
+import java.util.Collection;
 
 public abstract class CraftThrownPotion extends CraftProjectile implements ThrownPotion {
     public CraftThrownPotion(CraftServer server, EntityPotion entity) {
@@ -31,8 +27,8 @@ public abstract class CraftThrownPotion extends CraftProjectile implements Throw
     }
 
     public ItemStack getItem() {
-        return CraftItemStack.asBukkitCopy(getHandle().getItem());
-    }
+        return CraftItemStack.asCraftMirror(getHandle().getItem());
+    } //OilSpigot - use asCraftMirror
 
     @Override
     public EntityPotion getHandle() {
diff --git a/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java b/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
index f1a3ca95..c85534c5 100644
--- a/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
+++ b/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
@@ -12,6 +12,7 @@ import com.google.common.base.Functions;
 
 import net.minecraft.server.*;
 
+import net.minecraft.server.oilmod.IInventoryCrafting;
 import org.bukkit.Bukkit;
 import org.bukkit.Material;
 import org.bukkit.Server;
@@ -68,6 +69,10 @@ import org.bukkit.entity.AbstractHorse;
 import org.bukkit.entity.Vehicle;
 import org.bukkit.event.vehicle.VehicleCreateEvent;
 
+/*OilSpigot start*/
+import org.oilmod.spigot.items.itemstackimpl.internal.ModItemStack;
+/*OilSpigot end*/
+
 public class CraftEventFactory {
     public static final DamageSource MELTING = CraftDamageSource.copyOf(DamageSource.BURN);
     public static final DamageSource POISON = CraftDamageSource.copyOf(DamageSource.MAGIC);
@@ -233,8 +238,35 @@ public class CraftEventFactory {
         if (cancelledBlock) {
             event.setUseInteractedBlock(Event.Result.DENY);
         }
+        //OilSpigot start
+        if (event.isCancelled() && itemstack != null && itemstack instanceof ModItemStack) {
+            event.setCancelled(false);
+        }
+        //OilSpigot end
+
         craftServer.getPluginManager().callEvent(event);
 
+
+        //OilSpigot start
+        if ((!event.isCancelled() || cancelledBlock) && itemstack != null && itemstack instanceof ModItemStack) {
+            ModItemStack modItemStack = (ModItemStack) itemstack;
+            boolean handled = false;
+            if (action == Action.RIGHT_CLICK_AIR || action == Action.RIGHT_CLICK_BLOCK) {
+                handled = modItemStack.onUse(who, action);
+            }
+            if (action == Action.RIGHT_CLICK_BLOCK) {
+                handled |= modItemStack.onUseOnBlock(who, action, position, direction);
+            }
+            if (action == Action.LEFT_CLICK_AIR || action == Action.LEFT_CLICK_BLOCK) {
+                handled |= modItemStack.onLeftClick(who, action);
+            }
+            if (action == Action.LEFT_CLICK_BLOCK) {
+                handled |= modItemStack.onLeftClickOnBlock(who, action, position, direction);
+            }
+            event.setCancelled(handled || event.isCancelled());
+            //TODO: do this at a better location! / Do not abuse bukkit code for it
+        }
+        //OilSpigot end
         return event;
     }
 
@@ -832,8 +864,10 @@ public class CraftEventFactory {
         return container;
     }
 
-    public static ItemStack callPreCraftEvent(InventoryCrafting matrix, ItemStack result, InventoryView lastCraftView, boolean isRepair) {
-        CraftInventoryCrafting inventory = new CraftInventoryCrafting(matrix, matrix.resultInventory);
+    //OilSpigot start -  InventoryCrafting -> IInventoryCrafting
+    public static ItemStack callPreCraftEvent(IInventoryCrafting matrix, ItemStack result, InventoryView lastCraftView, boolean isRepair) {
+        CraftInventoryCrafting inventory = new CraftInventoryCrafting(matrix, matrix.getResultInventory());
+        //OilSpigot end
         inventory.setResult(CraftItemStack.asCraftMirror(result));
 
         PrepareItemCraftEvent event = new PrepareItemCraftEvent(inventory, lastCraftView, isRepair);
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftEntityEquipment.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftEntityEquipment.java
index 3ed9e2bb..795fd06d 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftEntityEquipment.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftEntityEquipment.java
@@ -96,7 +96,7 @@ public class CraftEntityEquipment implements EntityEquipment {
     }
 
     private ItemStack getEquipment(EnumItemSlot slot) {
-        return CraftItemStack.asBukkitCopy(entity.getHandle().getEquipment(slot));
+        return CraftItemStack.asCraftMirror(entity.getHandle().getEquipment(slot)); //OilSpigot - use asCraftMirror
     }
 
     private void setEquipment(EnumItemSlot slot, ItemStack stack) {
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftInventoryCrafting.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftInventoryCrafting.java
index 0f0dd199..336a1869 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftInventoryCrafting.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftInventoryCrafting.java
@@ -5,16 +5,19 @@ import java.util.List;
 
 import net.minecraft.server.IRecipe;
 import net.minecraft.server.IInventory;
-import net.minecraft.server.InventoryCrafting;
 
 import org.bukkit.inventory.CraftingInventory;
 import org.bukkit.inventory.ItemStack;
 import org.bukkit.inventory.Recipe;
 
+//OilSpigot start
+import net.minecraft.server.oilmod.IInventoryCrafting;
+//OilSpigot end
+
 public class CraftInventoryCrafting extends CraftInventory implements CraftingInventory {
     private final IInventory resultInventory;
 
-    public CraftInventoryCrafting(InventoryCrafting inventory, IInventory resultInventory) {
+    public CraftInventoryCrafting(IInventoryCrafting inventory, IInventory resultInventory) {//OilSpigot changed from InventoryCrafting to IInventoryCrafting
         super(inventory);
         this.resultInventory = resultInventory;
     }
@@ -34,10 +37,15 @@ public class CraftInventoryCrafting extends CraftInventory implements CraftingIn
 
     @Override
     public void setContents(ItemStack[] items) {
+        //OilSpigot start
+        int resultLen = getResultInventory().getSize(); //OilSpigot - using getSize()
+        int len = getMatrixInventory().getSize() + resultLen; //OilSpigot - using getSize()
         if (getSize() > items.length) {
-            throw new IllegalArgumentException("Invalid inventory size; expected " + getSize() + " or less");
+            throw new IllegalArgumentException("Invalid inventory size; expected " + len + " or less");
         }
-        setContents(items[0], Arrays.copyOfRange(items, 1, items.length));
+
+        setContents(items[0], Arrays.copyOfRange(items, resultLen, items.length)); //OilSpigot - using resultLen
+        /*OilSpigot stop*/
     }
 
     @Override
@@ -45,16 +53,18 @@ public class CraftInventoryCrafting extends CraftInventory implements CraftingIn
         ItemStack[] items = new ItemStack[getSize()];
         List<net.minecraft.server.ItemStack> mcResultItems = getResultInventory().getContents();
 
+        //OilSpigot start
         int i = 0;
-        for (i = 0; i < mcResultItems.size(); i++ ) {
+        for (i = 0; i < getResultInventory().getSize(); i++ ) {
             items[i] = CraftItemStack.asCraftMirror(mcResultItems.get(i));
         }
 
         List<net.minecraft.server.ItemStack> mcItems = getMatrixInventory().getContents();
 
-        for (int j = 0; j < mcItems.size(); j++) {
+        for (int j = 0; j < getMatrixInventory().getSize(); j++) {
             items[i + j] = CraftItemStack.asCraftMirror(mcItems.get(j));
         }
+        /*OilSpigot stop*/
 
         return items;
     }
@@ -116,7 +126,9 @@ public class CraftInventoryCrafting extends CraftInventory implements CraftingIn
     }
 
     public Recipe getRecipe() {
-        IRecipe recipe = ((InventoryCrafting)getInventory()).currentRecipe;
+        //OilSpigot start
+        IRecipe recipe = ((IInventoryCrafting)getInventory()).getCurrentRecipe();
+        /*OilSpigot stop*/
         return recipe == null ? null : recipe.toBukkitRecipe();
     }
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemStack.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemStack.java
index decdccdc..cbb26f65 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemStack.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemStack.java
@@ -12,6 +12,7 @@ import net.minecraft.server.Item;
 import net.minecraft.server.NBTTagCompound;
 import net.minecraft.server.NBTTagList;
 
+import net.minecraft.server.NonNullList;
 import org.apache.commons.lang.Validate;
 import org.bukkit.Material;
 import org.bukkit.configuration.serialization.DelegateDeserialization;
@@ -23,8 +24,12 @@ import org.bukkit.inventory.meta.ItemMeta;
 import com.google.common.collect.ImmutableMap;
 import org.bukkit.craftbukkit.enchantments.CraftEnchantment;
 
+//OilSpigot start
+import org.oilmod.spigot.items.RealItemStack;
+//OilSpigot end
+
 @DelegateDeserialization(ItemStack.class)
-public final class CraftItemStack extends ItemStack {
+public  class CraftItemStack extends ItemStack { //OilSpigot PAIL removed final
 
     public static net.minecraft.server.ItemStack asNMSCopy(ItemStack original) {
         if (original instanceof CraftItemStack) {
@@ -57,9 +62,10 @@ public final class CraftItemStack extends ItemStack {
         return stack;
     }
 
+    /* -- OilSpigot removed //TODO: when the new item implementation is there this might be useful again. Revert then
     /**
      * Copies the NMS stack to return as a strictly-Bukkit stack
-     */
+     *-/
     public static ItemStack asBukkitCopy(net.minecraft.server.ItemStack original) {
         if (original.isEmpty()) {
             return new ItemStack(Material.AIR);
@@ -69,16 +75,34 @@ public final class CraftItemStack extends ItemStack {
             stack.setItemMeta(getItemMeta(original));
         }
         return stack;
+    }*/ //OilSpigot end
+
+    //OilSpigot start
+    public static ItemStack[] asCraftMirrorArray(NonNullList<net.minecraft.server.ItemStack> original) {
+        ItemStack[] result = new ItemStack[original.size()];
+        for (int i=0;i<result.length;i++) {
+            result[i] = asCraftMirror(original.get(i));
+        }
+        return result;
     }
+    //OilSpigot end
 
     public static CraftItemStack asCraftMirror(net.minecraft.server.ItemStack original) {
+        //OilSpigot start - !=null only needed because bukkit still allows null nms handles even tho nms forbids them.
+        if (original != null && !original.isEmpty() && original instanceof RealItemStack) {
+            RealItemStack modItemStack = (RealItemStack) original;
+            return modItemStack.asCraftItemStack();
+        }
+        //OilSpigot end
         return new CraftItemStack((original == null || original.isEmpty()) ? null : original);
     }
 
     public static CraftItemStack asCraftCopy(ItemStack original) {
         if (original instanceof CraftItemStack) {
             CraftItemStack stack = (CraftItemStack) original;
-            return new CraftItemStack(stack.handle == null ? null : stack.handle.cloneItemStack());
+            //OilSpigot start
+            return asCraftMirror((stack.handle == null || stack.handle.isEmpty()) ? null : stack.handle.cloneItemStack());
+            //OilSpigot end
         }
         return new CraftItemStack(original);
     }
@@ -93,10 +117,16 @@ public final class CraftItemStack extends ItemStack {
 
     net.minecraft.server.ItemStack handle;
 
+    //OilSpigot start
+    public net.minecraft.server.ItemStack getHandle() {
+        return handle;
+    }
+    //OilSpigot end
+
     /**
      * Mirror
      */
-    private CraftItemStack(net.minecraft.server.ItemStack item) {
+    protected CraftItemStack(net.minecraft.server.ItemStack item) { //OilSpigot Pail private to protected
         this.handle = item;
     }
 
@@ -392,6 +422,25 @@ public final class CraftItemStack extends ItemStack {
         return true;
     }
 
+
+    //OilSpigot start
+    public static boolean setItemMeta(NBTTagCompound tag, Material material, ItemMeta itemMeta) {
+        if (CraftItemFactory.instance().equals(itemMeta, null)) {
+            return true;
+        }
+        if (!CraftItemFactory.instance().isApplicable(itemMeta, material)) {
+            return false;
+        }
+
+        itemMeta = CraftItemFactory.instance().asMetaFor(itemMeta, material);
+        if (itemMeta == null) return true;
+
+        ((CraftMetaItem) itemMeta).applyToItem(tag);
+
+        return true;
+    }
+    //OilSpigot end
+
     @Override
     public boolean isSimilar(ItemStack stack) {
         if (stack == null) {
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMerchantRecipe.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMerchantRecipe.java
index 2c51fd8b..bbc327b5 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMerchantRecipe.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMerchantRecipe.java
@@ -1,19 +1,22 @@
 package org.bukkit.craftbukkit.inventory;
 
 import com.google.common.base.Preconditions;
-import java.util.List;
 import org.bukkit.inventory.ItemStack;
 import org.bukkit.inventory.MerchantRecipe;
 
+import java.util.List;
+
 public class CraftMerchantRecipe extends MerchantRecipe {
 
     private final net.minecraft.server.MerchantRecipe handle;
 
     public CraftMerchantRecipe(net.minecraft.server.MerchantRecipe merchantRecipe) {
-        super(CraftItemStack.asBukkitCopy(merchantRecipe.sellingItem), 0);
+        //OilSpigot start - use asCraftMirror
+        super(CraftItemStack.asCraftMirror(merchantRecipe.sellingItem), 0);
         this.handle = merchantRecipe;
-        addIngredient(CraftItemStack.asBukkitCopy(merchantRecipe.buyingItem1));
-        addIngredient(CraftItemStack.asBukkitCopy(merchantRecipe.buyingItem2));
+        addIngredient(CraftItemStack.asCraftMirror(merchantRecipe.buyingItem1));
+        addIngredient(CraftItemStack.asCraftMirror(merchantRecipe.buyingItem2));
+        //OilSpigot end
     }
 
     public CraftMerchantRecipe(ItemStack result, int uses, int maxUses, boolean experienceReward) {
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftShapedRecipe.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftShapedRecipe.java
index 44df9301..61ac8533 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftShapedRecipe.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftShapedRecipe.java
@@ -21,7 +21,7 @@ public class CraftShapedRecipe extends ShapedRecipe implements CraftRecipe {
     }
 
     public CraftShapedRecipe(ItemStack result, ShapedRecipes recipe) {
-        this(CraftNamespacedKey.fromMinecraft(recipe.key), result);
+        this(CraftNamespacedKey.fromMinecraft(recipe.getKey()), result); //OilSpigot use getKey
         this.recipe = recipe;
     }
 
@@ -55,6 +55,7 @@ public class CraftShapedRecipe extends ShapedRecipe implements CraftRecipe {
             }
         }
 
-        CraftingManager.a(CraftNamespacedKey.toMinecraft(this.getKey()), new ShapedRecipes("", width, shape.length, data, CraftItemStack.asNMSCopy(this.getResult())));
+        //OilSpigot use registerRecipe instead of a()
+        CraftingManager.registerRecipe(CraftNamespacedKey.toMinecraft(this.getKey()), new ShapedRecipes("", width, shape.length, data, CraftItemStack.asNMSCopy(this.getResult())));
     }
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftShapelessRecipe.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftShapelessRecipe.java
index 211898c5..1bbfbfa5 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftShapelessRecipe.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftShapelessRecipe.java
@@ -21,7 +21,8 @@ public class CraftShapelessRecipe extends ShapelessRecipe implements CraftRecipe
     }
 
     public CraftShapelessRecipe(ItemStack result, ShapelessRecipes recipe) {
-        this(CraftNamespacedKey.fromMinecraft(recipe.key), result);
+        //OilSpigot use getkey
+        this(CraftNamespacedKey.fromMinecraft(recipe.getKey()), result);
         this.recipe = recipe;
     }
 
@@ -43,6 +44,7 @@ public class CraftShapelessRecipe extends ShapelessRecipe implements CraftRecipe
             data.set(i, RecipeItemStack.a(new net.minecraft.server.ItemStack[]{CraftItemStack.asNMSCopy(ingred.get(i))}));
         }
 
-        CraftingManager.a(CraftNamespacedKey.toMinecraft(this.getKey()), new ShapelessRecipes("", CraftItemStack.asNMSCopy(this.getResult()), data));
+        //OilSpigot use registerRecipe instead of a()
+        CraftingManager.registerRecipe(CraftNamespacedKey.toMinecraft(this.getKey()), new ShapelessRecipes("", CraftItemStack.asNMSCopy(this.getResult()), data));
     }
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/InventoryWrapper.java b/src/main/java/org/bukkit/craftbukkit/inventory/InventoryWrapper.java
index 6cbcc9d3..20e73847 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/InventoryWrapper.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/InventoryWrapper.java
@@ -73,7 +73,7 @@ public class InventoryWrapper implements IInventory {
 
     @Override
     public void setItem(int i, ItemStack itemstack) {
-        inventory.setItem(i, CraftItemStack.asBukkitCopy(itemstack));
+        inventory.setItem(i, CraftItemStack.asCraftMirror(itemstack));  //OilSpigot - use asCraftMirror
     }
 
     @Override
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/RecipeIterator.java b/src/main/java/org/bukkit/craftbukkit/inventory/RecipeIterator.java
index f03f8baa..d69e1dab 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/RecipeIterator.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/RecipeIterator.java
@@ -9,25 +9,32 @@ import net.minecraft.server.IRecipe;
 import net.minecraft.server.RecipesFurnace;
 
 public class RecipeIterator implements Iterator<Recipe> {
-    private final Iterator<IRecipe> recipes;
+    //OilSpigot start
+    private final Iterator<CraftingManager> craftingManagers;
+    private Iterator<IRecipe> recipesCurrent;
+    //OilSpigot end
     private final Iterator<net.minecraft.server.ItemStack> smeltingCustom;
     private final Iterator<net.minecraft.server.ItemStack> smeltingVanilla;
     private Iterator<?> removeFrom = null;
 
     public RecipeIterator() {
-        this.recipes = CraftingManager.recipes.iterator();
+        this.craftingManagers = CraftingManager.REGISTERED_CRAFTING_MANAGERS.iterator(); //OilSpigot
+        this.recipesCurrent = craftingManagers.next().recipeIterator();
         this.smeltingCustom = RecipesFurnace.getInstance().customRecipes.keySet().iterator();
         this.smeltingVanilla = RecipesFurnace.getInstance().recipes.keySet().iterator();
     }
 
     public boolean hasNext() {
-        return recipes.hasNext() || smeltingCustom.hasNext() || smeltingVanilla.hasNext();
+        return (!recipesCurrent.hasNext() && craftingManagers.hasNext()) || recipesCurrent.hasNext() || smeltingCustom.hasNext() || smeltingVanilla.hasNext();
     }
 
     public Recipe next() {
-        if (recipes.hasNext()) {
-            removeFrom = recipes;
-            return recipes.next().toBukkitRecipe();
+        //OilSpigot start
+        if (recipesCurrent.hasNext() || craftingManagers.hasNext()) {
+            if (!recipesCurrent.hasNext()) recipesCurrent = craftingManagers.next().recipeIterator();
+            removeFrom = recipesCurrent;
+            return recipesCurrent.next().toBukkitRecipe();
+            //OilSpigot end
         } else {
             net.minecraft.server.ItemStack item;
             if (smeltingCustom.hasNext()) {
diff --git a/src/main/java/org/oilmod/ApiOilMod.java b/src/main/java/org/oilmod/ApiOilMod.java
new file mode 100644
index 00000000..ea6babe9
--- /dev/null
+++ b/src/main/java/org/oilmod/ApiOilMod.java
@@ -0,0 +1,16 @@
+package org.oilmod;
+
+/**
+ * Created by sirati97 on 22.03.2016.
+ */
+public class ApiOilMod { //TODO delete
+    private String name;
+
+    public ApiOilMod(String name) {
+        this.name = name;
+    }
+
+    public String getName() {
+        return name;
+    }
+}
diff --git a/src/main/java/org/oilmod/oilclient/ConnectionManager.java b/src/main/java/org/oilmod/oilclient/ConnectionManager.java
new file mode 100644
index 00000000..ba9dbc41
--- /dev/null
+++ b/src/main/java/org/oilmod/oilclient/ConnectionManager.java
@@ -0,0 +1,51 @@
+package org.oilmod.oilclient;
+
+
+/**
+ * Created by sirati97 on 15.03.2016.
+ */
+/*public class ConnectionManager implements PacketHandler {
+    public static final ConnectionManager INSTANCE;
+    public static final PacketCollection ROOT;
+    public static final TestPacket TEST_PACKET;
+
+    static {
+        INSTANCE = new ConnectionManager();
+        ROOT = new PacketCollection(INSTANCE);
+        TEST_PACKET = null;//new TestPacket((short)0, ROOT);
+    }
+    private Map<UUID, OilConnection> connections = new THashMap<>();
+    private AsyncHelper asyncHelper = new ThreadPoolAsyncHelper();
+
+    private ConnectionManager(){}
+
+    public OilConnection registerConnection(EntityPlayer entityPlayer) {
+        if (connections.get(entityPlayer.getUniqueID())!=null) {
+            return null;
+        }
+        OilConnection connection = new OilConnection(entityPlayer, asyncHelper);
+        connections.put(entityPlayer.getUniqueID(), connection);
+        return connection;
+    }
+
+
+    public void unregisterConnection(EntityPlayer entityPlayer) {
+        connections.remove(entityPlayer.getUniqueID());
+    }
+
+    public void executeInput(EntityPlayer entityPlayer, byte[] in) {
+        OilConnection connection = connections.get(entityPlayer.getUniqueID());
+        if (connection==null) {
+            throw new IllegalStateException("Received message without being handshaked to a OilClient. Player: name="+entityPlayer.getDisplayName() + ", uuid="+entityPlayer.getUniqueID().toString());
+        }
+        connection.read(in, 0);
+    }
+
+    @Override
+    public void execute(ReceivedPacket packet) {
+        if(packet.checkPacket(TestPacket.class)) {
+            System.out.println(packet.get(0));
+        }
+    }
+}
+*/
\ No newline at end of file
diff --git a/src/main/java/org/oilmod/oilclient/IOHandlerPlayer.java b/src/main/java/org/oilmod/oilclient/IOHandlerPlayer.java
new file mode 100644
index 00000000..386fad1b
--- /dev/null
+++ b/src/main/java/org/oilmod/oilclient/IOHandlerPlayer.java
@@ -0,0 +1,40 @@
+package org.oilmod.oilclient;
+
+
+/**
+ * Created by sirati97 on 15.03.2016.
+ */
+/*public class IOHandlerPlayer extends IOHandlerBase {
+    private EntityPlayer entityPlayer;
+
+    public IOHandlerPlayer(EntityPlayer entityPlayer) {
+        this.entityPlayer = entityPlayer;
+    }
+
+
+    @Override
+    protected void sendInternal(byte[] bytes, boolean b) throws IOException {
+        OilMain.sendUnregisteredPluginMessage(entityPlayer, "MAIN", bytes);
+    }
+
+    @Override
+    protected boolean isIOOpen() {
+        return true;
+    }
+
+    @Override
+    protected void closeIO() throws IOException {
+
+    }
+
+    @Override
+    protected void onClose() {
+
+    }
+
+    @Override
+    protected void startReading() throws IOException {
+
+    }
+}
+*/
\ No newline at end of file
diff --git a/src/main/java/org/oilmod/oilclient/OilConnection.java b/src/main/java/org/oilmod/oilclient/OilConnection.java
new file mode 100644
index 00000000..9e25213f
--- /dev/null
+++ b/src/main/java/org/oilmod/oilclient/OilConnection.java
@@ -0,0 +1,13 @@
+package org.oilmod.oilclient;
+
+
+/**
+ * Created by sirati97 on 15.03.2016.
+ */
+/*public class OilConnection extends ArtifConnection{
+
+    public OilConnection(EntityPlayer player, AsyncHelper asyncHelper) {
+        super(player.getDisplayName(), asyncHelper, new IOHandlerPlayer(player),new SysOutLogger(), ConnectionManager.ROOT);//
+    }
+}
+*/
\ No newline at end of file
diff --git a/src/main/java/org/oilmod/spigot/OilMain.java b/src/main/java/org/oilmod/spigot/OilMain.java
new file mode 100644
index 00000000..8042b8bf
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/OilMain.java
@@ -0,0 +1,102 @@
+package org.oilmod.spigot;
+
+import org.oilmod.api.OilMod;
+import org.oilmod.api.blocks.BlockType;
+import org.oilmod.api.inventory.InventoryFactory;
+import org.oilmod.api.items.ItemRegistry;
+import org.oilmod.api.items.internal.ItemClassMap;
+import org.oilmod.api.items.internal.ItemCraftingFactory;
+import org.oilmod.api.items.internal.ItemFactory;
+import org.oilmod.api.items.type.ItemTypeHelper;
+import org.oilmod.api.items.type.TBBType;
+import org.oilmod.api.userinterface.internal.UIHelper;
+import org.oilmod.api.util.OilUtil;
+import org.oilmod.spigot.block.RealBlockTypeHelper;
+import org.oilmod.spigot.inventory.RealInventoryFactory;
+import org.oilmod.spigot.inventory.creative.OilCreativeModInventoryCommand;
+import org.oilmod.spigot.inventory.custom.api.RealUIHelper;
+import org.oilmod.spigot.items.*;
+import org.oilmod.spigot.items.itemstackimpl.crafting.RealItemCraftingFactory;
+import org.oilmod.spigot.items.itemstackimpl.crafting.help.CHCommand;
+import org.oilmod.spigot.items.itemtype.RealTBBHelper;
+import org.oilmod.spigot.util.RealOilUtil;
+import io.netty.buffer.Unpooled;
+import nbt.YBase;
+import net.minecraft.server.EntityPlayer;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.PacketDataSerializer;
+import net.minecraft.server.PacketPlayOutCustomPayload;
+import org.bukkit.configuration.serialization.ConfigurationSerialization;
+import org.spigotmc.Metrics;
+
+import java.io.IOException;
+
+/**
+ * Created by sirati97 on 16.01.2016.
+ */
+public class OilMain {
+    public static OilMod ModMinecraft;
+
+    public static void init() {
+        OilMod.ModHelper.setInstance(new OilMod.ModHelper()); //no modification needed for now
+        ModMinecraft  =  new OilMod("minecraft", "Minecraft");
+        ItemFactory.setInstance(new RealItemFactory());
+        RealItemClassMap itemClassMap = new RealItemClassMap();
+        ItemClassMap.setInstance(itemClassMap);
+        ItemRegistry.ItemRegistryHelper.setInstance(new RealItemRegistryHelper(itemClassMap));
+        InventoryFactory.setInstance(new RealInventoryFactory());
+        OilUtil.UtilImpl.setInstance(new RealOilUtil());
+        UIHelper.setInstance(new RealUIHelper());
+        ItemCraftingFactory.setInstance(new RealItemCraftingFactory());
+        BlockType.BlockTypeHelper.setInstance(new RealBlockTypeHelper());
+        ItemTypeHelper.setInstance(new RealItemTypeHelper());
+        TBBType.TBBHelper.setInstance(new RealTBBHelper());
+        initReflection();
+        YBase.registerYAMLClasses();
+        registerYAMLItemClasses();
+    }
+
+    public static void printTrace(String text) {
+        System.out.println("Printing stack trace for " + text + ":");
+        StackTraceElement[] elements = Thread.currentThread().getStackTrace();
+        for (int i = 2; i < elements.length; i++) {
+            StackTraceElement s = elements[i];
+            System.out.println("\tat " + s.getClassName() + "." + s.getMethodName()
+                    + "(" + s.getFileName() + ":" + s.getLineNumber() + ")");
+        }
+    }
+
+    public static void registerCommands() {
+        OilCreativeModInventoryCommand cmiCommand = new OilCreativeModInventoryCommand("CreativeModInventory", "cmi");
+        MinecraftServer.getServer().server.getCommandMap().register(cmiCommand.getName(), "OilMod", cmiCommand);
+        CHCommand chCommand = new CHCommand("CraftingHelper", "CraftingHelp", "CraftHelper", "CraftHelp", "cHelp", "ch");
+        MinecraftServer.getServer().server.getCommandMap().register(cmiCommand.getName(), "OilMod", chCommand);
+    }
+
+    public static void sendUnregisteredPluginMessage(EntityPlayer player, String channel, byte[] message) {
+        PacketPlayOutCustomPayload packet = new PacketPlayOutCustomPayload("OILMOD|" + channel, new PacketDataSerializer(Unpooled.wrappedBuffer(message)));
+        player.playerConnection.sendPacket(packet);
+    }
+
+    public static void initReflection() {
+        //should i ever use reflection - check it here to fire missing fields exceptions early
+    }
+
+    private static Metrics metricsOilSpigot;
+    private static Metrics metricsOilMod;
+    public static void initMetrics() throws IOException {
+        if (metricsOilSpigot == null) {
+            metricsOilSpigot = new Metrics("OilSpigot");
+            metricsOilSpigot.start();
+        }
+        if (metricsOilMod == null) {
+            metricsOilMod = new Metrics("OilMod"); //both are used as there could be other implementations than OilSpigot around!
+            metricsOilMod.start();
+        }
+    }
+
+
+    public static void registerYAMLItemClasses() {
+        ConfigurationSerialization.registerClass(RealCraftItemStack.class);
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/block/RealBlockType.java b/src/main/java/org/oilmod/spigot/block/RealBlockType.java
new file mode 100644
index 00000000..ce49d739
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/block/RealBlockType.java
@@ -0,0 +1,150 @@
+package org.oilmod.spigot.block;
+
+import net.minecraft.server.Block;
+import net.minecraft.server.Blocks;
+import org.oilmod.api.blocks.BlockType;
+import org.oilmod.api.blocks.MapColor;
+import org.oilmod.api.blocks.PistonReaction;
+import net.minecraft.server.Material;
+import org.oilmod.spigot.OilMain;
+import org.oilmod.spigot.util.OilSpigotUtil;
+
+public class RealBlockType extends BlockType {
+    public RealBlockType(Material material, BlockTypeEnum blockTypeEnum) {
+        super(material, OilMain.ModMinecraft.createKey(blockTypeEnum.toString().toLowerCase()), blockTypeEnum);
+    }
+
+    @Override
+    public Material getNmsBlockType() {
+        return (Material)super.getNmsBlockType();
+    }
+
+    @Override
+    public boolean isLiquid() {
+        return getNmsBlockType().isLiquid();
+    }
+
+    @Override
+    public boolean isBuildable() {
+        return getNmsBlockType().isBuildable();
+    }
+
+    @Override
+    public boolean blocksLight() {
+        return getNmsBlockType().blocksLight();
+    }
+
+    @Override
+    public boolean isSolid() {
+        return getNmsBlockType().isSolid();
+    }
+
+    @Override
+    public boolean isBurnable() {
+        return getNmsBlockType().isBurnable();
+    }
+
+    @Override
+    public boolean isReplaceable() {
+        return getNmsBlockType().isReplaceable();
+    }
+
+    @Override
+    public boolean isAlwaysDestroyable() {
+        return getNmsBlockType().isAlwaysDestroyable();
+    }
+
+    @Override
+    public boolean breakablePickaxe(org.bukkit.Material material) {
+        Block block = OilSpigotUtil.toNMS(material);
+        switch (getBlockTypeEnum()) {
+            case ANVIL: //Inferred by ItemPickaxe KEEPSYNC
+            case IRON:
+            case ROCK:
+            case PACKED_ICE: //Inferred by blocks
+                return true;
+            case CIRCUITS: //Unit test helps here
+                return block == Blocks.GOLDEN_RAIL || block == Blocks.DETECTOR_RAIL  || block == Blocks.RAIL || block == Blocks.STONE_BUTTON || block == Blocks.ACTIVATOR_RAIL;
+            case ICE:
+                return block == Blocks.ICE;
+            default:
+                return false;
+        }
+    }
+
+    @Override
+    public boolean breakableAxe(org.bukkit.Material material) {
+        Block block = OilSpigotUtil.toNMS(material);
+        switch (getBlockTypeEnum()) {
+            case WOOD: //Inferred by ItemAxe KEEPSYNC
+            case PLANTS:
+            case VINE:
+            case GOURD: //Inferred by blocks
+                return true;
+            case CIRCUITS: //Unit test helps here
+                return block == Blocks.LADDER || block == Blocks.WOODEN_BUTTON;
+            default:
+                return false;
+        }
+    }
+
+    @Override
+    public boolean breakableShovel(org.bukkit.Material material) {
+        Block block = OilSpigotUtil.toNMS(material);
+        switch (getBlockTypeEnum()) {
+            case SAND: //Inferred by blocks ItemSpade KEEPSYNC
+            case GROUND:
+            case CRAFTED_SNOW:
+            case SNOW:
+                return true;
+            case GRASS://Unit test helps here
+                return block == Blocks.GRASS || block == Blocks.MYCELIUM;
+            case CLAY:
+                return block == Blocks.CLAY;
+            default:
+                return false;
+        }
+    }
+
+    @Override
+    public boolean breakableShears(org.bukkit.Material material) {
+        switch (getBlockTypeEnum()) {
+            case PLANTS: //Inferred by blocks ItemShears KEEPSYNC
+            case VINE:
+            case LEAVES:
+            case CARPET:
+            case CLOTH:
+            case WEB:
+            case REDSTONE_LIGHT:
+                return true;
+            default:
+                return false;
+        }
+    }
+
+    @Override
+    public boolean breakableBlade(org.bukkit.Material material) {
+        switch (getBlockTypeEnum()) {
+            case PLANTS: //Inferred by ItemSword KEEPSYNC
+            case VINE:
+            case CORAL:
+            case LEAVES:
+            case GOURD:
+            case WEB: //Inferred by blocks
+            case REDSTONE_LIGHT: //TODO check this one
+                return true;
+            default:
+                return false;
+        }
+    }
+
+    @Override
+    public PistonReaction getPistonReaction() {
+        return RealBlockTypeHelper.toOil(getNmsBlockType().getPushReaction());
+    }
+
+    @Override
+    public MapColor getColor() {
+        return null; //TODO: implement when MapColor actually exists
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/block/RealBlockTypeHelper.java b/src/main/java/org/oilmod/spigot/block/RealBlockTypeHelper.java
new file mode 100644
index 00000000..c633d450
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/block/RealBlockTypeHelper.java
@@ -0,0 +1,94 @@
+package org.oilmod.spigot.block;
+
+import net.minecraft.server.EnumPistonReaction;
+import net.minecraft.server.Material;
+import org.apache.commons.lang3.Validate;
+import org.oilmod.api.blocks.BlockType;
+import org.oilmod.api.blocks.PistonReaction;
+import org.oilmod.api.blocks.nms.NMSBlockType;
+
+import static org.oilmod.api.blocks.BlockType.BlockTypeEnum.*;
+
+public class RealBlockTypeHelper extends BlockType.BlockTypeHelper {
+    private boolean initialised;
+
+
+    @Override
+    protected void apiInit() {
+        Validate.isTrue(!initialised, "Already initialised");
+        initialised = true;
+        Material.AIR.initOil(AIR); //KEEPSYNC have all types - needs to be done this way to ensure that both static instances are initialized properly
+        Material.GRASS.initOil(GRASS);
+        Material.EARTH.initOil(GROUND);
+        Material.WOOD.initOil(WOOD);
+        Material.STONE.initOil(ROCK);
+        Material.ORE.initOil(IRON);
+        Material.HEAVY.initOil(ANVIL);
+        Material.WATER.initOil(WATER);
+        Material.LAVA.initOil(LAVA);
+        Material.LEAVES.initOil(LEAVES);
+        Material.PLANT.initOil(PLANTS);
+        Material.REPLACEABLE_PLANT.initOil(VINE);
+        Material.SPONGE.initOil(SPONGE);
+        Material.CLOTH.initOil(CLOTH);
+        Material.FIRE.initOil(FIRE);
+        Material.SAND.initOil(SAND);
+        Material.ORIENTABLE.initOil(CIRCUITS);
+        Material.WOOL.initOil(CARPET);
+        Material.SHATTERABLE.initOil(GLASS);
+        Material.BUILDABLE_GLASS.initOil(REDSTONE_LIGHT);
+        Material.TNT.initOil(TNT);
+        Material.CORAL.initOil(CORAL);
+        Material.ICE.initOil(ICE);
+        Material.SNOW_LAYER.initOil(SNOW);
+        Material.PACKED_ICE.initOil(PACKED_ICE);
+        Material.SNOW_BLOCK.initOil(CRAFTED_SNOW);
+        Material.CACTUS.initOil(CACTUS);
+        Material.CLAY.initOil(CLAY);
+        Material.PUMPKIN.initOil(GOURD);
+        Material.DRAGON_EGG.initOil(DRAGON_EGG);
+        Material.PORTAL.initOil(PORTAL);
+        Material.CAKE.initOil(CAKE);
+        Material.WEB.initOil(WEB);
+        Material.PISTON.initOil(PISTON);
+        Material.BANNER.initOil(BARRIER);
+        Material.J.initOil(STRUCTURE_VOID);
+    }
+
+    @Override
+    protected void apiPostInit() {
+
+    }
+
+    @Override
+    protected BlockType getVanillaBlockType(BlockType.BlockTypeEnum blockType) {
+        return BlockType.getStandard(blockType);
+    }
+
+    @Override
+    protected NMSBlockType registerCustom(BlockType blockType) {
+        return new RealNMSMaterial(blockType);
+    }
+
+    public  static EnumPistonReaction toNMS(PistonReaction pistonReaction) {
+        switch (pistonReaction) {
+            case BLOCK: return EnumPistonReaction.BLOCK;
+            case DESTROY: return EnumPistonReaction.DESTROY;
+            case IGNORE: return EnumPistonReaction.IGNORE;
+            case NORMAL: return EnumPistonReaction.NORMAL;
+            case PUSH_ONLY: return EnumPistonReaction.PUSH_ONLY;
+            default: throw new UnsupportedOperationException("Missing is just a placeholder");
+        }
+    }
+
+    public  static PistonReaction toOil(EnumPistonReaction pistonReaction) {
+        switch (pistonReaction) {
+            case BLOCK: return PistonReaction.BLOCK;
+            case DESTROY: return PistonReaction.DESTROY;
+            case IGNORE: return PistonReaction.IGNORE;
+            case NORMAL: return PistonReaction.NORMAL;
+            case PUSH_ONLY: return PistonReaction.PUSH_ONLY;
+            default: return PistonReaction.MISSING;
+        }
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/block/RealNMSMaterial.java b/src/main/java/org/oilmod/spigot/block/RealNMSMaterial.java
new file mode 100644
index 00000000..0a25a8ab
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/block/RealNMSMaterial.java
@@ -0,0 +1,53 @@
+package org.oilmod.spigot.block;
+
+import net.minecraft.server.EnumPistonReaction;
+import net.minecraft.server.Material;
+import net.minecraft.server.MaterialMapColor;
+import org.oilmod.api.blocks.BlockType;
+
+public class RealNMSMaterial extends Material {
+    public RealNMSMaterial(BlockType type) {
+        super(MaterialMapColor.c); //TODO implement when MapColor actually exists
+        initOil(type);
+    }
+
+    @Override
+    public boolean isAlwaysDestroyable() {
+        return getOilBlockType().isAlwaysDestroyable();
+    }
+
+    @Override
+    public boolean isBuildable() {
+        return getOilBlockType().isBuildable();
+    }
+
+    @Override
+    public boolean isBurnable() {
+        return getOilBlockType().isBurnable();
+    }
+
+    @Override
+    public boolean isLiquid() {
+        return getOilBlockType().isLiquid();
+    }
+
+    @Override
+    public boolean isReplaceable() {
+        return getOilBlockType().isReplaceable();
+    }
+
+    @Override
+    public boolean isSolid() {
+        return getOilBlockType().isSolid();
+    }
+
+    @Override
+    public EnumPistonReaction getPushReaction() {
+        return RealBlockTypeHelper.toNMS(getOilBlockType().getPistonReaction());
+    }
+
+    @Override
+    public boolean blocksLight() {
+        return getOilBlockType().blocksLight();
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/block/RealOilBlockState.java b/src/main/java/org/oilmod/spigot/block/RealOilBlockState.java
new file mode 100644
index 00000000..54687dfc
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/block/RealOilBlockState.java
@@ -0,0 +1,38 @@
+package org.oilmod.spigot.block;
+
+import net.minecraft.server.BlockPosition;
+import net.minecraft.server.IBlockData;
+import org.bukkit.Location;
+import org.bukkit.Material;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.oilmod.api.blocks.BlockType;
+import org.oilmod.api.blocks.IBlockState;
+import org.oilmod.spigot.util.OilSpigotUtil;
+
+public class RealOilBlockState implements IBlockState {
+    private final IBlockData nms;
+
+    public RealOilBlockState(IBlockData nms) {
+        this.nms = nms;
+    }
+
+    @Override
+    public BlockType getBlockType() {
+        return nms.getMaterial().getOilBlockType();
+    }
+
+    @Override
+    public Material getMaterial() {
+        return OilSpigotUtil.toBukkit(nms.getBlock());
+    }
+
+    @Override
+    public float getBlockHardness(Location location) {
+        return nms.b(((CraftWorld)location.getWorld()).getHandle(), new BlockPosition(location.getBlockX(), location.getBlockY(), location.getBlockZ()));
+    }
+
+    @Override
+    public IBlockData getNMS() {
+        return nms;
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/bukkit/stubs/OilBlockStub.java b/src/main/java/org/oilmod/spigot/bukkit/stubs/OilBlockStub.java
new file mode 100644
index 00000000..a428de90
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/bukkit/stubs/OilBlockStub.java
@@ -0,0 +1,265 @@
+package org.oilmod.spigot.bukkit.stubs;
+
+import org.bukkit.Chunk;
+import org.bukkit.Location;
+import org.bukkit.Material;
+import org.bukkit.World;
+import org.bukkit.block.*;
+import org.bukkit.inventory.ItemStack;
+
+import java.util.Collection;
+import java.util.Collections;
+
+public class OilBlockStub extends OilStubMetadatable implements Block {
+    private final int x;
+    private final int y;
+    private final int z;
+
+
+    //OilSpigot start
+    private Material material;
+
+    public OilBlockStub(int x, int y, int z, Material material) {
+        this.x = x;
+        this.y = y;
+        this.z = z;
+        this.material = material;
+    }
+
+    public OilBlockStub(Material material) {
+        this(0, -1, 0, material);
+    }
+
+    @Override
+    public byte getData() {
+        return 0;
+    }
+
+    @Override
+    public Block getRelative(final int modX, final int modY, final int modZ) {
+        return new OilBlockStub(x+modX,y+modY,z+modZ, Material.AIR);
+    }
+    //OilSpigot end
+
+    public Block getRelative(BlockFace face) {
+        return getRelative(face, 1);
+    }
+
+    public Block getRelative(BlockFace face, int distance) {
+        return getRelative(face.getModX() * distance, face.getModY() * distance, face.getModZ() * distance);
+    }
+
+
+    @Override
+    public String toString() { //OilSpigot
+        return "OilBlockStub{type=" + getType() + '}';
+    }
+
+    @Override
+    public Material getType() {
+        return material;
+    }
+
+    @Override
+    public int getTypeId() {
+        return 0;
+    }
+
+    @Override
+    public byte getLightLevel() {
+        return 0;
+    }
+
+    @Override
+    public byte getLightFromSky() {
+        return 0;
+    }
+
+    @Override
+    public byte getLightFromBlocks() {
+        return 0;
+    }
+
+    @Override
+    public World getWorld() {
+        return null;
+    }
+
+    @Override
+    public int getX() {
+        return x;
+    }
+
+    @Override
+    public int getY() {
+        return y;
+    }
+
+    @Override
+    public int getZ() {
+        return z;
+    }
+
+    @Override
+    public Location getLocation() {
+        return new Location(null, x, y, z);
+    }
+
+    @Override
+    public Location getLocation(Location loc) {
+        if (loc != null) {
+            loc.setWorld(null);
+            loc.setX(x);
+            loc.setY(y);
+            loc.setZ(z);
+            loc.setYaw(0);
+            loc.setPitch(0);
+        }
+        return loc;
+    }
+
+    @Override
+    public Chunk getChunk() {
+        return null;
+    }
+
+    @Override
+    public void setData(byte b) {
+
+    }
+
+    @Override
+    public void setData(byte b, boolean b1) {
+
+    }
+
+    @Override
+    public void setType(Material material) {
+        this.material = material;
+    }
+
+    @Override
+    public void setType(Material material, boolean b) {
+        setType(material);
+    }
+
+    @Override
+    public boolean setTypeId(int i) {
+        return false;
+    }
+
+    @Override
+    public boolean setTypeId(int i, boolean b) {
+        return false;
+    }
+
+    @Override
+    public boolean setTypeIdAndData(int i, byte b, boolean b1) {
+        return false;
+    }
+
+    public BlockFace getFace(final Block block) {
+        BlockFace[] values = BlockFace.values();
+
+        for (BlockFace face : values) {
+            if ((this.getX() + face.getModX() == block.getX()) &&
+                    (this.getY() + face.getModY() == block.getY()) &&
+                    (this.getZ() + face.getModZ() == block.getZ())
+                    ) {
+                return face;
+            }
+        }
+
+        return null;
+    }
+
+    @Override
+    public BlockState getState() {
+        return null;
+    }
+
+    @Override
+    public Biome getBiome() {
+        return Biome.VOID;
+    }
+
+    @Override
+    public void setBiome(Biome biome) {
+
+    }
+
+    @Override
+    public boolean isBlockPowered() {
+        return false;
+    }
+
+    @Override
+    public boolean isBlockIndirectlyPowered() {
+        return false;
+    }
+
+    @Override
+    public boolean isBlockFacePowered(BlockFace blockFace) {
+        return false;
+    }
+
+    @Override
+    public boolean isBlockFaceIndirectlyPowered(BlockFace blockFace) {
+        return false;
+    }
+
+    @Override
+    public int getBlockPower(BlockFace blockFace) {
+        return 0;
+    }
+
+    @Override
+    public int getBlockPower() {
+        return 0;
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return !material.isBlock();
+    }
+
+    @Override
+    public boolean isLiquid() {
+        return (getType() == Material.WATER) || (getType() == Material.STATIONARY_WATER) || (getType() == Material.LAVA) || (getType() == Material.STATIONARY_LAVA);
+    }
+
+    @Override
+    public double getTemperature() {
+        return 0;
+    }
+
+    @Override
+    public double getHumidity() {
+        return 0;
+    }
+
+    @Override
+    public PistonMoveReaction getPistonMoveReaction() {
+        return null;
+    }
+
+    @Override
+    public boolean breakNaturally() {
+        return false;
+    }
+
+    @Override
+    public boolean breakNaturally(ItemStack itemStack) {
+        return false;
+    }
+
+    @Override
+    public Collection<ItemStack> getDrops() {
+        return Collections.emptyList();
+    }
+
+    @Override
+    public Collection<ItemStack> getDrops(ItemStack itemStack) {
+        return Collections.emptyList();
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/bukkit/stubs/OilStubMetadatable.java b/src/main/java/org/oilmod/spigot/bukkit/stubs/OilStubMetadatable.java
new file mode 100644
index 00000000..2cacdd08
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/bukkit/stubs/OilStubMetadatable.java
@@ -0,0 +1,30 @@
+package org.oilmod.spigot.bukkit.stubs;
+
+import org.bukkit.metadata.MetadataValue;
+import org.bukkit.metadata.Metadatable;
+import org.bukkit.plugin.Plugin;
+
+import java.util.Collections;
+import java.util.List;
+
+public class OilStubMetadatable implements Metadatable {
+    @Override
+    public void setMetadata(String s, MetadataValue metadataValue) {
+
+    }
+
+    @Override
+    public List<MetadataValue> getMetadata(String s) {
+        return Collections.emptyList();
+    }
+
+    @Override
+    public boolean hasMetadata(String s) {
+        return false;
+    }
+
+    @Override
+    public void removeMetadata(String s, Plugin plugin) {
+
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/config/ConfigUtil.java b/src/main/java/org/oilmod/spigot/config/ConfigUtil.java
new file mode 100644
index 00000000..35e4ffc8
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/config/ConfigUtil.java
@@ -0,0 +1,63 @@
+package org.oilmod.spigot.config;
+
+import org.oilmod.api.config.Compound;
+import org.oilmod.api.config.CompoundCreator;
+import org.oilmod.api.config.DataIndexedEntry;
+import org.oilmod.api.config.DataKeyedEntry;
+import org.oilmod.api.config.DataList;
+
+/**
+ * Created by sirati97 on 25.06.2016 for spigot.
+ */
+public final class ConfigUtil {
+    private ConfigUtil() {throw new UnsupportedOperationException();}
+
+
+    public static void copyTo(Compound from, Compound to) {
+        copyTo(from, to, to);
+    }
+
+    public static void copyTo(Compound from, Compound to, CompoundCreator creator) {
+        for (DataKeyedEntry<?> entry:from) {
+            switch (entry.getType()) {
+                case List:
+                    DataList<?> oldList = (DataList) entry.getValue();
+                    DataList<?> newList = creator.createList(oldList.getType());
+                    copyTo(oldList, newList, creator);
+                    to.setList(entry.getKey(), newList);
+                    break;
+                case Subsection:
+                    Compound newSubsection = creator.createCompound();
+                    copyTo((Compound) entry.getValue(), newSubsection, creator);
+                    to.set(entry.getKey(), newSubsection);
+                    break;
+                default:
+                    to.set(entry);
+            }
+        }
+    }
+
+
+    public static void copyTo(DataList<?> from, DataList<?> to, CompoundCreator creator) {
+        for (DataIndexedEntry<?> entry:from) {
+            switch (entry.getType()) {
+                case List:
+                    DataList<?> oldList = (DataList) entry.getValue();
+                    DataList<?> newList = creator.createList(oldList.getType());
+                    copyTo(oldList, newList, creator);
+                    //noinspection unchecked
+                    ((DataList)to).append(newList);
+                    break;
+                case Subsection:
+                    Compound newSubsection = creator.createCompound();
+                    copyTo((Compound) entry.getValue(), newSubsection, creator);
+                    //noinspection unchecked
+                    ((DataList)to).append(newSubsection);
+                    break;
+                default:
+                    //noinspection unchecked
+                    ((DataList)to).append(entry.getValue());
+            }
+        }
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/config/DeserializationMethod.java b/src/main/java/org/oilmod/spigot/config/DeserializationMethod.java
new file mode 100644
index 00000000..2c83c7ab
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/config/DeserializationMethod.java
@@ -0,0 +1,15 @@
+package org.oilmod.spigot.config;
+
+/**
+ * Created by sirati97 on 16.01.2016.
+ */
+public enum DeserializationMethod{
+    /**
+     * Same method as used in YamlConfiguration / org.bukkit.Itemstack.deserialize()
+     */
+    Bukkit,
+    /**
+     * Same method as used to load ItemStacks from NBTData
+     */
+    NMS_Nbt
+}
diff --git a/src/main/java/org/oilmod/spigot/config/MappedMemoryConfiguration.java b/src/main/java/org/oilmod/spigot/config/MappedMemoryConfiguration.java
new file mode 100644
index 00000000..95cc6b1b
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/config/MappedMemoryConfiguration.java
@@ -0,0 +1,34 @@
+package org.oilmod.spigot.config;
+
+import org.bukkit.configuration.MemoryConfiguration;
+import org.bukkit.configuration.MemorySection;
+
+import java.lang.reflect.Field;
+import java.lang.reflect.Modifier;
+import java.util.Map;
+
+/**
+ * Created by sirati97 on 16.01.2016.
+ */
+public class MappedMemoryConfiguration extends MemoryConfiguration {
+
+    public MappedMemoryConfiguration(Map<String, Object> args) {
+        try {
+            Field field = MemorySection.class.getDeclaredField("map");
+            field.setAccessible(true);
+            Field modifiersField = Field.class.getDeclaredField("modifiers");
+            modifiersField.setAccessible(true);
+            modifiersField.setInt(field, field.getModifiers() & ~Modifier.FINAL);
+            field.set(this, args);
+        } catch (Exception ex) {
+            throw new IllegalStateException("Exception thrown while changing final field from superclass", ex);
+        }
+    }
+
+
+    public MappedMemoryConfiguration() {}
+
+    public Map<String, Object> getMap() {
+        return map;
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/config/nbttag/NBTCompound.java b/src/main/java/org/oilmod/spigot/config/nbttag/NBTCompound.java
new file mode 100644
index 00000000..1b0ef3ec
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/config/nbttag/NBTCompound.java
@@ -0,0 +1,303 @@
+package org.oilmod.spigot.config.nbttag;
+
+import org.oilmod.api.config.Compound;
+import org.oilmod.api.config.DataKeyedEntry;
+import org.oilmod.api.config.DataList;
+import org.oilmod.api.config.DataType;
+import net.minecraft.server.NBTBase;
+import net.minecraft.server.NBTTagByte;
+import net.minecraft.server.NBTTagByteArray;
+import net.minecraft.server.NBTTagCompound;
+import net.minecraft.server.NBTTagDouble;
+import net.minecraft.server.NBTTagFloat;
+import net.minecraft.server.NBTTagInt;
+import net.minecraft.server.NBTTagIntArray;
+import net.minecraft.server.NBTTagList;
+import net.minecraft.server.NBTTagLong;
+import net.minecraft.server.NBTTagShort;
+import net.minecraft.server.NBTTagString;
+
+import java.util.Iterator;
+
+public class NBTCompound implements Compound {
+	NBTTagCompound parent;
+	
+	
+	public NBTCompound() {
+		this(new NBTTagCompound());
+	}
+
+	public NBTCompound(NBTTagCompound parent) {
+		this.parent = parent;
+	}
+	
+	public NBTTagCompound getNBTTagCompound() {
+		return parent;
+	}
+	
+	
+	@Override
+	public Compound createCompound() {
+        return new NBTCompound();
+	}
+
+    @Override
+    public <Type> DataList<Type> createList(DataType dataType) {
+        //noinspection unchecked
+        Class<Type> typeClass = (Class<Type>) dataType.getJavaClass();
+        return new NBTDataList<Type>(typeClass, dataType);
+    }
+
+
+	@Override
+	public void set(String paramString, Compound paramCompound) {
+		parent.set(paramString, ((NBTCompound) paramCompound).getNBTTagCompound());
+	}
+
+	@Override
+	public void setList(String paramString, DataList paramCompoundList) {
+		parent.set(paramString, ((NBTDataList) paramCompoundList).getNBTTagList());
+		
+	}
+
+	@Override
+	public void setByte(String paramString, byte paramByte) {
+		parent.setByte(paramString, paramByte);
+	}
+
+	@Override
+	public void setShort(String paramString, short paramShort) {
+		parent.setShort(paramString, paramShort);
+	}
+
+	@Override
+	public void setInt(String paramString, int paramInt) {
+		parent.setInt(paramString, paramInt);
+	}
+
+	@Override
+	public void setLong(String paramString, long paramLong) {
+		parent.setLong(paramString, paramLong);
+	}
+
+	@Override
+	public void setFloat(String paramString, float paramFloat) {
+		parent.setFloat(paramString, paramFloat);
+	}
+
+	@Override
+	public void setDouble(String paramString, double paramDouble) {
+		parent.setDouble(paramString, paramDouble);
+	}
+
+	@Override
+	public void setString(String paramString1, String paramString2) {
+		parent.setString(paramString1, paramString2);
+	}
+
+	@Override
+	public void setByteArray(String paramString, byte[] paramArrayOfByte) {
+		parent.setByteArray(paramString, paramArrayOfByte);
+	}
+
+	@Override
+	public void setIntArray(String paramString, int[] paramArrayOfInt) {
+		parent.setIntArray(paramString, paramArrayOfInt);
+	}
+
+	@Override
+	public void setBoolean(String paramString, boolean paramBoolean) {
+		parent.setBoolean(paramString, paramBoolean);
+	}
+
+	@Override
+	public void setNBT(String paramString, Object paramNBTTag) {
+		parent.set(paramString, (NBTTagCompound) paramNBTTag);
+	}
+
+
+    @Override
+    public void set(String key, Object value, DataType type) {
+        switch (type) {
+            case Byte:
+                setByte(key, (Byte) value);
+                break;
+            case Short:
+                setShort(key, (Short) value);
+                break;
+            case Int:
+                setInt(key, (Integer) value);
+                break;
+            case Long:
+                setLong(key, (Long) value);
+                break;
+            case Float:
+                setFloat(key, (Float) value);
+                break;
+            case Double:
+                setDouble(key, (Double) value);
+                break;
+            case ByteArray:
+                setByteArray(key, (byte[]) value);
+                break;
+            case String:
+                setString(key, (String) value);
+                break;
+            case List:
+                setList(key, (DataList) value);
+                break;
+            case Subsection:
+                set(key, (Compound) value);
+                break;
+            case IntArray:
+                setIntArray(key, (int[]) value);
+                break;
+        }
+    }
+
+    @Override
+    public void set(DataKeyedEntry dataKeyedEntry) {
+        set(dataKeyedEntry.getKey(), dataKeyedEntry.getValue(), dataKeyedEntry.getType());
+    }
+
+
+    @Override
+	public byte getByte(String paramString) {
+		return parent.getByte(paramString);
+	}
+
+	@Override
+	public short getShort(String paramString) {
+		return parent.getShort(paramString);
+	}
+
+	@Override
+	public int getInt(String paramString) {
+		return parent.getInt(paramString);
+	}
+
+	@Override
+	public long getLong(String paramString) {
+		return parent.getLong(paramString);
+	}
+
+	@Override
+	public float getFloat(String paramString) {
+		return parent.getFloat(paramString);
+	}
+
+	@Override
+	public double getDouble(String paramString) {
+		return parent.getDouble(paramString);
+	}
+
+	@Override
+	public String getString(String paramString) {
+		return parent.getString(paramString);
+	}
+
+	@Override
+	public byte[] getByteArray(String paramString) {
+		return parent.getByteArray(paramString);
+	}
+
+	@Override
+	public int[] getIntArray(String paramString) {
+		return parent.getIntArray(paramString);
+	}
+
+	@Override
+	public Compound getCompound(String paramString) {
+		return new NBTCompound(parent.getCompound(paramString));
+	}
+
+	@Override
+    public <Type> DataList<Type> getList(String paramString) {
+		return new NBTDataList<>(parent.getList(paramString, 10));
+	}
+
+	@Override
+	public boolean getBoolean(String paramString) {
+		return parent.getBoolean(paramString);
+	}
+
+	@Override
+	public Object getRaw(String s) {
+		return parent.get(s);
+	}
+
+    @Override
+    public DataKeyedEntry get(String s) {
+        NBTBase nbtBase = parent.get(s);
+        DataType type = DataType.getByNbtId(nbtBase.getTypeId());
+        return new DataKeyedEntry<>(s, convertJava(nbtBase, type), type);
+    }
+
+    @SuppressWarnings("unchecked")
+    private Object convertJava(NBTBase nbt, DataType type) {
+        switch (type) {
+            case Byte:
+                return ((NBTTagByte) nbt).g();
+            case Short:
+                return ((NBTTagShort) nbt).f();
+            case Int:
+                return ((NBTTagInt) nbt).e();
+            case Long:
+                return ((NBTTagLong) nbt).d();
+            case Float:
+                return ((NBTTagFloat) nbt).i();
+            case Double:
+                return ((NBTTagDouble) nbt).asDouble();
+            case ByteArray:
+                return ((NBTTagByteArray) nbt).c();
+            case String:
+                return ((NBTTagString) nbt).c_();
+            case List:
+                return new NBTDataList<>((NBTTagList) nbt);
+            case Subsection:
+                return new NBTCompound((NBTTagCompound) nbt);
+            case IntArray:
+                return ((NBTTagIntArray) nbt).d();
+            default:
+                throw new IllegalStateException("Cannot convert object with type " + type.toString() + " to Java");
+        }
+    }
+
+    @Override
+	public boolean containsKey(String s) {
+		return parent.hasKey(s);
+	}
+
+    @Override
+    public boolean containsKey(String s, DataType dataType) {
+        return containsKey(s) && getType(s)==dataType;
+    }
+
+    @Override
+	public Object nbtClone() {
+		return parent.clone();
+	}
+
+	@Override
+	public DataType getType(String s) {
+		return DataType.getByNbtId(parent.get(s).getTypeId());
+	}
+
+    @Override
+    public Iterator<DataKeyedEntry> iterator() {
+        return new Iterator<DataKeyedEntry>() {
+            private final Iterator<String> keyIterator = parent.c().iterator();
+
+            @Override
+            public boolean hasNext() {
+                return keyIterator.hasNext();
+            }
+
+            @Override
+            public DataKeyedEntry next() {
+                String key = keyIterator.next();
+                return get(key);
+            }
+        };
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/config/nbttag/NBTDataList.java b/src/main/java/org/oilmod/spigot/config/nbttag/NBTDataList.java
new file mode 100644
index 00000000..49e50d65
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/config/nbttag/NBTDataList.java
@@ -0,0 +1,166 @@
+package org.oilmod.spigot.config.nbttag;
+
+import org.oilmod.api.config.DataIndexedEntry;
+import org.oilmod.api.config.DataList;
+import org.oilmod.api.config.DataType;
+import net.minecraft.server.NBTBase;
+import net.minecraft.server.NBTTagByte;
+import net.minecraft.server.NBTTagByteArray;
+import net.minecraft.server.NBTTagCompound;
+import net.minecraft.server.NBTTagDouble;
+import net.minecraft.server.NBTTagFloat;
+import net.minecraft.server.NBTTagInt;
+import net.minecraft.server.NBTTagIntArray;
+import net.minecraft.server.NBTTagList;
+import net.minecraft.server.NBTTagLong;
+import net.minecraft.server.NBTTagShort;
+import net.minecraft.server.NBTTagString;
+
+import java.util.Iterator;
+
+public class NBTDataList<Type> implements DataList<Type> {
+	private final NBTTagList parent;
+    private final Class<Type> javaType;
+    private final DataType type;
+
+
+	public NBTDataList(Class<Type> javaType, DataType type) {
+		this(new NBTTagList(), javaType, type);
+	}
+
+	private NBTDataList(NBTTagList parent, Class<Type> javaType, DataType type) {
+		this.parent = parent;
+        this.javaType = javaType;
+        this.type = type;
+    }
+
+
+    public NBTDataList(NBTTagList parent) {
+        this.parent = parent;
+        this.type = DataType.getByNbtId(parent.g());
+        //noinspection unchecked
+        this.javaType = (Class<Type>) type.getJavaClass();
+    }
+
+	public NBTTagList getNBTTagList() {
+		return parent;
+	}
+
+
+    @Override
+    public void append(Type type) {
+        parent.add(convertNBT(type));
+    }
+
+    @Override
+    public void set(int i, Type type) {
+        parent.a(i, convertNBT(type));
+    }
+
+    @Override
+    public Type get(int i) {
+        return convertJava(parent.get(i));
+    }
+
+    @Override
+    public Type remove(int i) {
+        return convertJava(parent.remove(i));
+    }
+
+    @Override
+    public int size() {
+        return parent.size();
+    }
+
+    @Override
+    public DataType getType() {
+        return type;
+    }
+
+    @Override
+    public Class<Type> getJavaType() {
+        return javaType;
+    }
+
+    private NBTBase convertNBT(Type obj) {
+        if (obj == null) {
+            throw new IllegalArgumentException("Argument must not be null");
+        }
+        switch (type) {
+            case Byte:
+                return new NBTTagByte((Byte) obj);
+            case Short:
+                return new NBTTagShort((Short) obj);
+            case Int:
+                return new NBTTagInt((Integer) obj);
+            case Long:
+                return new NBTTagLong((Long) obj);
+            case Float:
+                return new NBTTagFloat((Float) obj);
+            case Double:
+                return new NBTTagDouble((Double) obj);
+            case ByteArray:
+                return new NBTTagByteArray((byte[]) obj);
+            case String:
+                return new NBTTagString((String) obj);
+            case List:
+                return ((NBTDataList) obj).getNBTTagList();
+            case Subsection:
+                return ((NBTCompound) obj).getNBTTagCompound();
+            case IntArray:
+                return new NBTTagIntArray((int[]) obj);
+            default:
+                throw new IllegalStateException("Cannot convert object with type " + type.toString() + " to NBT");
+        }
+    }
+
+    @SuppressWarnings("unchecked")
+    private Type convertJava(NBTBase nbt) {
+        switch (type) {
+            case Byte:
+                return (Type)(Byte)((NBTTagByte) nbt).g();
+            case Short:
+                return (Type)(Short)((NBTTagShort) nbt).f();
+            case Int:
+                return (Type)(Integer)((NBTTagInt) nbt).e();
+            case Long:
+                return (Type)(Long)((NBTTagLong) nbt).d();
+            case Float:
+                return (Type)(Float)((NBTTagFloat) nbt).i();
+            case Double:
+                return (Type)(Double)((NBTTagDouble) nbt).asDouble();
+            case ByteArray:
+                return (Type)((NBTTagByteArray) nbt).c();
+            case String:
+                return (Type)((NBTTagString) nbt).c_();
+            case List:
+                return (Type) new NBTDataList<>((NBTTagList) nbt);
+            case Subsection:
+                return (Type) new NBTCompound((NBTTagCompound) nbt);
+            case IntArray:
+                return (Type)((NBTTagIntArray) nbt).d();
+            default:
+                throw new IllegalStateException("Cannot convert object with type " + type.toString() + " to Java");
+        }
+    }
+
+    @Override
+    public Iterator<DataIndexedEntry<Type>> iterator() {
+        return new Iterator<DataIndexedEntry<Type>>() {
+            private int index = 0;
+
+            @Override
+            public boolean hasNext() {
+                return index<parent.size();
+            }
+
+            @Override
+            public DataIndexedEntry<Type> next() {
+                NBTBase nbt = parent.get(index); //todo: replaced h with get hopefully correct
+                DataIndexedEntry<Type> result = new DataIndexedEntry<>(index, convertJava(nbt), type);
+                index++;
+                return result;
+            }
+        };
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/config/yaml/YamlCompound.java b/src/main/java/org/oilmod/spigot/config/yaml/YamlCompound.java
new file mode 100644
index 00000000..7118c6a6
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/config/yaml/YamlCompound.java
@@ -0,0 +1,465 @@
+package org.oilmod.spigot.config.yaml;
+
+import org.oilmod.api.config.Compound;
+import org.oilmod.api.config.DataKeyedEntry;
+import org.oilmod.api.config.DataList;
+import org.oilmod.api.config.DataType;
+import org.oilmod.spigot.config.ConfigUtil;
+import org.oilmod.spigot.config.MappedMemoryConfiguration;
+import org.oilmod.spigot.config.nbttag.NBTCompound;
+import nbt.YBase;
+import nbt.YByte;
+import nbt.YByteArray;
+import nbt.YDouble;
+import nbt.YFloat;
+import nbt.YInt;
+import nbt.YIntArray;
+import nbt.YList;
+import nbt.YLong;
+import nbt.YShort;
+import net.minecraft.server.NBTTagCompound;
+import org.bukkit.configuration.ConfigurationSection;
+import org.bukkit.configuration.MemorySection;
+import org.bukkit.configuration.file.YamlConfiguration;
+import org.oilmod.spigot.config.nbttag.NBTCompound;
+
+import java.lang.reflect.Field;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+
+public class YamlCompound implements Compound {
+	private final ConfigurationSection parent;
+
+	public YamlCompound() {
+		this (new YamlConfiguration());
+	}
+	
+	public YamlCompound(ConfigurationSection parent) {
+		if (!(parent instanceof MemorySection)) throw new IllegalStateException ("parent is no subclass of MemorySection");
+		this.parent = parent;
+
+	}
+
+	private static Map<String, Object> getInnerMap(MemorySection section) {
+		try {
+			Field field = MemorySection.class.getDeclaredField("map");
+			field.setAccessible(true);
+			return (Map<String, Object>) field.get(section);
+		} catch (Exception ex) {
+			throw new IllegalStateException("Exception thrown while extracting inner map from configuration", ex);
+		}
+	}
+
+	public YamlCompound(Map<String, Object> args) {
+		this(new MappedMemoryConfiguration(args));
+	}
+	
+	public ConfigurationSection getConfigurationSection() {
+		return parent;
+	}
+	
+	
+	@Override
+	public YamlCompound createCompound() {
+		return new YamlCompound(new MappedMemoryConfiguration(new HashMap<String, Object>()));
+	}
+
+    @Override
+    public <Type> DataList<Type> createList(DataType dataType) {
+        //noinspection unchecked
+        Class<Type> typeClass = (Class<Type>) dataType.getJavaClass();
+        return new YamlDataList<Type>(typeClass, dataType);
+    }
+
+
+	@Override
+	public void set(String paramString, Compound paramCompound) {
+		parent.set(paramString, ((YamlCompound) paramCompound).getConfigurationSection());
+		
+	}
+
+    @Override
+    public void setList(String paramString, DataList paramList) {
+        parent.set(paramString, ((YamlDataList) paramList).getYList());
+    }
+
+	@Override
+	public void setByte(String key, byte paramByte) {
+		parent.set(key, new YByte(paramByte));
+	}
+
+	@Override
+	public void setShort(String key, short paramShort) {
+		parent.set(key, new YShort(paramShort));
+	}
+
+	@Override
+	public void setInt(String key, int paramInt) {
+		parent.set(key, new YInt(paramInt));
+	}
+
+	@Override
+	public void setLong(String key, long paramLong) {
+		parent.set(key, new YLong(paramLong));
+	}
+
+	@Override
+	public void setFloat(String key, float paramFloat) {
+		parent.set(key, new YFloat(paramFloat));
+	}
+
+	@Override
+	public void setDouble(String key, double paramDouble) {
+		parent.set(key, new YDouble(paramDouble));
+	}
+
+	@Override
+	public void setString(String key, String paramString) {
+		parent.set(key, paramString);
+	}
+
+	@Override
+	public void setByteArray(String key, byte[] paramArrayOfByte) {
+		parent.set(key, new YByteArray(paramArrayOfByte));
+	}
+
+	@Override
+	public void setIntArray(String key, int[] paramArrayOfInt) {
+		parent.set(key, new YIntArray(paramArrayOfInt));
+	}
+
+	@Override
+	public void setBoolean(String key, boolean paramBoolean) {
+		parent.set(key, paramBoolean);
+	}
+
+	@Override
+	public void setNBT(String key, Object o) {
+        if (o instanceof NBTTagCompound) {
+            NBTCompound nbtCompound = new NBTCompound((NBTTagCompound) o);
+            YamlCompound yamlCompound = createCompound();
+            ConfigUtil.copyTo(nbtCompound, yamlCompound);
+            set(key, yamlCompound);
+        } else {
+            throw new IllegalArgumentException((o==null?"null":o.getClass().getCanonicalName()) + " is not a valid NBTTagCompound");
+        }
+	}
+
+    @Override
+    public void set(String key, Object value, DataType type) {
+        switch (type) {
+            case Byte:
+                setByte(key, (Byte) value);
+                break;
+            case Short:
+                setShort(key, (Short) value);
+                break;
+            case Int:
+                setInt(key, (Integer) value);
+                break;
+            case Long:
+                setLong(key, (Long) value);
+                break;
+            case Float:
+                setFloat(key, (Float) value);
+                break;
+            case Double:
+                setDouble(key, (Double) value);
+                break;
+            case ByteArray:
+                setByteArray(key, (byte[]) value);
+                break;
+            case String:
+                setString(key, (String) value);
+                break;
+            case List:
+                setList(key, (DataList) value);
+                break;
+            case Subsection:
+                set(key, (Compound) value);
+                break;
+            case IntArray:
+                setIntArray(key, (int[]) value);
+                break;
+        }
+    }
+
+    @Override
+    public void set(DataKeyedEntry dataKeyedEntry) {
+        set(dataKeyedEntry.getKey(), dataKeyedEntry.getValue(), dataKeyedEntry.getType());
+    }
+
+    @Override
+	public byte getByte(String key) {
+        return convertJava(parent.get(key), DataType.Byte, (byte)0);
+	}
+
+	@Override
+	public short getShort(String key) {
+        return convertJava(parent.get(key), DataType.Short, (short)0);
+	}
+
+	@Override
+	public int getInt(String key) {
+        return convertJava(parent.get(key), DataType.Int, 0);
+	}
+
+	@Override
+	public long getLong(String key) {
+        return convertJava(parent.get(key), DataType.Long, (long)0);
+	}
+
+	@Override
+	public float getFloat(String key) {
+        return convertJava(parent.get(key), DataType.Float, (float)0);
+	}
+
+	@Override
+	public double getDouble(String key) {
+        return convertJava(parent.get(key), DataType.Double, (double)0);
+	}
+
+	@Override
+	public String getString(String key) {
+        return convertJava(parent.get(key), DataType.String, "");
+	}
+
+    private final static byte[] EMPTY_BYTE_ARRAY = new byte[0];
+	@Override
+	public byte[] getByteArray(String key) {
+        return convertJava(parent.get(key), DataType.ByteArray, EMPTY_BYTE_ARRAY);
+	}
+
+    private final static int[] EMPTY_INT_ARRAY = new int[0];
+	@Override
+	public int[] getIntArray(String key) {
+        return convertJava(parent.get(key), DataType.IntArray, EMPTY_INT_ARRAY);
+	}
+
+	@Override
+	public Compound getCompound(String key) {
+        return convertJava(parent.get(key), DataType.Subsection, (Compound)null);
+	}
+
+    @Override
+    public <Type> DataList<Type> getList(String key) {
+        return convertJava(parent.get(key), DataType.List, (DataList<Type>)null);
+
+    }
+
+    @Override
+	public boolean getBoolean(String key) {
+        Object obj = parent.get(key);
+        if (obj instanceof YBase) {
+            //noinspection unchecked
+            int value = ((YBase<?, ? extends Number>)obj).getValue().intValue();
+            return value!=0;
+        } else if (obj instanceof Boolean) {
+            return (boolean)obj;
+        } else if (obj instanceof Number) {
+            int value = ((Number)obj).intValue();
+            return value!=0;
+        } else {
+            return false;
+        }
+	}
+
+	@Override
+	public Object getRaw(String key) {
+		return parent.get(key);
+	}
+
+    @Override
+    public DataKeyedEntry get(String key) {
+        Object yaml = parent.get(key);
+        DataType type = getType(yaml);
+        return new DataKeyedEntry<>(key, convertJavaNoGenerics(yaml, type, type.getStandardValue()), type);
+    }
+
+    @Override
+	public boolean containsKey(String key) {
+		return parent.contains(key);
+	}
+
+    @Override
+    public boolean containsKey(String key, DataType dataType) {
+        return containsKey(key) && getType(key)==dataType;
+    }
+
+	@Override
+	public Object nbtClone() {
+		NBTTagCompound result = new NBTTagCompound();
+        NBTCompound nbtCompound = new NBTCompound(result);
+        ConfigUtil.copyTo(this, nbtCompound);
+		return result;
+	}
+
+    protected Map<String, Object> getMap() {
+        return getInnerMap((MemorySection)parent);
+    }
+
+    @Override
+    public DataType getType(String key) {
+        Object object = parent.get(key);
+        return getType(object);
+    }
+    
+    private DataType getType(Object yaml) {
+        if (yaml == null) {
+          return DataType.Empty;
+        } else if (yaml instanceof YBase) {
+            return ((YBase) yaml).getDataType();
+        } else if (yaml instanceof String) {
+            return DataType.String;
+        } else if (yaml instanceof Boolean) {
+            return DataType.Byte;
+        } else if (yaml instanceof MemorySection || yaml instanceof Map) {
+            return DataType.Subsection;
+        } else if (yaml instanceof Byte) {
+            return DataType.Byte;
+        } else if (yaml instanceof Short) {
+            return DataType.Short;
+        } else if (yaml instanceof Integer) {
+            return DataType.Int;
+        } else if (yaml instanceof Long) {
+            return DataType.Long;
+        } else if (yaml instanceof Float) {
+            return DataType.Float;
+        } else if (yaml instanceof Double) {
+            return DataType.Double;
+        } else {
+            return DataType.Undefined;
+        }
+    }
+
+
+    private <JavaType> JavaType convertJava(Object yaml, DataType type, JavaType standard) {
+        //noinspection unchecked
+        return (JavaType) convertJavaNoGenerics(yaml, type, standard);
+    }
+
+    private Object convertJavaNoGenerics(Object yaml, DataType type, Object standard) {
+        if (yaml == null || getType(yaml)!=type) {
+            return standard;
+        }
+        switch (type) {
+            case Byte:
+                if (yaml instanceof YByte) {
+                    return ((YByte) yaml).getValue();
+                } else if (yaml instanceof Boolean) {
+                    return (byte) (((Boolean)yaml)?1:0);
+                } else if (yaml instanceof Number) {
+                    return ((Number) yaml).byteValue();
+                } else {
+                    return standard;
+                }
+            case Short:
+                if (yaml instanceof YShort) {
+                    return ((YShort) yaml).getValue();
+                } else if (yaml instanceof Boolean) {
+                    return (short) (((Boolean)yaml)?1:0);
+                } else if (yaml instanceof Number) {
+                    return ((Number) yaml).shortValue();
+                } else {
+                    return standard;
+                }
+            case Int:
+                if (yaml instanceof YInt) {
+                    return ((YInt) yaml).getValue();
+                } else if (yaml instanceof Boolean) {
+                    return (((Boolean)yaml)?1:0);
+                } else if (yaml instanceof Number) {
+                    return ((Number) yaml).intValue();
+                } else {
+                    return standard;
+                }
+            case Long:
+                if (yaml instanceof YLong) {
+                    return ((YLong) yaml).getValue();
+                } else if (yaml instanceof Boolean) {
+                    return (((Boolean)yaml)?1:0);
+                } else if (yaml instanceof Number) {
+                    return ((Number) yaml).longValue();
+                } else {
+                    return standard;
+                }
+            case Float:
+                if (yaml instanceof YFloat) {
+                    return ((YFloat) yaml).getValue();
+                } else if (yaml instanceof Boolean) {
+                    return (((Boolean)yaml)?1:0);
+                } else if (yaml instanceof Number) {
+                    return ((Number) yaml).floatValue();
+                } else {
+                    return standard;
+                }
+            case Double:
+                if (yaml instanceof YFloat) {
+                    return ((YFloat) yaml).getValue();
+                } else if (yaml instanceof Boolean) {
+                    return (((Boolean)yaml)?1:0);
+                } else if (yaml instanceof Number) {
+                    return ((Number) yaml).doubleValue();
+                } else {
+                    return standard;
+                }
+            case ByteArray:
+                if (yaml instanceof YByteArray) {
+                    return ((YByteArray) yaml).getValue();
+                } else {
+                    return standard;
+                }
+            case String:
+                return yaml;
+            case List:
+                if (yaml instanceof YList) {
+                    //noinspection unchecked
+                    return ((YList)yaml).getValue();
+                } else {
+                    return standard;
+                }
+            case Subsection:
+                if (yaml instanceof Map) {
+                    //noinspection unchecked
+                    return new YamlCompound((Map<String, Object>) yaml);
+                } else if (yaml instanceof ConfigurationSection) {
+                    return new YamlCompound((ConfigurationSection) yaml);
+                } else {
+                    return standard;
+                }
+            case IntArray:
+                if (yaml instanceof YIntArray) {
+                    return ((YIntArray) yaml).getValue();
+                } else {
+                    return standard;
+                }
+            default:
+                return yaml;//throw new IllegalStateException("Cannot convert object{" + yaml.getClass().getCanonicalName() + "} with type " + type.toString() + " to Java");
+        }
+    }
+
+
+    public ConfigurationSection getParent() {
+		return parent;
+	}
+
+    @Override
+    public Iterator<DataKeyedEntry> iterator() {
+        return new Iterator<DataKeyedEntry>() {
+            private final Iterator<Map.Entry<String, Object>> values = parent.getValues(false).entrySet().iterator();
+
+            @Override
+            public boolean hasNext() {
+                return values.hasNext();
+            }
+
+            @Override
+            public DataKeyedEntry next() {
+                Map.Entry<String, Object> value = values.next();
+                DataType type = getType(value.getValue());
+                return new DataKeyedEntry<>(value.getKey(), convertJavaNoGenerics(value.getValue(), type, type.getStandardValue()), type);
+            }
+        };
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/config/yaml/YamlDataList.java b/src/main/java/org/oilmod/spigot/config/yaml/YamlDataList.java
new file mode 100644
index 00000000..b02a2ddf
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/config/yaml/YamlDataList.java
@@ -0,0 +1,155 @@
+package org.oilmod.spigot.config.yaml;
+
+import org.oilmod.api.config.DataIndexedEntry;
+import org.oilmod.api.config.DataList;
+import org.oilmod.api.config.DataType;
+import nbt.YList;
+import nbt.YUtil;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+
+public class YamlDataList<Type> implements DataList<Type> {
+    private final List<Object> data;
+    private final Class<Type> javaType;
+    private final DataType type;
+    private final YList yList;
+
+    private YamlDataList(List<Object> data, Class<Type> javaType, DataType type) {
+        this.data = data;
+        this.javaType = javaType;
+        this.type = type;
+        this.yList = new YList(this);
+    }
+
+
+    public YamlDataList(Class<Type> javaType, DataType type) {
+        this(new ArrayList<>(), javaType, type);
+    }
+
+    public YamlDataList(List<Object> data, DataType type) {
+        //noinspection unchecked
+        this(data, (Class<Type>) type.getJavaClass(), type);
+    }
+
+    @Override
+    public void append(Type type) {
+        data.add(convertYAML(type));
+    }
+
+    @Override
+    public void set(int i, Type type) {
+        data.set(i, convertYAML(type));
+    }
+
+    @Override
+    public Type get(int i) {
+        return convertJava(data.get(i));
+    }
+
+    @Override
+    public Type remove(int i) {
+        return convertJava(data.remove(i));
+    }
+
+    @Override
+	public int size() {
+		return data.size();
+	}
+
+    @Override
+    public DataType getType() {
+        return type;
+    }
+
+    @Override
+    public Class<Type> getJavaType() {
+        return javaType;
+    }
+
+    public List<Object> getData() {
+		return data;
+	}
+
+    public YList getYList() {
+        return yList;
+    }
+
+    private Object convertYAML(Type obj) {
+        if (obj == null) {
+            throw new IllegalArgumentException("Argument must not be null");
+        }
+        switch (type) {
+            case Byte:
+            case Short:
+            case Int:
+            case Long:
+            case Float:
+            case Double:
+            case String:
+                return obj;
+            case ByteArray:
+                return YUtil.byteArrayToString((byte[]) obj);
+            case List:
+                return ((YamlDataList) obj).getYList();
+            case Subsection:
+                return ((YamlCompound) obj).getMap();
+            case IntArray:
+                return YUtil.intArrayToString((int[]) obj);
+            default:
+                throw new IllegalStateException("Cannot convert object with type " + type.toString() + " to YAML");
+        }
+    }
+    
+    @SuppressWarnings("unchecked")
+    private Type convertJava(Object obj) {
+        switch (type) {
+            case Byte:
+                return (Type)(Byte)((Number) obj).byteValue();
+            case Short:
+                return (Type)(Short)((Number) obj).shortValue();
+            case Int:
+                return (Type)(Integer)((Number) obj).intValue();
+            case Long:
+                return (Type)(Long)((Number) obj).longValue();
+            case Float:
+                return (Type)(Float)((Number) obj).floatValue();
+            case Double:
+                return (Type)(Double)((Number) obj).doubleValue();
+            case ByteArray:
+                return (Type)(YUtil.stringToByteArray((String)obj));
+            case String:
+                return (Type)obj;
+            case List:
+                return (Type) ((YList) obj).getValue();
+            case Subsection:
+                return (Type) new YamlCompound((Map<String, Object>) obj);
+            case IntArray:
+                return (Type)(YUtil.stringToIntArray((String)obj));
+            default:
+                throw new IllegalStateException("Cannot convert object with type " + type.toString() + " to Java");
+        }
+    }
+
+    @Override
+    public Iterator<DataIndexedEntry<Type>> iterator() {
+        return new Iterator<DataIndexedEntry<Type>>() {
+            private int index = 0;
+
+            @Override
+            public boolean hasNext() {
+                return index<data.size();
+            }
+
+            @Override
+            public DataIndexedEntry<Type> next() {
+                Object obj = data.get(index);
+                DataIndexedEntry<Type> result = new DataIndexedEntry<>(index, convertJava(obj), type);
+                index++;
+                return result;
+            }
+        };
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/enchantments/CustomCraftBukkitEnchantment.java b/src/main/java/org/oilmod/spigot/enchantments/CustomCraftBukkitEnchantment.java
new file mode 100644
index 00000000..a73443e4
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/enchantments/CustomCraftBukkitEnchantment.java
@@ -0,0 +1,20 @@
+package org.oilmod.spigot.enchantments;
+
+import org.bukkit.craftbukkit.enchantments.CraftEnchantment;
+
+/**
+ * Created by sirati97 on 22.03.2016.
+ */
+public class CustomCraftBukkitEnchantment extends CraftEnchantment {
+    private CustomEnchantment nmsEnchantment;
+
+    public CustomCraftBukkitEnchantment(CustomEnchantment nmsEnchantment) {
+        super(nmsEnchantment);
+        this.nmsEnchantment = nmsEnchantment;
+    }
+
+    @Override
+    public String getName() {
+        return nmsEnchantment.getOilMod().getName().toUpperCase() + "_" + nmsEnchantment.getEnchantName().toUpperCase();
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/enchantments/CustomEnchantment.java b/src/main/java/org/oilmod/spigot/enchantments/CustomEnchantment.java
new file mode 100644
index 00000000..37ef1521
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/enchantments/CustomEnchantment.java
@@ -0,0 +1,55 @@
+package org.oilmod.spigot.enchantments;
+
+import org.oilmod.ApiOilMod;
+import net.minecraft.server.Enchantment;
+import net.minecraft.server.EnchantmentSlotType;
+import net.minecraft.server.EnumItemSlot;
+import net.minecraft.server.LocaleI18n;
+import net.minecraft.server.MinecraftKey;
+
+/**
+ * Created by sirati97 on 22.03.2016.
+ */
+public class CustomEnchantment extends Enchantment { //TODO redo this. this version never completed and required because of the new keying and stuff
+    private final ApiOilMod oilMod;
+    private final String enchantName;
+    private final String englishName;
+    private final MinecraftKey key;
+
+
+    protected CustomEnchantment(ApiOilMod oilMod, String enchantName, String englishName, Enchantment.Rarity enchantment_rarity, EnchantmentSlotType enchantmentslottype, EnumItemSlot... itemSlots) {
+        super(enchantment_rarity, enchantmentslottype, itemSlots);
+        this.key = new MinecraftKey(oilMod.getName() + ":" + enchantName);
+        this.oilMod = oilMod;
+        this.enchantName = enchantName;
+        this.englishName = englishName;
+    }
+
+    public String getEnchantName() {
+        return enchantName;
+    }
+
+    public ApiOilMod getOilMod() {
+        return oilMod;
+    }
+
+    public String getEnchantKey() {
+       return getMinecraftKey().toString();
+    }
+
+    public String getEnglishName() {
+        return englishName;
+    }
+
+    public String d(int i) {
+        return getEnchantName() + " " + LocaleI18n.get("enchantment.level." + i);
+    }
+
+    public String a() {
+        return "enchantment." + getOilMod().getName() + "." + getEnchantName();
+    }
+
+    public MinecraftKey getMinecraftKey() {
+        return key;
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/inventory/ApiItemFilter.java b/src/main/java/org/oilmod/spigot/inventory/ApiItemFilter.java
new file mode 100644
index 00000000..acb8d552
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/inventory/ApiItemFilter.java
@@ -0,0 +1,21 @@
+package org.oilmod.spigot.inventory;
+
+import org.oilmod.api.inventory.ItemFilter;
+import net.minecraft.server.ItemStack;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
+
+/**
+ * Created by sirati97 on 13.02.2016.
+ */
+public class ApiItemFilter implements IItemFilter {
+    private final ItemFilter bukkitFilter;
+
+    public ApiItemFilter(ItemFilter bukkitFilter) {
+        this.bukkitFilter = bukkitFilter;
+    }
+
+    @Override
+    public boolean allowed(ItemStack itemStack) {
+        return bukkitFilter.allowed(CraftItemStack.asCraftMirror(itemStack));
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/inventory/FilteredInventory.java b/src/main/java/org/oilmod/spigot/inventory/FilteredInventory.java
new file mode 100644
index 00000000..6b3cb673
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/inventory/FilteredInventory.java
@@ -0,0 +1,10 @@
+package org.oilmod.spigot.inventory;
+
+import net.minecraft.server.ItemStack;
+
+/**
+ * Created by sirati97 on 13.02.2016.
+ */
+public interface FilteredInventory {
+    boolean itemstackAddable(ItemStack  itemStack);
+}
diff --git a/src/main/java/org/oilmod/spigot/inventory/IItemFilter.java b/src/main/java/org/oilmod/spigot/inventory/IItemFilter.java
new file mode 100644
index 00000000..3d158908
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/inventory/IItemFilter.java
@@ -0,0 +1,10 @@
+package org.oilmod.spigot.inventory;
+
+import net.minecraft.server.ItemStack;
+
+/**
+ * Created by sirati97 on 13.02.2016.
+ */
+public interface IItemFilter {
+    boolean allowed(ItemStack itemStack);
+}
diff --git a/src/main/java/org/oilmod/spigot/inventory/ItemStackDataImpl.java b/src/main/java/org/oilmod/spigot/inventory/ItemStackDataImpl.java
new file mode 100644
index 00000000..e86e02bc
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/inventory/ItemStackDataImpl.java
@@ -0,0 +1,56 @@
+package org.oilmod.spigot.inventory;
+
+import org.oilmod.api.config.Compound;
+import org.oilmod.api.config.DataType;
+import org.oilmod.api.data.DataParent;
+import org.oilmod.api.data.IData;
+import org.oilmod.api.data.ItemStackData;
+import org.oilmod.spigot.util.OilSpigotUtil;
+import org.bukkit.inventory.ItemStack;
+import org.oilmod.spigot.util.OilSpigotUtil;
+
+/**
+ * Created by sirati97 on 26.06.2016 for spigot.
+ */
+public class ItemStackDataImpl extends ItemStackData {
+    private ItemStack itemStack;
+
+    public ItemStackDataImpl(String name, DataParent dataParent) {
+        super(name, dataParent);
+    }
+
+    @Override
+    public void saveTo(Compound parent, String name) {
+        net.minecraft.server.ItemStack nmsItemStack = OilSpigotUtil.toNMS(itemStack);
+        if (!nmsItemStack.isEmpty()) {
+            Compound compoundItemStack = parent.createCompound();
+            nmsItemStack.save(compoundItemStack);
+            parent.set(name, compoundItemStack);
+        }
+    }
+
+    @Override
+    public void loadFrom(Compound parent, String name) {
+        if (parent.containsKey(name, DataType.Subsection)) {
+            itemStack = OilSpigotUtil.toBukkit(net.minecraft.server.ItemStack.createStack(parent.getCompound(name)));
+        } else {
+            itemStack = null;
+        }
+    }
+
+    @Override
+    public ItemStack getData() {
+        return itemStack;
+    }
+
+    @Override
+    public void setData(ItemStack itemStack) {
+        this.itemStack = itemStack;
+    }
+
+    @Override
+    public void onCloned(IData<ItemStack> iData) {
+        ItemStack original = iData.getData();
+        this.setData(original==null?null:original.clone());
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/inventory/NoItemFilter.java b/src/main/java/org/oilmod/spigot/inventory/NoItemFilter.java
new file mode 100644
index 00000000..22521484
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/inventory/NoItemFilter.java
@@ -0,0 +1,13 @@
+package org.oilmod.spigot.inventory;
+
+import net.minecraft.server.ItemStack;
+
+/**
+ * Created by sirati97 on 13.02.2016.
+ */
+public class NoItemFilter implements IItemFilter {
+    @Override
+    public boolean allowed(ItemStack itemStack) {
+        return true;
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/inventory/OilBukkitCraftInventoryFurnace.java b/src/main/java/org/oilmod/spigot/inventory/OilBukkitCraftInventoryFurnace.java
new file mode 100644
index 00000000..a7d2e787
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/inventory/OilBukkitCraftInventoryFurnace.java
@@ -0,0 +1,50 @@
+package org.oilmod.spigot.inventory;
+
+import org.bukkit.block.Furnace;
+import org.bukkit.craftbukkit.inventory.CraftInventory;
+import org.bukkit.event.inventory.InventoryType;
+import org.bukkit.inventory.FurnaceInventory;
+import org.bukkit.inventory.ItemStack;
+
+/**
+ * Created by sirati97 on 13.02.2016.
+ */
+public class OilBukkitCraftInventoryFurnace extends CraftInventory implements FurnaceInventory {
+    public OilBukkitCraftInventoryFurnace(OilInventoryFurnace inventory) {
+        super(inventory);
+    }
+
+    public ItemStack getResult() {
+        return getItem(2);
+    }
+
+    public ItemStack getFuel() {
+        return getItem(1);
+    }
+
+    public ItemStack getSmelting() {
+        return getItem(0);
+    }
+
+    public void setFuel(ItemStack stack) {
+        setItem(1,stack);
+    }
+
+    public void setResult(ItemStack stack) {
+        setItem(2,stack);
+    }
+
+    public void setSmelting(ItemStack stack) {
+        setItem(0,stack);
+    }
+
+    @Override
+    public Furnace getHolder() {
+        return null;
+    }
+
+    @Override
+    public InventoryType getType() {
+        return InventoryType.FURNACE;
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/inventory/OilBukkitCraftInventoryPortableCrafting.java b/src/main/java/org/oilmod/spigot/inventory/OilBukkitCraftInventoryPortableCrafting.java
new file mode 100644
index 00000000..7c9a3952
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/inventory/OilBukkitCraftInventoryPortableCrafting.java
@@ -0,0 +1,29 @@
+package org.oilmod.spigot.inventory;
+
+import net.minecraft.server.IInventory;
+import org.bukkit.craftbukkit.inventory.CraftInventoryCrafting;
+import org.bukkit.event.inventory.InventoryType;
+
+/**
+ * Created by sirati97 on 26.02.2016.
+ */
+public class OilBukkitCraftInventoryPortableCrafting extends CraftInventoryCrafting {
+    public OilBukkitCraftInventoryPortableCrafting(OilInventoryPortableCrafting inventory) {
+        super(inventory, inventory.getResultInventory());
+    }
+
+    @Override
+    public OilInventoryPortableCrafting getMatrixInventory() {
+        return (OilInventoryPortableCrafting) super.getMatrixInventory();
+    }
+
+    @Override
+    public IInventory getResultInventory() {
+        return getMatrixInventory().getResultInventory();
+    }
+
+    @Override
+    public InventoryType getType() {
+        return getMatrixInventory().getInvType();
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/inventory/OilContainerChest.java b/src/main/java/org/oilmod/spigot/inventory/OilContainerChest.java
new file mode 100644
index 00000000..2447737f
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/inventory/OilContainerChest.java
@@ -0,0 +1,38 @@
+package org.oilmod.spigot.inventory;
+
+import net.minecraft.server.ContainerChest;
+import net.minecraft.server.EntityHuman;
+import net.minecraft.server.IInventory;
+import net.minecraft.server.Slot;
+import org.bukkit.craftbukkit.inventory.CraftInventoryView;
+
+/**
+ * Created by sirati97 on 14.02.2016.
+ */
+public class OilContainerChest extends ContainerChest {
+    private final OilInventoryChest inventory;
+    private CraftInventoryView bukkitEntity = null;
+    private EntityHuman player;
+
+
+    public OilContainerChest(IInventory iinventoryPlayer, OilInventoryChest iinventoryChest, EntityHuman entityhuman) {
+        super(iinventoryPlayer, iinventoryChest, entityhuman);
+        this.inventory = iinventoryChest;
+        this.player = entityhuman;
+    }
+
+    @Override
+    protected Slot createChestSlot(IInventory inventory, int row, int column, int index, int j, int k) {
+        return new OilSlot((OilIInventory) inventory,index,j,k);
+    }
+
+    @Override
+    public CraftInventoryView getBukkitView() {
+        if (bukkitEntity != null) {
+            return bukkitEntity;
+        }
+
+        bukkitEntity = new CraftInventoryView(this.player.getBukkitEntity(), inventory.getBukkitInventory(), this);
+        return bukkitEntity;
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/inventory/OilContainerFurnace.java b/src/main/java/org/oilmod/spigot/inventory/OilContainerFurnace.java
new file mode 100644
index 00000000..b82ee9d0
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/inventory/OilContainerFurnace.java
@@ -0,0 +1,43 @@
+package org.oilmod.spigot.inventory;
+
+import net.minecraft.server.ContainerFurnace;
+import net.minecraft.server.IInventory;
+import net.minecraft.server.PlayerInventory;
+import net.minecraft.server.Slot;
+import org.bukkit.craftbukkit.inventory.CraftInventoryView;
+
+/**
+ * Created by sirati97 on 14.02.2016.
+ */
+public class OilContainerFurnace extends ContainerFurnace {
+    private final OilInventoryFurnace furnace;
+    // CraftBukkit start
+    private CraftInventoryView bukkitEntity = null;
+    private PlayerInventory player;
+
+    @Override
+    public CraftInventoryView getBukkitView() {
+        if (bukkitEntity != null) {
+            return bukkitEntity;
+        }
+
+        OilBukkitCraftInventoryFurnace inventory = furnace.getBukkitInventory();
+        bukkitEntity = new CraftInventoryView(this.player.player.getBukkitEntity(), inventory, this);
+        return bukkitEntity;
+    }
+    // CraftBukkit end
+
+    public OilContainerFurnace(PlayerInventory playerinventory, OilInventoryFurnace furnace) {
+        super(playerinventory, furnace);
+        this.furnace = furnace;
+        this.player = playerinventory; // CraftBukkit - save player
+
+    }
+
+    protected void addFurnaceSlots(PlayerInventory playerinventory, IInventory iinventory) {
+        OilInventoryFurnace furnace = (OilInventoryFurnace)iinventory;
+        this.a(new OilSlot(furnace, 0, 56, 17));
+        this.a((Slot) (new OilSlotFurnaceFuel(furnace, 1, 56, 53)));
+        this.a((Slot) (new OilSlotFurnaceResult(playerinventory.player, furnace, 2, 116, 35)));
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/inventory/OilContainerHopper.java b/src/main/java/org/oilmod/spigot/inventory/OilContainerHopper.java
new file mode 100644
index 00000000..051e2fc2
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/inventory/OilContainerHopper.java
@@ -0,0 +1,39 @@
+package org.oilmod.spigot.inventory;
+
+import net.minecraft.server.ContainerHopper;
+import net.minecraft.server.EntityHuman;
+import net.minecraft.server.IInventory;
+import net.minecraft.server.PlayerInventory;
+import net.minecraft.server.Slot;
+import org.bukkit.craftbukkit.inventory.CraftInventoryView;
+
+/**
+ * Created by sirati97 on 14.02.2016.
+ */
+public class OilContainerHopper extends ContainerHopper {
+    private final OilInventoryChest inventory;
+    private CraftInventoryView bukkitEntity = null;
+    private EntityHuman player;
+
+
+    public OilContainerHopper(PlayerInventory iinventoryPlayer, OilInventoryChest iinventoryChest, EntityHuman entityhuman) {
+        super(iinventoryPlayer, iinventoryChest, entityhuman);
+        this.inventory = iinventoryChest;
+        this.player = entityhuman;
+    }
+
+    @Override
+    protected Slot createChestSlot(IInventory inventory, int index, int j, int k) {
+        return new OilSlot((OilIInventory) inventory,index,j,k);
+    }
+
+    @Override
+    public CraftInventoryView getBukkitView() {
+        if (bukkitEntity != null) {
+            return bukkitEntity;
+        }
+
+        bukkitEntity = new CraftInventoryView(this.player.getBukkitEntity(), inventory.getBukkitInventory(), this);
+        return bukkitEntity;
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/inventory/OilContainerPortableCrafting.java b/src/main/java/org/oilmod/spigot/inventory/OilContainerPortableCrafting.java
new file mode 100644
index 00000000..afba781e
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/inventory/OilContainerPortableCrafting.java
@@ -0,0 +1,61 @@
+package org.oilmod.spigot.inventory;
+
+import net.minecraft.server.ContainerWorkbench;
+import net.minecraft.server.EntityHuman;
+import net.minecraft.server.IInventory;
+import net.minecraft.server.oilmod.IInventoryCrafting;
+import net.minecraft.server.ItemStack;
+import net.minecraft.server.PlayerInventory;
+import net.minecraft.server.Slot;
+import org.bukkit.craftbukkit.inventory.CraftInventoryView;
+
+/**
+ * Created by sirati97 on 26.02.2016.
+ */
+public class OilContainerPortableCrafting extends ContainerWorkbench {
+
+    private OilInventoryPortableCrafting craftInventory;
+    // CraftBukkit start
+    private CraftInventoryView bukkitEntity = null;
+    private PlayerInventory player;
+    // CraftBukkit end
+
+    public OilContainerPortableCrafting(PlayerInventory playerinventory,OilInventoryPortableCrafting craftInventory) {
+        super(playerinventory, craftInventory, craftInventory.getResultInventory(),null,null);
+        // CraftBukkit start - Switched order of IInventory construction and stored player
+        this.craftInventory = craftInventory;
+        this.player = playerinventory;
+        // CraftBukkit end
+        this.bukkitEntity = new CraftInventoryView(this.player.player.getBukkitEntity(), craftInventory.getBukkitInventory(), this);
+
+    }
+
+    @Override
+    protected void addResultSlot(PlayerInventory playerinventory, IInventoryCrafting craftInventory, IInventory resultInventory) {
+        this.craftInventory = (OilInventoryPortableCrafting) craftInventory;
+        this.a((Slot) (new OilSlotPortableCraftingResult(playerinventory.player, (OilInventoryPortableCrafting) craftInventory, 0, 124, 35)));
+    }
+
+    public void a(IInventory iinventory) {
+        craftInventory.updateResult();
+    }
+
+    public void b(EntityHuman entityhuman) {
+        super.b(entityhuman);
+    }
+
+    public boolean a(EntityHuman entityhuman) {
+        return true;
+    }
+
+    public boolean a(ItemStack itemstack, Slot slot) {
+        return slot.getInventory() != this.craftInventory.getResultInventory() && super.a(itemstack, slot); //OilSpigot - changed .inventory to .getInventory()
+    }
+
+    // CraftBukkit start
+    @Override
+    public CraftInventoryView getBukkitView() {
+        return bukkitEntity;
+    }
+    // CraftBukkit end
+}
diff --git a/src/main/java/org/oilmod/spigot/inventory/OilCraftResultInventory.java b/src/main/java/org/oilmod/spigot/inventory/OilCraftResultInventory.java
new file mode 100644
index 00000000..63b311f8
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/inventory/OilCraftResultInventory.java
@@ -0,0 +1,156 @@
+package org.oilmod.spigot.inventory;
+
+import net.minecraft.server.ChatComponentText;
+import net.minecraft.server.ChatMessage;
+import net.minecraft.server.EntityHuman;
+import net.minecraft.server.IChatBaseComponent;
+import net.minecraft.server.oilmod.IInventoryCraftResult;
+import net.minecraft.server.IRecipe;
+import net.minecraft.server.ItemStack;
+import org.apache.commons.lang3.NotImplementedException;
+import org.bukkit.Location;
+import org.bukkit.craftbukkit.entity.CraftHumanEntity;
+import org.bukkit.entity.HumanEntity;
+
+import javax.annotation.Nullable;
+import java.util.Iterator;
+import java.util.List;
+
+/**
+ * Created by sirati97 on 26.02.2016.
+ */
+public class OilCraftResultInventory implements IInventoryCraftResult {
+
+    // CraftBukkit start
+    private int maxStack = MAX_STACK;
+    private OilInventoryPortableCrafting parent;
+
+    public List<ItemStack> getContents() {
+        return parent.getResults();
+    }
+
+    public org.bukkit.inventory.InventoryHolder getOwner() {
+        return null; // Result slots don't get an owner
+    }
+
+    // Don't need a transaction; the InventoryCrafting keeps track of it for us
+    public void onOpen(CraftHumanEntity who) {}
+    public void onClose(CraftHumanEntity who) {}
+    public java.util.List<HumanEntity> getViewers() {
+        return new java.util.ArrayList<HumanEntity>();
+    }
+
+    public void setMaxStackSize(int size) {
+        maxStack = size;
+    }
+    // CraftBukkit end
+
+    public OilCraftResultInventory(OilInventoryPortableCrafting parent) {
+        this.parent = parent;
+
+    }
+
+    public int getSize() {
+        return parent.getResults().size();
+    }
+
+    public ItemStack getItem(int i) {
+        return parent.getResultItem(i);
+    }
+
+    public String getName() {
+        return "Result";
+    }
+
+    public boolean hasCustomName() {
+        return false;
+    }
+
+    public IChatBaseComponent getScoreboardDisplayName() {
+        return (IChatBaseComponent) (this.hasCustomName() ? new ChatComponentText(this.getName()) : new ChatMessage(this.getName(), new Object[0]));
+    }
+
+    public ItemStack splitStack(int i, int j) {
+        ItemStack stack = this.getItem(i);
+        this.setItem(i, ItemStack.a);
+        return stack;
+    }
+
+    public ItemStack splitWithoutUpdate(int i) {
+        return splitStack(i,0);
+    }
+
+    public void setItem(int i, ItemStack itemstack) {
+        parent.setResultItem(i,itemstack);
+    }
+
+    public int getMaxStackSize() {
+        return maxStack; // CraftBukkit
+    }
+
+    public void update() {}
+
+    public boolean a(EntityHuman entityhuman) {
+        return true;
+    }
+
+    public void startOpen(EntityHuman entityhuman) {}
+
+    public void closeContainer(EntityHuman entityhuman) {}
+
+    @Override
+    public boolean b(int i, ItemStack itemstack) {
+        return true;
+    }
+
+    public int getProperty(int i) {
+        return 0;
+    }
+
+    @Override
+    public void setProperty(int i, int j) {
+
+    }
+
+    public int h() {
+        return 0;
+    }
+
+    public void clear() {
+        getContents().clear();
+    }
+
+
+
+    //KEEPSYNC from InventorySubcontainer.java
+    public boolean x_() {
+        Iterator iterator = getContents().iterator();
+
+        ItemStack itemstack;
+
+        do {
+            if (!iterator.hasNext()) {
+                return true;
+            }
+
+            itemstack = (ItemStack) iterator.next();
+        } while (itemstack.isEmpty());
+
+        return false;
+    }
+
+    @Override
+    public Location getLocation() {
+        throw new NotImplementedException("If you see that message sirati97 with an error log");
+    }
+
+    @Override
+    public void a(@Nullable IRecipe irecipe) {
+        parent.setCurrentRecipe(irecipe);
+    }
+
+    @Override
+    public IRecipe i() {
+        return parent.getCurrentRecipe();
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/inventory/OilIInventory.java b/src/main/java/org/oilmod/spigot/inventory/OilIInventory.java
new file mode 100644
index 00000000..f826cfd9
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/inventory/OilIInventory.java
@@ -0,0 +1,15 @@
+package org.oilmod.spigot.inventory;
+
+import org.oilmod.api.config.CompoundSerializable;
+import org.oilmod.api.inventory.ModInventoryObjectBase;
+import org.oilmod.api.inventory.ModNMSIInventory;
+import net.minecraft.server.BukkitIInventory;
+import net.minecraft.server.IInventory;
+import net.minecraft.server.ITileEntityContainer;
+
+/**
+ * Created by sirati97 on 13.02.2016.
+ */
+public interface OilIInventory<APIObject extends ModInventoryObjectBase> extends IInventory, CompoundSerializable, ModNMSIInventory<APIObject>, FilteredInventory, ITileEntityContainer, BukkitIInventory {
+    boolean isValid();
+}
diff --git a/src/main/java/org/oilmod/spigot/inventory/OilInventoryBase.java b/src/main/java/org/oilmod/spigot/inventory/OilInventoryBase.java
new file mode 100644
index 00000000..eef14e7f
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/inventory/OilInventoryBase.java
@@ -0,0 +1,284 @@
+package org.oilmod.spigot.inventory;
+
+import org.apache.commons.lang3.NotImplementedException;
+import org.oilmod.api.config.Compound;
+import org.oilmod.api.config.CompoundSerializable;
+import org.oilmod.api.config.DataList;
+import org.oilmod.api.config.DataType;
+import org.oilmod.api.inventory.ModInventoryObjectBase;
+import org.oilmod.api.userinterface.IInteractableUIElement;
+import org.oilmod.api.util.WeakReferenceTicker;
+import org.oilmod.spigot.inventory.custom.slot.OilInventoryViewSlot;
+import net.minecraft.server.*;
+import org.apache.commons.lang.Validate;
+import org.bukkit.Location;
+import org.bukkit.craftbukkit.entity.CraftHumanEntity;
+import org.bukkit.craftbukkit.inventory.CraftInventory;
+import org.bukkit.entity.HumanEntity;
+import org.bukkit.inventory.InventoryHolder;
+import org.oilmod.spigot.inventory.custom.slot.OilInventoryViewSlot;
+
+import java.lang.ref.WeakReference;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
+/**
+ * Created by sirati97 on 13.02.2016.
+ */
+public abstract class OilInventoryBase<APIObject extends ModInventoryObjectBase> implements OilIInventory<APIObject> {
+    private int maxStack = MAX_STACK;
+    private final List<HumanEntity> transaction = new java.util.ArrayList<HumanEntity>();
+    private String title;
+    private final WeakReference<InventoryHolder> owner;
+    private final CraftInventory bukkitInventory;
+    private final IItemFilter itemFilter;
+    public final NonNullList<ItemStack> items;
+    private WeakReference<APIObject> modInventoryObject;
+    private WeakReferenceTicker ticker;
+    private final int size;
+    private final boolean needsOwner;
+
+    public OilInventoryBase(InventoryHolder owner, String title, int size, WeakReferenceTicker ticker, IItemFilter itemFilter, boolean needsOwner) {
+        Validate.isTrue(title == null || title.length() <= 32, "Title cannot be longer than 32 characters");
+        this.items = initItems(size);
+        this.size = size;
+        this.title = title;
+        this.owner = new WeakReference<InventoryHolder>(owner);
+        this.bukkitInventory = createBukkit();
+        this.itemFilter = itemFilter==null?new NoItemFilter():itemFilter;
+        this.ticker = ticker;
+        this.needsOwner = needsOwner;
+        if (isTickable() && ticker != null) {
+            ticker.add(this);
+        }
+    }
+
+    protected NonNullList<ItemStack> initItems(int size) {
+        return NonNullList.a(size, ItemStack.a);
+    }
+
+    public ItemStack splitStack(int i, int j) {
+        return ContainerUtil.a(this.items, i, j);
+    }
+
+    public ItemStack splitWithoutUpdate(int i) {
+        return ContainerUtil.a(this.items, i);
+    }
+
+    protected CraftInventory createBukkit() {
+        return new CraftInventory(this);
+    }
+
+    public int getSize() {
+        return size;
+    }
+
+    public int getTotalSize() {
+        return size;
+    }
+
+    public ItemStack getItem(int i) {
+        return items.get(i);
+    }
+
+    public int getMaxStackSize() {
+        return maxStack;
+    }
+
+    public void setMaxStackSize(int size) {
+        maxStack = size;
+    }
+
+    public void update() {}
+
+    public void onOpen(CraftHumanEntity who) {
+        transaction.add(who);
+    }
+
+    public void onClose(CraftHumanEntity who) {
+        transaction.remove(who);
+    }
+
+    public List<HumanEntity> getViewers() {
+        return transaction;
+    }
+
+    public InventoryHolder getOwner() {
+        return owner.get();
+    }
+
+    @Override
+    public boolean isValid() {
+        return !needsOwner || getOwner()!=null;
+    }
+
+    public abstract String getContainerLangKey();
+
+    @Override
+    public String getName() {
+        return hasCustomName()?title: getContainerLangKey();
+    }
+    public List<ItemStack> getContents() {
+        return this.items;
+    }
+
+    @Override
+    public boolean hasCustomName() {
+        return title != null;
+    }
+
+    @Override
+    public IChatBaseComponent getScoreboardDisplayName() {
+        return new ChatComponentText(title);
+    }
+
+    @Override
+    public CompoundSerializable cloneIfCloneable() {
+        return this;
+    }
+
+    @Override
+    public Object getNMSInventory() {
+        return this;
+    }
+
+    @Override
+    public Object getOilModInventory() {
+        return this;
+    }
+
+    @Override
+    public CraftInventory getBukkitInventory() {
+        return bukkitInventory;
+    }
+
+    @Override
+    public boolean itemstackAddable(ItemStack itemStack) {
+        return itemFilter.allowed(itemStack);
+    }
+
+    @Override
+    public void startOpen(EntityHuman entityHuman) {}
+
+    @Override
+    public void closeContainer(EntityHuman entityHuman) {}
+
+    public boolean a(EntityHuman entityhuman) {
+        return true;
+    }
+
+    public void a(String s) {
+        this.title = s;
+    }
+
+    public void setItem(int i, ItemStack itemstack) {
+        items.set(i,itemstack);
+        if (this.getMaxStackSize() > 0 && itemstack.getCount() > this.getMaxStackSize()) {
+            itemstack.setCount(this.getMaxStackSize());
+        }
+    }
+
+    @Override
+    public int getProperty(int i) {
+        return 0;
+    }
+
+    @Override
+    public void setProperty(int i, int i1) {}
+
+    public abstract Container createContainer(PlayerInventory playerinventory, EntityHuman entityhuman);
+
+    @Override
+    public void load(Compound compound) {
+        loadItemsFromCompound(compound, this.items, "Items");
+    }
+
+    @Override
+    public void save(Compound compound) {
+        saveItemsToCompound(compound, this.items, "Items");
+    }
+
+    public static void saveItemsToCompound(Compound compound, NonNullList<ItemStack> items, String key) {
+        DataList<Compound> itemsCompoundList = compound.createList(DataType.Subsection);
+        for (int i = 0; i < items.size(); ++i) {
+            ItemStack item = items.get(i);
+            if (!item.isEmpty()) {
+                Compound compound1 = compound.createCompound();
+                compound1.setByte("Slot", (byte) i);
+                item.save(compound1);
+                itemsCompoundList.append(compound1);
+            }
+        }
+        compound.setList(key, itemsCompoundList);
+    }
+
+    public static  void loadItemsFromCompound(Compound compound, NonNullList<ItemStack> items, String key) {
+        DataList<Compound> itemsCompoundList = compound.getList(key);
+        items.clear();
+        for (int i = 0; i < itemsCompoundList.size(); ++i) {
+            Compound compound1 = itemsCompoundList.get(i);
+            int j = compound1.getByte("Slot") & 255;
+
+            if (j >= 0 && j < items.size()) {
+                items.set(j, ItemStack.createStack(compound1));
+            }
+        }
+    }
+
+    @Override
+    public void setOilApiMirror(APIObject modInventoryObject) {
+        this.modInventoryObject = new WeakReference<>(modInventoryObject);
+    }
+
+    public APIObject getModInventoryObject() {
+        return modInventoryObject.get();
+    }
+
+    @Override
+    public void tick(int i) {
+
+    }
+
+    @Override
+    public boolean isTickable() {
+        return false;
+    }
+
+    @Override
+    public Location getLocation() {
+        throw new NotImplementedException("If you see that message sirati97 with an error log");
+    }
+
+    @Override
+    public IInteractableUIElement createUIElement() {
+        return new OilInventoryViewSlot(this);
+    }
+
+
+    //KEEPSYNC from InventorySubcontainer.java
+    public boolean x_() {
+        Iterator iterator = this.items.iterator();
+
+        ItemStack itemstack;
+
+        do {
+            if (!iterator.hasNext()) {
+                return true;
+            }
+
+            itemstack = (ItemStack) iterator.next();
+        } while (itemstack.isEmpty());
+
+        return false;
+    }
+
+    public void clear() {
+        items.clear();
+    }
+
+    @Override
+    public void setTitle(String title) {
+        this.title = title;
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/inventory/OilInventoryChest.java b/src/main/java/org/oilmod/spigot/inventory/OilInventoryChest.java
new file mode 100644
index 00000000..46eaf9fa
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/inventory/OilInventoryChest.java
@@ -0,0 +1,44 @@
+package org.oilmod.spigot.inventory;
+
+import org.oilmod.api.inventory.ModInventoryObject;
+import net.minecraft.server.Container;
+import net.minecraft.server.EntityHuman;
+import net.minecraft.server.ItemStack;
+import net.minecraft.server.PlayerInventory;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
+import org.bukkit.inventory.InventoryHolder;
+
+/**
+ * Created by sirati97 on 17.01.2016.
+ */
+public class OilInventoryChest extends OilInventoryBase<ModInventoryObject> {
+
+    public OilInventoryChest(InventoryHolder owner, int size, String title, IItemFilter itemFilter) {
+        super(owner, title, size, null, itemFilter, true);
+    }
+
+    public boolean b(int i, ItemStack itemstack) {
+        return true;
+    }
+
+    @Override
+    public int h() { //what does this dooooooo
+        return 0;
+    }
+
+
+    @Override
+    public String getContainerLangKey() {
+        return getSize()==5?"container.hopper":"container.chest";
+    }
+
+    @Override
+    public Container createContainer(PlayerInventory playerinventory, EntityHuman entityhuman) {
+        return getSize()==5?new OilContainerHopper(entityhuman.inventory, this, entityhuman):new OilContainerChest(entityhuman.inventory, this, entityhuman);
+    }
+
+    @Override
+    public String getContainerName() {
+        return getSize()==5?"minecraft:hopper":"minecraft:chest";
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/inventory/OilInventoryFurnace.java b/src/main/java/org/oilmod/spigot/inventory/OilInventoryFurnace.java
new file mode 100644
index 00000000..10d890bb
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/inventory/OilInventoryFurnace.java
@@ -0,0 +1,350 @@
+package org.oilmod.spigot.inventory;
+
+
+
+import java.util.Iterator;
+// CraftBukkit start
+import java.util.List;
+
+import org.oilmod.spigot.bukkit.stubs.OilBlockStub;
+import net.minecraft.server.*;
+import org.bukkit.craftbukkit.event.CraftEventFactory;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
+import org.bukkit.entity.HumanEntity;
+import org.bukkit.event.inventory.FurnaceBurnEvent;
+import org.bukkit.event.inventory.FurnaceSmeltEvent;
+import org.bukkit.craftbukkit.entity.CraftHumanEntity;
+// CraftBukkit end
+
+//OilSpigot start
+import org.oilmod.api.config.Compound;
+import org.oilmod.api.inventory.ModFurnaceInventoryObject;
+import org.oilmod.api.util.WeakReferenceTicker;
+import org.bukkit.inventory.InventoryHolder;
+import org.oilmod.spigot.bukkit.stubs.OilBlockStub;
+//OilSpigot end
+
+/**
+ * Created by sirati97 on 13.02.2016.
+ */
+public class OilInventoryFurnace extends OilInventoryBase<ModFurnaceInventoryObject> {
+    //OilSpigot start
+    public int burnTime;
+    private int ticksForCurrentFuel;
+    public int cookTime;
+    private int cookTimeTotal;
+
+    private boolean wasBurning = false;
+
+    public OilInventoryFurnace(InventoryHolder owner, String title, WeakReferenceTicker ticker, IItemFilter itemFilter) {
+        super(owner, title, 3, ticker, itemFilter, true);
+    }
+    //OilSpigot end
+
+    public void setItem(int i, ItemStack itemstack) {
+        ItemStack itemstack1 = (ItemStack) this.items.get(i);
+        boolean flag = !itemstack.isEmpty() && itemstack.doMaterialsMatch(itemstack1) && ItemStack.equals(itemstack, itemstack1);
+        //OilSpigot start
+        super.setItem(i,itemstack);
+        //OilSpigot end
+
+        if (i == 0 && !flag) {
+            this.cookTimeTotal = this.a(itemstack);
+            this.cookTime = 0;
+            this.update();
+        }
+
+    }
+
+    //OilSpigot start
+    public String getContainerLangKey() {
+        return "container.furnace";
+    }
+
+
+    @Override
+    public void load(Compound compound) {
+        super.load(compound); //This loads items
+        this.burnTime = compound.getShort("BurnTime");
+        this.cookTime = compound.getShort("CookTime");
+        this.cookTimeTotal = compound.getShort("CookTimeTotal");
+        this.ticksForCurrentFuel = fuelTime(this.items.get(1));
+    }
+
+    @Override
+    public void save(Compound compound) {
+        super.save(compound); //This saves items
+        compound.setShort("BurnTime", (short) this.burnTime);
+        compound.setShort("CookTime", (short) this.cookTime);
+        compound.setShort("CookTimeTotal", (short) this.cookTimeTotal);
+        //TODO: check if furnances now support custom names
+    }
+    //OilSpigot end
+
+    public boolean isBurning() {
+        return this.burnTime > 0;
+    }
+
+    //OilSpigot start - added param PAIL e smelt
+    public void smelt(int elapsedTicks) {
+        //OilSpigot end
+        boolean flag1 = false;
+
+
+        // CraftBukkit start - Use wall time instead of ticks for cooking
+
+        //OilSpigot start - removed ticks calculation as we use the parameter
+
+        // CraftBukkit - moved from below
+        if (this.isBurning() && this.canBurn()) {
+            this.cookTime += elapsedTicks;
+            //OilSpigot start
+            while (this.cookTime >= this.cookTimeTotal) {
+                this.cookTime -= this.cookTimeTotal;
+                this.cookTimeTotal = this.a((ItemStack) this.items.get(0));
+                this.burn();
+                flag1 = true;
+            }
+            //OilSpigot end
+        } else {
+            this.cookTime = 0;
+        }
+        // CraftBukkit end
+
+
+        if (this.isBurning()) {
+            this.burnTime -= elapsedTicks; // CraftBukkit - use elapsedTicks in place of constant
+        }
+
+
+
+        //OilSpigot start
+        ItemStack itemstack = (ItemStack) this.items.get(1);
+        if (!this.isBurning() && (itemstack.isEmpty() || ((ItemStack) this.items.get(0)).isEmpty())) {
+            if (!this.isBurning() && this.cookTime > 0) {
+                this.cookTime = MathHelper.clamp(this.cookTime - 2, 0, this.cookTimeTotal);
+            }
+        } else {
+            // CraftBukkit start - Handle multiple elapsed ticks
+            if (this.burnTime <= 0 && this.canBurn()) { // CraftBukkit - == to <=
+                CraftItemStack fuel = CraftItemStack.asCraftMirror(itemstack);
+
+                //OilSpigot: fake the block so that the event works properly //TODO find better way
+                FurnaceBurnEvent furnaceBurnEvent = new FurnaceBurnEvent(new OilBlockStub(org.bukkit.Material.BURNING_FURNACE), fuel, fuelTime(itemstack));
+                CraftEventFactory.callEvent(furnaceBurnEvent);
+
+                if (furnaceBurnEvent.isCancelled()) {
+                    return;
+                }
+
+                this.ticksForCurrentFuel = furnaceBurnEvent.getBurnTime();
+                this.burnTime += this.ticksForCurrentFuel;
+                //if (this.burnTime > 0 && furnaceBurnEvent.isBurning()) {//*/
+                if (this.burnTime > 0) {
+                    // CraftBukkit end
+                    flag1 = true;
+                    if (!itemstack.isEmpty()) {
+                        Item item = itemstack.getItem();
+
+                        itemstack.subtract(1);
+                        if (itemstack.isEmpty()) {
+                            Item item1 = item.q();
+
+                            this.items.set(1, item1 == null ? ItemStack.a : new ItemStack(item1));
+                        }
+                    }
+                }
+            }
+        }
+
+        //OilSpigot calling onGoneOut and onStartFire
+        if (wasBurning != this.isBurning()) {
+            flag1 = true;
+            if (wasBurning) {
+                onGoneOut();
+            } else {
+                onStartFire();
+            }
+        }
+        //OilSpigot end
+
+        if (flag1) {
+            this.update();
+        }
+
+    }
+
+    //OilSpigot start
+    protected void onStartFire(){}
+    protected void onGoneOut(){}
+    //OilSpigot end
+
+    public int a(ItemStack itemstack) {
+        return 200;
+    }
+
+    private boolean canBurn() {
+        return TileEntityFurnace.canBurn(this.items.get(0), this.items.get(2), getMaxStackSize());
+    }
+
+    public void burn() {
+        if (this.canBurn()) {
+            ItemStack itemstack = (ItemStack) this.items.get(0);
+            ItemStack itemstack1 = RecipesFurnace.getInstance().getResult(itemstack);
+            ItemStack itemstack2 = (ItemStack) this.items.get(2);
+
+            // CraftBukkit start - fire FurnaceSmeltEvent
+            CraftItemStack source = CraftItemStack.asCraftMirror(itemstack);
+            org.bukkit.inventory.ItemStack result = CraftItemStack.asCraftMirror(itemstack1); //OilSpigot - use asCraftMirror
+
+            //OilSpigot: fake the block so that the event works properly //TODO find better way
+            FurnaceSmeltEvent furnaceSmeltEvent = new FurnaceSmeltEvent(new OilBlockStub(org.bukkit.Material.BURNING_FURNACE), source, result);
+            CraftEventFactory.callEvent(furnaceSmeltEvent);
+
+            if (furnaceSmeltEvent.isCancelled()) {
+                return;
+            }
+
+            result = furnaceSmeltEvent.getResult();
+            itemstack1 = CraftItemStack.asNMSCopy(result);
+
+            if (!itemstack1.isEmpty()) {
+                if (itemstack2.isEmpty()) {
+                    this.items.set(2, itemstack1.cloneItemStack());
+                } else if (CraftItemStack.asCraftMirror(itemstack2).isSimilar(result)) {
+                    itemstack2.add(itemstack1.getCount());
+                } else {
+                    return;
+                }
+            }
+
+            /*
+            if (itemstack2.isEmpty()) {
+                this.items.set(2, itemstack1.cloneItemStack());
+            } else if (itemstack2.getItem() == itemstack1.getItem()) {
+                itemstack2.add(1);
+            }
+            */
+            // CraftBukkit end
+
+            if (itemstack.getItem() == Item.getItemOf(Blocks.SPONGE) && itemstack.getData() == 1 && !((ItemStack) this.items.get(1)).isEmpty() && ((ItemStack) this.items.get(1)).getItem() == Items.BUCKET) {
+                this.items.set(1, new ItemStack(Items.WATER_BUCKET));
+            }
+
+            itemstack.subtract(1);
+        }
+    }
+
+    public static int fuelTime(ItemStack itemstack) {
+        if (itemstack.isEmpty()) {
+            return 0;
+        } else {
+            Item item = itemstack.getItem();
+
+            return item == Item.getItemOf(Blocks.WOODEN_SLAB) ? 150 : (item == Item.getItemOf(Blocks.WOOL) ? 100 : (item == Item.getItemOf(Blocks.CARPET) ? 67 : (item == Item.getItemOf(Blocks.LADDER) ? 300 : (item == Item.getItemOf(Blocks.WOODEN_BUTTON) ? 100 : (Block.asBlock(item).getBlockData().getMaterial() == Material.WOOD ? 300 : (item == Item.getItemOf(Blocks.COAL_BLOCK) ? 16000 : (item instanceof ItemTool && "WOOD".equals(((ItemTool) item).h()) ? 200 : (item instanceof ItemSword && "WOOD".equals(((ItemSword) item).h()) ? 200 : (item instanceof ItemHoe && "WOOD".equals(((ItemHoe) item).g()) ? 200 : (item == Items.STICK ? 100 : (item != Items.BOW && item != Items.FISHING_ROD ? (item == Items.SIGN ? 200 : (item == Items.COAL ? 1600 : (item == Items.LAVA_BUCKET ? 20000 : (item != Item.getItemOf(Blocks.SAPLING) && item != Items.BOWL ? (item == Items.BLAZE_ROD ? 2400 : (item instanceof ItemDoor && item != Items.IRON_DOOR ? 200 : (item instanceof ItemBoat ? 400 : 0))) : 100)))) : 300)))))))))));
+        }
+    }
+
+    public static boolean isFuel(ItemStack itemstack) {
+        return fuelTime(itemstack) > 0;
+    }
+
+    public boolean b(int i, ItemStack itemstack) {
+        if (i == 2) {
+            return false;
+        } else if (i != 1) {
+            return true;
+        } else {
+            ItemStack itemstack1 = (ItemStack) this.items.get(1);
+
+            return isFuel(itemstack) || SlotFurnaceFuel.d_(itemstack) && itemstack1.getItem() != Items.BUCKET;
+        }
+    }
+
+    public Container createContainer(PlayerInventory playerinventory, EntityHuman entityhuman) {
+        //OilSpigot start
+        return new OilContainerFurnace(playerinventory, this);
+        //OilSpigot end
+    }
+
+    public int getProperty(int i) {
+        switch (i) {
+        case 0:
+            return this.burnTime;
+
+        case 1:
+            return this.ticksForCurrentFuel;
+
+        case 2:
+            return this.cookTime;
+
+        case 3:
+            return this.cookTimeTotal;
+
+        default:
+            return 0;
+        }
+    }
+
+    public void setProperty(int i, int j) {
+        switch (i) {
+        case 0:
+            this.burnTime = j;
+            break;
+
+        case 1:
+            this.ticksForCurrentFuel = j;
+            break;
+
+        case 2:
+            this.cookTime = j;
+            break;
+
+        case 3:
+            this.cookTimeTotal = j;
+        }
+
+    }
+
+    public int h() {
+        return 4;
+    }
+
+    @Override
+    public void clear() { //OilSpigot PAIL l clear
+        super.clear();
+        burnTime=0;
+        ticksForCurrentFuel=0;
+        cookTime=0;
+        cookTimeTotal=0;
+    }
+
+
+    public String getContainerName() {
+        return "minecraft:furnace";
+    }
+
+    //OilSpigot start
+
+    @Override
+    protected OilBukkitCraftInventoryFurnace createBukkit() {
+        return new OilBukkitCraftInventoryFurnace(this);
+    }
+
+    @Override
+    public OilBukkitCraftInventoryFurnace getBukkitInventory() {
+        return (OilBukkitCraftInventoryFurnace) super.getBukkitInventory();
+    }
+
+    @Override
+    public void tick(int i) {
+        smelt(i);
+    }
+
+    @Override
+    public boolean isTickable() {
+        return true;
+    }
+
+    //OilSpigot end
+}
diff --git a/src/main/java/org/oilmod/spigot/inventory/OilInventoryPortableCrafting.java b/src/main/java/org/oilmod/spigot/inventory/OilInventoryPortableCrafting.java
new file mode 100644
index 00000000..bf505214
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/inventory/OilInventoryPortableCrafting.java
@@ -0,0 +1,237 @@
+package org.oilmod.spigot.inventory;
+
+import net.minecraft.server.AutoRecipeStackManager;
+import org.oilmod.api.config.Compound;
+import org.oilmod.api.inventory.ModPortableCraftingInventoryObject;
+import net.minecraft.server.ChatComponentText;
+import net.minecraft.server.ChatMessage;
+import net.minecraft.server.Container;
+import net.minecraft.server.ContainerUtil;
+import net.minecraft.server.CraftingManager;
+import net.minecraft.server.EntityHuman;
+import net.minecraft.server.EntityPlayer;
+import net.minecraft.server.IChatBaseComponent;
+import net.minecraft.server.IInventory;
+import net.minecraft.server.oilmod.IInventoryCraftResult;
+import net.minecraft.server.oilmod.IInventoryCrafting;
+import net.minecraft.server.IRecipe;
+import net.minecraft.server.ItemStack;
+import net.minecraft.server.Items;
+import net.minecraft.server.NonNullList;
+import net.minecraft.server.PacketPlayOutSetSlot;
+import net.minecraft.server.PlayerInventory;
+import net.minecraft.server.World;
+import org.bukkit.craftbukkit.entity.CraftHumanEntity;
+import org.bukkit.entity.HumanEntity;
+import org.bukkit.event.inventory.InventoryType;
+import org.bukkit.inventory.InventoryHolder;
+
+import java.util.Iterator;
+import java.util.List;
+
+/**
+ * Created by sirati97 on 26.02.2016.
+ */
+public class OilInventoryPortableCrafting extends OilInventoryBase<ModPortableCraftingInventoryObject> implements IInventoryCrafting {
+    private final OilCraftResultInventory resultInventory = new OilCraftResultInventory(this);
+    private World lastWorld;
+    private Container lastContainer;
+    private final int width;
+    private final int height;
+    private IRecipe currentRecipe;
+    protected NonNullList<ItemStack> results;
+
+    public OilInventoryPortableCrafting(InventoryHolder owner, int width, int height, String title, IItemFilter itemFilter) {
+        super(owner, title, width * height, null, itemFilter, true);
+        this.width = width;
+        this.height = height;
+        this.results = NonNullList.a(1, ItemStack.a);
+    }
+
+    public boolean b(int i, ItemStack itemstack) {
+        return true;
+    }
+
+    @Override
+    public int h() {
+        return 0;
+    }
+
+    @Override
+    public String getContainerLangKey() {
+        return "container.crafting";
+    }
+
+    @Override
+    public Container createContainer(PlayerInventory playerinventory, EntityHuman entityhuman) {
+        lastWorld = entityhuman.world;
+
+
+        //return new ContainerChest(playerinventory, this, entityhuman);//new ContainerWorkbench(playerinventory,entityhuman.world,entityhuman.getBed().up());//
+        return lastContainer = new OilContainerPortableCrafting(entityhuman.inventory, this);
+    }
+
+    public IChatBaseComponent getScoreboardDisplayName() {
+        return (IChatBaseComponent) (this.hasCustomName() ? new ChatComponentText(this.getName()) : new ChatMessage(this.getName(), new Object[0]));
+    }
+
+    @Override
+    public String getContainerName() {
+        return "minecraft:crafting_table";
+    }
+
+    //@Override
+    //public String getDisplayName() {
+    //    return getContainerLangKey();
+    //}
+
+    public ItemStack getItem(int var1) {
+        return var1 >= this.getSize()?ItemStack.a:super.getItem(var1);
+    }
+
+    public ItemStack getResultItem(int i) {
+        return results.get(i);
+    }
+
+    public void setResultItem(int i,ItemStack item) {
+        results.set(i, item);
+    }
+
+    public List<ItemStack> getResults() {
+        return results;
+    }
+
+    @Override
+    public ItemStack c(int var1, int var2) {
+        return var1 >= 0 && var1 < this.width && var2 >= 0 && var2 <= this.height ?this.getItem(var1 + var2 * this.width):ItemStack.a;
+    }
+
+    @Override
+    public void setItem(int left, int top, ItemStack itemStack, boolean update) {
+        if (left >= 0 && left < this.width && top >= 0 && top <= this.height) {
+            this.setItem(left + top * this.width, itemStack, update);
+        }
+    }
+
+    public ItemStack splitWithoutUpdate(int var1) {
+        return ContainerUtil.a(items, var1);
+    }
+
+    public ItemStack splitStack(int var1, int var2) {
+        return ContainerUtil.a(items, var1, var2);
+    }
+
+    public void setItem(int var1, ItemStack var2) {
+        setItem(var1, var2, true);
+    }
+
+    public void setItem(int var1, ItemStack var2, boolean update) {
+        super.setItem(var1,var2);
+        if (update)updateResult();
+    }
+
+
+
+    public void clear() {
+        items.clear();
+    }
+
+    @Override
+    public int i() {
+        return this.height;
+    }
+
+    @Override
+    public int j() {
+        return this.width;
+    }
+
+    public void updateResult() {
+        // this.resultInventory.setItem(0, CraftingManager.getInstance().craft(this.craftInventory, this.g));
+        // CraftBukkit start
+        ItemStack craftResult = CraftingManager.getInstance().craft(this, this.lastWorld);
+        this.resultInventory.setItem(0, craftResult);
+        List<HumanEntity> viewers = getViewers();
+        if (getViewers().size() < 1) {
+            return;
+        }
+        // See CraftBukkit PR #39
+        if (craftResult != null && craftResult.getItem() == Items.FILLED_MAP) {
+            return;
+        }
+        for (HumanEntity humanEntity:viewers) {
+            if (humanEntity instanceof CraftHumanEntity) {
+                EntityHuman human = ((CraftHumanEntity) humanEntity).getHandle();
+                if (human instanceof EntityPlayer) {
+                    EntityPlayer player = (EntityPlayer) human;
+                    player.playerConnection.sendPacket(new PacketPlayOutSetSlot(player.activeContainer.windowId, 0, craftResult));
+
+                }
+            }
+        }
+        // CraftBukkit end
+    }
+
+    public void setCurrentRecipe(IRecipe currentRecipe) {
+        this.currentRecipe = currentRecipe;
+    }
+
+    public IRecipe getCurrentRecipe() {
+        return currentRecipe;
+    }
+
+    @Override
+    public IInventoryCraftResult getResultInventory() {
+        return resultInventory;
+    }
+
+    @Override
+    public void setResultInventory(IInventory resultInventory) {}
+
+    @Override
+    protected OilBukkitCraftInventoryPortableCrafting createBukkit() {
+        return new OilBukkitCraftInventoryPortableCrafting(this);
+    }
+
+    @Override
+    public OilBukkitCraftInventoryPortableCrafting getBukkitInventory() {
+        return (OilBukkitCraftInventoryPortableCrafting) super.getBukkitInventory();
+    }
+
+    @Override
+    public CraftingManager getCraftingManager() {
+        return CraftingManager.getInstance(); //TODO: Add support for custom crafting managers
+    }
+
+    @Override
+    public Container getContainer() {
+        return lastContainer;
+    }
+
+    public InventoryType getInvType() {
+        return InventoryType.WORKBENCH;
+    }
+
+    //KEEPSYNC InventoryCrafting.a
+    public void a(AutoRecipeStackManager autorecipestackmanager) {
+        Iterator iterator = this.items.iterator();
+
+        while (iterator.hasNext()) {
+            ItemStack itemstack = (ItemStack) iterator.next();
+
+            autorecipestackmanager.a(itemstack);
+        }
+    }
+
+    @Override
+    public void load(Compound compound) {
+        super.load(compound);
+        loadItemsFromCompound(compound, this.results, "results");
+    }
+
+    @Override
+    public void save(Compound compound) {
+        super.save(compound);
+        saveItemsToCompound(compound, this.results, "results");
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/inventory/OilSlot.java b/src/main/java/org/oilmod/spigot/inventory/OilSlot.java
new file mode 100644
index 00000000..dcea7204
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/inventory/OilSlot.java
@@ -0,0 +1,21 @@
+package org.oilmod.spigot.inventory;
+
+import net.minecraft.server.ItemStack;
+import net.minecraft.server.Slot;
+
+/**
+ * Created by sirati97 on 14.02.2016.
+ */
+public class OilSlot extends Slot {
+    private OilIInventory iinventory;
+
+    public OilSlot(OilIInventory iinventory, int i, int j, int k) {
+        super(iinventory, i, j, k);
+        this.iinventory = iinventory;
+    }
+
+    @Override
+    public boolean isAllowed(ItemStack itemstack) {
+        return iinventory.itemstackAddable(itemstack);
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/inventory/OilSlotFurnaceFuel.java b/src/main/java/org/oilmod/spigot/inventory/OilSlotFurnaceFuel.java
new file mode 100644
index 00000000..eb174db0
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/inventory/OilSlotFurnaceFuel.java
@@ -0,0 +1,21 @@
+package org.oilmod.spigot.inventory;
+
+import net.minecraft.server.ItemStack;
+import net.minecraft.server.SlotFurnaceFuel;
+
+/**
+ * Created by sirati97 on 14.02.2016.
+ */
+public class OilSlotFurnaceFuel extends SlotFurnaceFuel {
+    private OilInventoryFurnace furnace;
+
+    public OilSlotFurnaceFuel(OilInventoryFurnace furnace, int i, int i1, int i2) {
+        super(furnace, i, i1, i2);
+        this.furnace = furnace;
+    }
+
+    @Override
+    public boolean isAllowed(ItemStack itemStack) {
+        return super.isAllowed(itemStack) && furnace.itemstackAddable(itemStack);
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/inventory/OilSlotFurnaceResult.java b/src/main/java/org/oilmod/spigot/inventory/OilSlotFurnaceResult.java
new file mode 100644
index 00000000..7bd0e847
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/inventory/OilSlotFurnaceResult.java
@@ -0,0 +1,74 @@
+package org.oilmod.spigot.inventory;
+
+// CraftBukkit start
+import org.oilmod.spigot.bukkit.stubs.OilBlockStub;
+import net.minecraft.server.EntityExperienceOrb;
+import net.minecraft.server.EntityHuman;
+import net.minecraft.server.IInventory;
+import net.minecraft.server.ItemStack;
+import net.minecraft.server.Items;
+import net.minecraft.server.MathHelper;
+import net.minecraft.server.RecipesFurnace;
+import net.minecraft.server.Slot;
+import net.minecraft.server.SlotFurnaceResult;
+import net.minecraft.server.Statistic;
+import net.minecraft.server.TileEntityFurnace;
+import org.bukkit.Material;
+import org.bukkit.entity.Player;
+import org.bukkit.event.inventory.FurnaceExtractEvent;
+import org.oilmod.spigot.bukkit.stubs.OilBlockStub;
+// CraftBukkit end
+
+public class OilSlotFurnaceResult extends SlotFurnaceResult {
+
+    public OilSlotFurnaceResult(EntityHuman entityhuman, IInventory iinventory, int i, int j, int k) {
+        super(entityhuman, iinventory, i, j, k);
+    }
+
+    public boolean isAllowed(ItemStack itemstack) {
+        return false;
+    }
+
+
+    //OilSpigot KEEPSYNC SlotFurnaceResult.c(SAME PARAM)
+    protected void c(ItemStack itemstack) {
+        itemstack.a(this.a.world, this.a, this.b);
+        if (!this.a.world.isClientSide) {
+            int i = this.b;
+            float f = RecipesFurnace.getInstance().b(itemstack);
+            int j;
+
+            if (f == 0.0F) {
+                i = 0;
+            } else if (f < 1.0F) {
+                j = MathHelper.d((float) i * f);
+                if (j < MathHelper.f((float) i * f) && Math.random() < (double) ((float) i * f - (float) j)) {
+                    ++j;
+                }
+
+                i = j;
+            }
+
+            // CraftBukkit start - fire FurnaceExtractEvent
+            Player player = (Player) a.getBukkitEntity();
+            OilInventoryFurnace furnace = ((OilInventoryFurnace) this.getInventory());  //OilSpigot - changed .inventory to .getInventory(), use OilInventoryFurnace
+            //OilSpigot: fake the block so that the event works properly //TODO find better way
+            org.bukkit.block.Block block = new OilBlockStub(Material.BURNING_FURNACE);
+
+            if (b != 0) {
+                FurnaceExtractEvent event = new FurnaceExtractEvent(player, block, org.bukkit.craftbukkit.util.CraftMagicNumbers.getMaterial(itemstack.getItem()), b, i);
+                a.world.getServer().getPluginManager().callEvent(event);
+                i = event.getExpToDrop();
+            }
+            // CraftBukkit end
+
+            while (i > 0) {
+                j = EntityExperienceOrb.getOrbValue(i);
+                i -= j;
+                this.a.world.addEntity(new EntityExperienceOrb(this.a.world, this.a.locX, this.a.locY + 0.5D, this.a.locZ + 0.5D, j));
+            }
+        }
+
+        this.b = 0;
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/inventory/OilSlotPortableCraftingResult.java b/src/main/java/org/oilmod/spigot/inventory/OilSlotPortableCraftingResult.java
new file mode 100644
index 00000000..b95a9f46
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/inventory/OilSlotPortableCraftingResult.java
@@ -0,0 +1,14 @@
+package org.oilmod.spigot.inventory;
+
+import net.minecraft.server.EntityHuman;
+import net.minecraft.server.SlotResult;
+
+/**
+ * Created by sirati97 on 26.02.2016.
+ */
+public class OilSlotPortableCraftingResult extends SlotResult {
+
+    public OilSlotPortableCraftingResult(EntityHuman var1, OilInventoryPortableCrafting var2, int var4, int var5, int var6) {
+        super(var1, var2, var2.getResultInventory(), var4, var5, var6);
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/inventory/RealInventoryFactory.java b/src/main/java/org/oilmod/spigot/inventory/RealInventoryFactory.java
new file mode 100644
index 00000000..cdd3f21e
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/inventory/RealInventoryFactory.java
@@ -0,0 +1,57 @@
+package org.oilmod.spigot.inventory;
+
+import org.oilmod.api.data.DataParent;
+import org.oilmod.api.data.ItemStackData;
+import org.oilmod.api.data.ObjectFactory;
+import org.oilmod.api.inventory.InventoryFactory;
+import org.oilmod.api.inventory.ItemFilter;
+import org.oilmod.api.inventory.ModFurnaceInventoryObject;
+import org.oilmod.api.inventory.ModInventoryObject;
+import org.oilmod.api.inventory.ModNMSIInventory;
+import org.oilmod.api.inventory.ModPortableCraftingInventoryObject;
+import org.oilmod.api.items.OilItemStack;
+import org.oilmod.api.util.WeakReferenceTicker;
+
+/**
+ * Created by sirati97 on 12.02.2016.
+ */
+public class RealInventoryFactory extends InventoryFactory {
+    @Override
+    public ItemStackData createItemStackData(String name, DataParent dataParent) {
+        return new ItemStackDataImpl(name, dataParent);
+    }
+
+    @Override
+    protected ObjectFactory<ModNMSIInventory<ModInventoryObject>> getBasicInventoryFactory(final OilItemStack oilItemStack, final int size, final String title, final ItemFilter filter) {
+        return new ObjectFactory<ModNMSIInventory<ModInventoryObject>>() {
+            @Override
+            public ModNMSIInventory create() {
+                return new OilInventoryChest(oilItemStack,size,title,createNMSFilter(filter));
+            }
+        };
+    }
+
+    @Override
+    protected ObjectFactory<ModNMSIInventory<ModFurnaceInventoryObject>> getFurnaceInventoryFactory(final OilItemStack oilItemStack, final String title, final WeakReferenceTicker ticker, final ItemFilter filter) {
+        return new ObjectFactory<ModNMSIInventory<ModFurnaceInventoryObject>>() {
+            @Override
+            public ModNMSIInventory<ModFurnaceInventoryObject> create() {
+                return new OilInventoryFurnace(oilItemStack,title, ticker, createNMSFilter(filter));
+            }
+        };
+    }
+
+    @Override
+    protected ObjectFactory<ModNMSIInventory<ModPortableCraftingInventoryObject>> getPortableCraftingInventoryFactory(final OilItemStack oilItemStack, final int width, final int height,final String title,final ItemFilter filter) {
+        return new ObjectFactory<ModNMSIInventory<ModPortableCraftingInventoryObject>>() {
+            @Override
+            public ModNMSIInventory<ModPortableCraftingInventoryObject> create() {
+                return new OilInventoryPortableCrafting(oilItemStack, width, height,title, createNMSFilter(filter));
+            }
+        };
+    }
+
+    public IItemFilter createNMSFilter(ItemFilter bukkitFilter) {
+        return bukkitFilter==null?null:new ApiItemFilter(bukkitFilter);
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/inventory/creative/OilContainerCreative.java b/src/main/java/org/oilmod/spigot/inventory/creative/OilContainerCreative.java
new file mode 100644
index 00000000..f5d72d01
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/inventory/creative/OilContainerCreative.java
@@ -0,0 +1,198 @@
+package org.oilmod.spigot.inventory.creative;
+
+import net.minecraft.server.Container;
+import net.minecraft.server.EntityHuman;
+import net.minecraft.server.EntityPlayer;
+import net.minecraft.server.InventoryClickType;
+import net.minecraft.server.ItemStack;
+import net.minecraft.server.PlayerInventory;
+import net.minecraft.server.Slot;
+import org.bukkit.craftbukkit.inventory.CraftInventoryView;
+
+import javax.annotation.Nullable;
+
+/**
+ * Created by sirati97 on 05.03.2016.
+ */
+public class OilContainerCreative extends Container {
+    private OilCreativeInventory creativeInventory;
+    private PlayerInventory player;
+    private CraftInventoryView bukkitEntity = null;
+    private int offset=0;
+
+    public OilContainerCreative(PlayerInventory player, OilCreativeInventory creativeInventory, EntityHuman entityhuman) {
+        this.creativeInventory = creativeInventory;
+        creativeInventory.startOpen(entityhuman);
+        int i = (creativeInventory.getSize() / 9 - 4) * 18;
+
+        // CraftBukkit start - Save player
+        this.player = player;
+        // CraftBukkit end
+
+        int j;
+        int k;
+
+        for (j = 0; j < 6; ++j) {
+            for (k = 0; k < 9; ++k) {
+                if (k == 8) {
+                    if (j==2) {
+                        this.a(new OilCreativeMoveActionSlot(this, -3));
+                    } else if (j==3) {
+                        this.a(new OilCreativeMoveActionSlot(this, -1));
+                    } else if (j==4) {
+                        this.a(new OilCreativeMoveActionSlot(this, 1));
+                    } else if (j==5) {
+                        this.a(new OilCreativeMoveActionSlot(this, 3));
+                    } else {
+                        this.a(new OilCreativeEmptyActionSlot(this));
+                    }
+                } else {
+                    this.a(new OilInvCreativeSlot(this, creativeInventory, k + j * 8, 8 + k * 18, 18 + j * 18));
+                }
+            }
+        }
+
+        for (j = 0; j < 3; ++j) {
+            for (k = 0; k < 9; ++k) {
+                this.a(new Slot(player, k + j * 9 + 9, 8 + k * 18, 103 + j * 18 + i));
+            }
+        }
+
+        for (j = 0; j < 9; ++j) {
+            this.a(new Slot(player, j, 8 + j * 18, 161 + i));
+        }
+
+    }
+
+    @Override
+    public CraftInventoryView getBukkitView() {
+        if (bukkitEntity != null) {
+            return bukkitEntity;
+        }
+        bukkitEntity = new CraftInventoryView(this.player.player.getBukkitEntity(), creativeInventory.getBukkitInventory(), this);
+        return bukkitEntity;
+    }
+
+    @Nullable
+    @Override
+    public ItemStack a(int slotId, int button, InventoryClickType mode, EntityHuman entityhuman) {
+        ItemStack result=ItemStack.a;
+        if (slotId >= 0 && slotId < 54) {
+            boolean isButton = (slotId+1)%9==0;
+            if (isButton && mode != InventoryClickType.THROW) {
+                OilCreativeActionSlot slot = (OilCreativeActionSlot) getSlot(slotId);
+                slot.onAction();
+            } else if (mode == InventoryClickType.PICKUP || mode == InventoryClickType.QUICK_MOVE || mode == InventoryClickType.SWAP || mode == InventoryClickType.CLONE || mode == InventoryClickType.THROW) {
+                OilInvCreativeSlot slot = (OilInvCreativeSlot) getSlot(slotId);
+                if (slot.doesSlotExist()) {
+                    result = clickItemCreative(slotId, button, mode, entityhuman);
+                } else {
+                    entityhuman.inventory.setCarried(ItemStack.a);
+                }
+            }
+            ((EntityPlayer) entityhuman).updateInventory(this);
+        } else {
+            if (mode == InventoryClickType.QUICK_MOVE) {
+                if (slotId < 0) {
+                    return ItemStack.a;
+                }
+                Slot slot = this.slots.get(slotId);
+                if (slot == null) {
+                    return ItemStack.a;
+                }
+                slot.set(ItemStack.a);
+                ((EntityPlayer) entityhuman).updateInventory(this);
+            } else {
+                result = super.a(slotId, button, mode, entityhuman);
+            }
+        }
+        return result;
+    }
+
+    public ItemStack clickItemCreative(int slotId, int button, InventoryClickType mode, EntityHuman entityhuman) {
+        ItemStack result = ItemStack.a;
+        PlayerInventory playerinventory = entityhuman.inventory;
+        ItemStack carried = playerinventory.getCarried();
+
+        if (slotId < 0) {
+            return ItemStack.a;
+        }
+        Slot slot = this.slots.get(slotId);
+
+        if (slot == null || !slot.isAllowed(entityhuman)) {
+            return ItemStack.a;
+        }
+        ItemStack itemstack = slot.getItem();
+        if (itemstack.isEmpty()) {
+            return ItemStack.a;
+        }
+
+
+        if (mode == InventoryClickType.PICKUP) {
+            if (!carried.isEmpty()) {
+                if (slot.hasItem() && ItemStack.matchesIgnoresCount(carried, itemstack)) {
+
+                    carried.add(button==0?1:-1);
+                    if (carried.getCount() < 1) {
+                        playerinventory.setCarried(ItemStack.a);
+                    } else if (carried.getCount() > carried.getMaxStackSize()) {
+                        carried.setCount(carried.getMaxStackSize());
+                    }
+                } else {
+                    playerinventory.setCarried(ItemStack.a);
+                }
+            } else {
+                playerinventory.setCarried(itemstack);
+                slot.set(ItemStack.a);
+            }
+            result = itemstack.cloneItemStack();
+        } else if (mode == InventoryClickType.QUICK_MOVE) {
+            if (carried.isEmpty()) {
+                carried = itemstack;
+                carried.setCount(carried.getMaxStackSize());
+                playerinventory.setCarried(carried);
+                slot.set(ItemStack.a);
+            } else if (slot.hasItem() && ItemStack.matchesIgnoresCount(carried, itemstack)) {
+                carried.setCount(carried.getMaxStackSize());
+            } else {
+                playerinventory.setCarried(ItemStack.a);
+            }
+            result = itemstack.cloneItemStack();
+        } else if (mode == InventoryClickType.SWAP && button >= 0 && button < 9 && carried.isEmpty()) {
+            itemstack.setCount(itemstack.getMaxStackSize());
+            slot.set(ItemStack.a);
+            playerinventory.setItem(button, itemstack);
+        } else if (mode == InventoryClickType.CLONE) {
+            carried = itemstack;
+            carried.setCount(carried.getMaxStackSize());
+            playerinventory.setCarried(carried);
+            slot.set(ItemStack.a);
+        } else if (mode == InventoryClickType.THROW && (button == 0 || button == 1)) {
+            if (button == 1) {
+                itemstack.setCount(itemstack.getMaxStackSize());
+            }
+            entityhuman.drop(itemstack, true);
+            slot.set(ItemStack.a);
+        }
+        return result;
+    }
+
+    @Override
+    public boolean canUse(EntityHuman entityhuman) {
+        return true;
+    }
+
+    public int getOffset() {
+        return offset;
+    }
+
+    public boolean doesSlotExist(int i) {
+        return i >= 0 && creativeInventory.getTotalSize()>i;
+    }
+
+    public void move(int i) {
+        offset += i;
+        int rows = creativeInventory.getTotalSize()/8+(creativeInventory.getTotalSize()%8==0?0:1);
+        offset = offset<0?0:offset>=rows?rows<=0?0:rows-1:offset;
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/inventory/creative/OilCreativeActionSlot.java b/src/main/java/org/oilmod/spigot/inventory/creative/OilCreativeActionSlot.java
new file mode 100644
index 00000000..bbae557e
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/inventory/creative/OilCreativeActionSlot.java
@@ -0,0 +1,63 @@
+package org.oilmod.spigot.inventory.creative;
+
+import net.minecraft.server.EntityHuman;
+import net.minecraft.server.IInventory;
+import net.minecraft.server.ItemStack;
+
+/**
+ * Created by sirati97 on 05.03.2016.
+ */
+public abstract class OilCreativeActionSlot extends OilCreativeSlot {
+
+    public OilCreativeActionSlot(OilContainerCreative container) {
+        super(container, null, 0, 0, 0);
+    }
+
+    public abstract void onAction();
+
+    public void a(ItemStack itemstack, ItemStack itemstack1) {
+    }
+
+    public ItemStack a(EntityHuman entityhuman, ItemStack itemstack) {
+        return itemstack; //todo what does this do
+    }
+
+    public boolean isAllowed(ItemStack itemstack) {
+        return false;
+    }
+
+    public abstract ItemStack getItem();
+
+    public boolean hasItem() {
+        return this.getItem() != null;
+    }
+
+    public void set(ItemStack itemstack) {
+    }
+
+    public void f() {
+    }
+
+    public int getMaxStackSize() {
+        return 64;
+    }
+
+    public int getMaxStackSize(ItemStack itemstack) {
+        return this.getMaxStackSize();
+    }
+
+    public ItemStack a(int i) {
+        return null;
+    }
+
+    public boolean a(IInventory iinventory, int i) {
+        return iinventory == this.getInventory() && i == this.index; //OilSpigot - changed .inventory to .getInventory()
+    }
+
+    public boolean isAllowed(EntityHuman entityhuman) {
+        return false;
+    }
+
+
+
+}
diff --git a/src/main/java/org/oilmod/spigot/inventory/creative/OilCreativeEmptyActionSlot.java b/src/main/java/org/oilmod/spigot/inventory/creative/OilCreativeEmptyActionSlot.java
new file mode 100644
index 00000000..d5eb4f65
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/inventory/creative/OilCreativeEmptyActionSlot.java
@@ -0,0 +1,26 @@
+package org.oilmod.spigot.inventory.creative;
+
+import net.minecraft.server.Blocks;
+import net.minecraft.server.ItemStack;
+
+/**
+ * Created by sirati97 on 05.03.2016.
+ */
+public class OilCreativeEmptyActionSlot extends OilCreativeActionSlot {
+    private ItemStack item;
+
+    public OilCreativeEmptyActionSlot(OilContainerCreative container) {
+        super(container);
+        item = new ItemStack(Blocks.STAINED_GLASS_PANE, 1, 7);
+        item.c("r");
+    }
+
+    @Override
+    public void onAction() {
+    }
+
+    @Override
+    public ItemStack getItem() {
+        return item;
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/inventory/creative/OilCreativeInventory.java b/src/main/java/org/oilmod/spigot/inventory/creative/OilCreativeInventory.java
new file mode 100644
index 00000000..fc1c212c
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/inventory/creative/OilCreativeInventory.java
@@ -0,0 +1,123 @@
+package org.oilmod.spigot.inventory.creative;
+
+import net.minecraft.server.NonNullList;
+import org.oilmod.api.inventory.ModInventoryObjectBase;
+import org.oilmod.api.items.OilItemStackFactory;
+import org.oilmod.spigot.inventory.OilInventoryBase;
+import org.oilmod.spigot.items.RealSpecificItemStackFactory;
+import org.oilmod.spigot.items.SpecificItemStackFactory;
+import net.minecraft.server.Container;
+import net.minecraft.server.EntityHuman;
+import net.minecraft.server.ItemStack;
+import net.minecraft.server.PlayerInventory;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
+import org.oilmod.spigot.util.BetterNonNullList;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+/**
+ * Created by sirati97 on 06.03.2016.
+ */
+public class OilCreativeInventory extends OilInventoryBase<ModInventoryObjectBase> {
+    public static final OilCreativeInventory instance = new OilCreativeInventory();
+
+
+    private List<SpecificItemStackFactory> factories = new ArrayList<>();
+
+    public OilCreativeInventory() {
+        super(null, "Creative Menu", 10, null, null, false);
+    }
+
+    @Override
+    protected NonNullList<ItemStack> initItems(int size) {
+        return new BetterNonNullList<>(ItemStack.a);
+    }
+
+    @Override
+    public String getContainerLangKey() {
+        return "container.chest";
+    }
+
+    @Override
+    public String getContainerName() {
+        return "minecraft:chest";
+    }
+
+    public ItemStack splitStack(int i, int j) {
+        ItemStack stack = this.getItem(i);
+        ItemStack result;
+        if (stack.isEmpty()) return ItemStack.a;
+        if (stack.getCount() <= j) {
+            this.setItem(i, ItemStack.a);
+            result = stack;
+        } else {
+            result = CraftItemStack.copyNMSStack(stack, j);
+            stack.subtract(j);
+        }
+        this.update();
+        return result;
+    }
+
+    public ItemStack splitWithoutUpdate(int i) {
+        ItemStack stack = this.getItem(i);
+        ItemStack result;
+        if (stack.isEmpty()) return ItemStack.a;
+        if (stack.getCount()  <= 1) {
+            this.setItem(i, ItemStack.a);
+            result = stack;
+        } else {
+            result = CraftItemStack.copyNMSStack(stack, 1);
+            stack.subtract(1);
+        }
+        return result;
+    }
+
+    public boolean b(int i, ItemStack itemstack) {
+        return true;
+    }
+
+    @Override
+    public int h() {
+        return 0;
+    }
+
+    @Override
+    public int getSize() {
+        return 54;
+    }
+
+    @Override
+    public int getTotalSize() {
+        return factories.size();
+    }
+
+    @Override
+    public void setItem(int i, ItemStack itemstack) {
+        super.setItem(i, factories.get(i).create());
+    }
+
+
+    public void addFactories(OilItemStackFactory... argFactories) {
+        SpecificItemStackFactory[] newFactories = new SpecificItemStackFactory[argFactories.length];
+        for (int i=0;i<argFactories.length;i++) {
+            newFactories[i] = new RealSpecificItemStackFactory(argFactories[i]);
+        }
+        addFactories(newFactories);
+    }
+
+    public void addFactories(SpecificItemStackFactory... argFactories) {
+        int oldSize = getTotalSize();
+        factories.addAll(Arrays.asList(argFactories));
+
+        for (int i = oldSize; i < factories.size(); i++) {
+            items.add(factories.get(i).create());
+        }
+    }
+
+    @Override
+    public Container createContainer(PlayerInventory playerinventory, EntityHuman entityhuman) {
+        return new OilContainerCreative(playerinventory, this, entityhuman);
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/inventory/creative/OilCreativeModInventoryCommand.java b/src/main/java/org/oilmod/spigot/inventory/creative/OilCreativeModInventoryCommand.java
new file mode 100644
index 00000000..ec863796
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/inventory/creative/OilCreativeModInventoryCommand.java
@@ -0,0 +1,28 @@
+package org.oilmod.spigot.inventory.creative;
+
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+
+import java.util.Arrays;
+
+/**
+ * Created by sirati97 on 06.03.2016.
+ */
+public class OilCreativeModInventoryCommand extends Command {
+
+    public OilCreativeModInventoryCommand(String name, String... aliases) {
+        super(name, "Shows all the oilmod items", "/"+name, Arrays.asList(aliases));
+        this.setPermission( "oilmod.command.CreativeModInventory" );
+    }
+
+    @Override
+    public boolean execute(CommandSender commandSender, String currentAlias, String[] args) {
+        if (commandSender instanceof CraftPlayer) {
+            ((CraftPlayer) commandSender).openInventory(OilCreativeInventory.instance.getBukkitInventory());
+        } else {
+            commandSender.sendMessage("This command is only for players");
+        }
+        return true;
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/inventory/creative/OilCreativeMoveActionSlot.java b/src/main/java/org/oilmod/spigot/inventory/creative/OilCreativeMoveActionSlot.java
new file mode 100644
index 00000000..6ff78b91
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/inventory/creative/OilCreativeMoveActionSlot.java
@@ -0,0 +1,35 @@
+package org.oilmod.spigot.inventory.creative;
+
+import net.minecraft.server.ItemStack;
+import org.bukkit.Material;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
+import org.bukkit.inventory.meta.SkullMeta;
+
+/**
+ * Created by sirati97 on 05.03.2016.
+ */
+public class OilCreativeMoveActionSlot extends OilCreativeActionSlot {
+    private final ItemStack item;
+    private final int move;
+
+    public OilCreativeMoveActionSlot(OilContainerCreative container, int move) {
+        super(container);
+        this.move = move;
+        org.bukkit.inventory.ItemStack bukkitItemStack = new org.bukkit.inventory.ItemStack(Material.SKULL_ITEM, 1, (short)3);
+        SkullMeta meta = (SkullMeta)bukkitItemStack.getItemMeta();
+        meta.setOwner(move>0?"MHF_ArrowDown":"MHF_ArrowUp");
+        meta.setDisplayName("rGo " + (move>0?"down":"up") + " " + Math.abs(move) + "x");
+        bukkitItemStack.setItemMeta(meta);
+        item = CraftItemStack.asNMSCopy(bukkitItemStack);
+    }
+
+    @Override
+    public void onAction() {
+        getContainer().move(move);
+    }
+
+    @Override
+    public ItemStack getItem() {
+        return item;
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/inventory/creative/OilCreativeSlot.java b/src/main/java/org/oilmod/spigot/inventory/creative/OilCreativeSlot.java
new file mode 100644
index 00000000..e7705fc5
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/inventory/creative/OilCreativeSlot.java
@@ -0,0 +1,19 @@
+package org.oilmod.spigot.inventory.creative;
+
+import net.minecraft.server.IInventory;
+import net.minecraft.server.Slot;
+
+/**
+ * Created by sirati97 on 05.03.2016.
+ */
+public abstract class OilCreativeSlot extends Slot{
+    private final OilContainerCreative container;
+    public OilCreativeSlot(OilContainerCreative container, IInventory iinventory, int i, int j, int k) {
+        super(iinventory, i, j, k);
+        this.container = container;
+    }
+
+    public OilContainerCreative getContainer() {
+        return container;
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/inventory/creative/OilInvCreativeSlot.java b/src/main/java/org/oilmod/spigot/inventory/creative/OilInvCreativeSlot.java
new file mode 100644
index 00000000..ff1ddf02
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/inventory/creative/OilInvCreativeSlot.java
@@ -0,0 +1,51 @@
+package org.oilmod.spigot.inventory.creative;
+
+import net.minecraft.server.Blocks;
+import net.minecraft.server.IInventory;
+import net.minecraft.server.ItemStack;
+
+/**
+ * Created by sirati97 on 06.03.2016.
+ */
+public class OilInvCreativeSlot extends OilCreativeSlot {
+    private ItemStack item;
+
+    public OilInvCreativeSlot(OilContainerCreative container, IInventory iinventory, int i, int j, int k) {
+        super(container, iinventory, i, j, k);
+        item = new ItemStack(Blocks.STAINED_GLASS_PANE, 1, 7);
+        item.c("r");
+    }
+
+    public int getIndex() {
+        return index + getContainer().getOffset()*8;
+    }
+
+    public boolean doesSlotExist() {
+        return getContainer().doesSlotExist(getIndex());
+    }
+
+    @Override
+    public boolean hasItem() {
+        return doesSlotExist() && super.hasItem();
+    }
+
+    public ItemStack getItem() {
+        return doesSlotExist()?this.getInventory().getItem(getIndex()):item; //OilSpigot - changed .inventory to .getInventory()
+    }
+
+    public void set(ItemStack itemstack) {
+        if (!doesSlotExist()) {
+            return;
+        }
+        this.getInventory().setItem(getIndex(), itemstack); //OilSpigot - changed .inventory to .getInventory()
+        this.f();
+    }
+
+    public ItemStack a(int i) {
+        return doesSlotExist()?this.getInventory().splitStack(getIndex(), i):item; //OilSpigot - changed .inventory to .getInventory()
+    }
+
+    public boolean a(IInventory iinventory, int i) {
+        return iinventory == this.getInventory() && i == getIndex(); //OilSpigot - changed .inventory to .getInventory()
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/inventory/custom/ClickExtraData.java b/src/main/java/org/oilmod/spigot/inventory/custom/ClickExtraData.java
new file mode 100644
index 00000000..6111f32a
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/inventory/custom/ClickExtraData.java
@@ -0,0 +1,37 @@
+package org.oilmod.spigot.inventory.custom;
+
+
+import org.oilmod.api.userinterface.internal.NMSClickData;
+import org.oilmod.spigot.inventory.custom.nms.ViewContainer;
+import net.minecraft.server.ItemStack;
+import org.oilmod.spigot.inventory.custom.nms.ViewContainer;
+
+/**
+ * Created by sirati97 on 14.06.2016 for spigot.
+ */
+public class ClickExtraData implements NMSClickData {
+    private ItemStack result;
+    private final ViewContainer viewContainer;
+    private final ISingleSlot singleSlot;
+
+    public ClickExtraData(ViewContainer viewContainer, ISingleSlot singleSlot) {
+        this.viewContainer = viewContainer;
+        this.singleSlot = singleSlot;
+    }
+
+    public ItemStack getResult() {
+        return result;
+    }
+
+    public void setResult(ItemStack result) {
+        this.result = result;
+    }
+
+    public ViewContainer getViewContainer() {
+        return viewContainer;
+    }
+
+    public ISingleSlot getSingleSlot() {
+        return singleSlot;
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/inventory/custom/ISingleSlot.java b/src/main/java/org/oilmod/spigot/inventory/custom/ISingleSlot.java
new file mode 100644
index 00000000..5f9c621e
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/inventory/custom/ISingleSlot.java
@@ -0,0 +1,22 @@
+package org.oilmod.spigot.inventory.custom;
+
+import net.minecraft.server.EntityHuman;
+import net.minecraft.server.ItemStack;
+
+/**
+ * Created by sirati97 on 17.06.2016 for spigot.
+ */
+public interface ISingleSlot {
+    int getIndex();
+    int getPacketSlotIndex();
+    ItemStack getItem();
+    boolean hasItem();
+    void setItem(ItemStack itemStack);
+    boolean isAllowed(ItemStack itemStack);
+    boolean isReadOnly();
+    boolean isSettable();
+    int getMaxStackSize(ItemStack itemStack);
+    int getMaxStackSize();
+    boolean isAllowed(EntityHuman human);
+    ItemStack splitItemStack(int removed);
+}
diff --git a/src/main/java/org/oilmod/spigot/inventory/custom/api/NMSFixedSizePanelImpl.java b/src/main/java/org/oilmod/spigot/inventory/custom/api/NMSFixedSizePanelImpl.java
new file mode 100644
index 00000000..4ed68bee
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/inventory/custom/api/NMSFixedSizePanelImpl.java
@@ -0,0 +1,39 @@
+package org.oilmod.spigot.inventory.custom.api;
+
+import org.oilmod.api.userinterface.UIElement;
+import org.oilmod.api.userinterface.UIElementResult;
+import org.oilmod.api.userinterface.UIPanel;
+import org.oilmod.api.userinterface.internal.NMSFixedSizePanel;
+import org.oilmod.spigot.inventory.custom.view.SlotView;
+import org.oilmod.spigot.inventory.custom.slot.ViewSlotBase;
+import org.oilmod.spigot.util.OilSpigotUtil;
+import org.oilmod.spigot.inventory.custom.slot.ViewSlotBase;
+import org.oilmod.spigot.inventory.custom.view.SlotView;
+import org.oilmod.spigot.util.OilSpigotUtil;
+
+/**
+ * Created by sirati97 on 14.06.2016 for spigot.
+ */
+public class NMSFixedSizePanelImpl extends SlotView implements WrappedPanel, NMSFixedSizePanel {
+    private final UIPanel oilPanel;
+
+    public NMSFixedSizePanelImpl(UIPanel oilPanel) {
+        super(new ViewSlotBase[oilPanel.size()]);
+        this.oilPanel = oilPanel;
+    }
+
+    @Override
+    public UIPanel getOilPanel() {
+        return oilPanel;
+    }
+
+    @Override
+    public UIElementResult getElement(int i) {
+        return get(i);
+    }
+
+    @Override
+    public void setElement(int i, UIElement uiElement) {
+        super.set(i, OilSpigotUtil.toNMS(uiElement));
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/inventory/custom/api/OilElementWrapper.java b/src/main/java/org/oilmod/spigot/inventory/custom/api/OilElementWrapper.java
new file mode 100644
index 00000000..f29bf0d8
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/inventory/custom/api/OilElementWrapper.java
@@ -0,0 +1,96 @@
+package org.oilmod.spigot.inventory.custom.api;
+
+import org.oilmod.api.userinterface.Click;
+import org.oilmod.api.userinterface.IUIElement;
+import org.oilmod.api.userinterface.internal.NMSClickData;
+import org.oilmod.api.userinterface.internal.NMSUIElement;
+import org.oilmod.spigot.inventory.custom.ClickExtraData;
+import org.oilmod.spigot.inventory.custom.slot.IViewSlot;
+import org.oilmod.spigot.util.OilSpigotUtil;
+import net.minecraft.server.EntityHuman;
+import net.minecraft.server.EntityPlayer;
+import net.minecraft.server.InventoryClickType;
+import net.minecraft.server.ItemStack;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
+import org.bukkit.entity.Player;
+import org.oilmod.spigot.inventory.custom.slot.IViewSlot;
+import org.oilmod.spigot.util.OilSpigotUtil;
+
+/**
+ * Created by sirati97 on 14.06.2016 for spigot.
+ */
+public class OilElementWrapper implements IViewSlot {
+    private final IUIElement element;
+
+    public OilElementWrapper(IUIElement element) {
+        this.element = element;
+    }
+
+    @Override
+    public ItemStack getItem(int index) {
+        CraftItemStack cStack = getDisplayed(index);
+        return cStack==null?ItemStack.a:cStack.getHandle();
+    }
+
+    @Override
+    public final boolean hasItem(int index) {
+        return !this.getItem(index).isEmpty();
+    }
+
+    @Override
+    public CraftItemStack getDisplayed(int index) {
+        org.bukkit.inventory.ItemStack result = element.getDisplayed(index);
+        CraftItemStack craftResult;
+        if (result instanceof CraftItemStack) {
+            craftResult = (CraftItemStack) result;
+        } else if (result == null) {
+            return null;
+        } else  {
+            craftResult = CraftItemStack.asCraftCopy(result); //replace with nms
+            element.setDisplayed(index, craftResult);
+            if (craftResult != element.getDisplayed(index)) {
+                throw new IllegalStateException("UIElement needs to allow setting the item! This will only replace the itemstack with an CraftBukkit instance, nothing more.");
+            }
+        }
+        return craftResult;
+    }
+
+    @Override
+    public void setDisplayed(int index, org.bukkit.inventory.ItemStack itemStack) {
+        if (!(itemStack instanceof CraftItemStack)) {
+            itemStack = itemStack==null?null:CraftItemStack.asCraftCopy(itemStack); //replace with nms
+        }
+        element.setDisplayed(index, itemStack);
+    }
+
+    @Override
+    public void onClick(Player player, int index, Click click, NMSClickData nmsClickData) {
+        element.onClick(player, index, click, nmsClickData);
+    }
+
+    @Override
+    public void setNmsWrapper(NMSUIElement nmsuiElement) {
+        throw new UnsupportedOperationException("Cannot set wrapper of wrapper. Plugin should never call this method");
+    }
+
+    @Override
+    public NMSUIElement getNmsWrapper() {
+        return this;
+    }
+
+    public void clickItem(int index, int button, InventoryClickType mode, EntityHuman entityhuman, ClickExtraData data) {
+        onClick(((EntityPlayer)entityhuman).getBukkitEntity(), index, new Click(OilSpigotUtil.toOil(mode), button), data);
+    }
+
+    public IUIElement getElement() {
+        return element;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (obj instanceof OilElementWrapper) {
+            return element.equals(((OilElementWrapper) obj).element);
+        }
+        return super.equals(obj);
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/inventory/custom/api/OilInteractableElementWrapper.java b/src/main/java/org/oilmod/spigot/inventory/custom/api/OilInteractableElementWrapper.java
new file mode 100644
index 00000000..e976b96a
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/inventory/custom/api/OilInteractableElementWrapper.java
@@ -0,0 +1,70 @@
+package org.oilmod.spigot.inventory.custom.api;
+
+import org.oilmod.api.userinterface.IInteractableUIElement;
+import org.oilmod.spigot.inventory.custom.slot.SettableViewSlot;
+import org.oilmod.spigot.util.OilSpigotUtil;
+import net.minecraft.server.EntityHuman;
+import net.minecraft.server.ItemStack;
+import org.bukkit.entity.Player;
+import org.oilmod.spigot.inventory.custom.slot.SettableViewSlot;
+import org.oilmod.spigot.util.OilSpigotUtil;
+
+/**
+ * Created by sirati97 on 16.06.2016 for spigot.
+ */
+public class OilInteractableElementWrapper extends OilElementWrapper implements SettableViewSlot, IInteractableUIElement {
+
+    public OilInteractableElementWrapper(IInteractableUIElement element) {
+        super(element);
+    }
+
+    @Override
+    public void setItem(int index, ItemStack itemStack) {
+        setDisplayed(index, OilSpigotUtil.toBukkit(itemStack));
+    }
+
+    @Override
+    public boolean isItemstackAllowed(int index, ItemStack itemStack) {
+        return isItemstackAllowed(index, OilSpigotUtil.toBukkit(itemStack));
+    }
+
+    @Override
+    public boolean isHumanAllowed(int index, EntityHuman human) {
+        return isPlayerAllowed(index, OilSpigotUtil.toBukkit(human));
+    }
+
+    @Override
+    public boolean isItemstackAllowed(int index, org.bukkit.inventory.ItemStack itemStack) {
+        return getElement().isItemstackAllowed(index, itemStack);
+    }
+
+    @Override
+    public boolean isPlayerAllowed(int i, Player player) {
+        return getElement().isPlayerAllowed(i, player);
+    }
+
+    @Override
+    public boolean isReadOnly(int index) {
+        return getElement().isReadOnly(index);
+    }
+
+    @Override
+    public int getMaxStackSize(int index, org.bukkit.inventory.ItemStack itemStack) {
+        return getElement().getMaxStackSize(index, itemStack);
+    }
+
+    @Override
+    public int getMaxStackSize(int index, ItemStack itemStack) {
+        return getMaxStackSize(index, OilSpigotUtil.toBukkit(itemStack));
+    }
+
+    @Override
+    public int getMaxStackSize(int index) {
+        return getElement().getMaxStackSize(index);
+    }
+
+    @Override
+    public IInteractableUIElement getElement() {
+        return (IInteractableUIElement) super.getElement();
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/inventory/custom/api/OilPanelWrapper.java b/src/main/java/org/oilmod/spigot/inventory/custom/api/OilPanelWrapper.java
new file mode 100644
index 00000000..d691d770
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/inventory/custom/api/OilPanelWrapper.java
@@ -0,0 +1,54 @@
+package org.oilmod.spigot.inventory.custom.api;
+
+import org.oilmod.api.userinterface.UIPanel;
+import org.oilmod.api.userinterface.UIElementResult;
+import org.oilmod.spigot.OilMain;
+import org.oilmod.spigot.inventory.custom.view.ISlotView;
+import org.oilmod.spigot.inventory.custom.slot.ViewSlotResult;
+import org.oilmod.spigot.OilMain;
+import org.oilmod.spigot.inventory.custom.slot.ViewSlotResult;
+import org.oilmod.spigot.inventory.custom.view.ISlotView;
+
+/**
+ * Created by sirati97 on 14.06.2016 for spigot.
+ */
+public class OilPanelWrapper implements ISlotView, WrappedPanel {
+    private final UIPanel oilPanel;
+
+    public OilPanelWrapper(UIPanel oilPanel) {
+        this.oilPanel = oilPanel;
+        if (oilPanel == null) {
+            OilMain.printTrace("should not be null!");
+        }
+    }
+
+    @Override
+    public ViewSlotResult get(int index) {
+        return getUIElement(index);
+    }
+
+    @Override
+    public int size() {
+        return oilPanel.size();
+    }
+
+    @Override
+    public boolean hasForm() {
+        return oilPanel.hasForm();
+    }
+
+    @Override
+    public ViewSlotResult getUIElement(int i) {
+        UIElementResult result = oilPanel.getUIElement(i);
+        if (result==null || result instanceof ViewSlotResult) {
+            return (ViewSlotResult) result;
+        } else {
+            throw new IllegalStateException("Please use UIElementResultFactory.createResult(...) to create instance of UIElementResult");
+        }
+    }
+
+    @Override
+    public UIPanel getOilPanel() {
+        return oilPanel;
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/inventory/custom/api/RealUIHelper.java b/src/main/java/org/oilmod/spigot/inventory/custom/api/RealUIHelper.java
new file mode 100644
index 00000000..965bfbdd
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/inventory/custom/api/RealUIHelper.java
@@ -0,0 +1,77 @@
+package org.oilmod.spigot.inventory.custom.api;
+
+import org.oilmod.api.userinterface.Click;
+import org.oilmod.api.userinterface.IInteractableUIElement;
+import org.oilmod.api.userinterface.IUIElement;
+import org.oilmod.api.userinterface.UIElementResult;
+import org.oilmod.api.userinterface.UIMultiPanel;
+import org.oilmod.api.userinterface.UIPanel;
+import org.oilmod.api.userinterface.UserInterfaceBuilder;
+import org.oilmod.api.userinterface.internal.NMSClickData;
+import org.oilmod.api.userinterface.internal.NMSFixedSizePanel;
+import org.oilmod.api.userinterface.internal.NMSMultiPanel;
+import org.oilmod.api.userinterface.internal.UIHelper;
+import org.oilmod.api.userinterface.internal.UserInterface;
+import org.oilmod.api.userinterface.internal.UserInterfaceFactory;
+import org.oilmod.spigot.inventory.custom.ClickExtraData;
+import org.oilmod.spigot.inventory.custom.slot.ViewSlotResult;
+import org.oilmod.spigot.util.OilSpigotUtil;
+import org.bukkit.entity.Player;
+import org.bukkit.inventory.ItemStack;
+
+/**
+ * Created by sirati97 on 14.06.2016 for spigot.
+ */
+public class RealUIHelper extends UIHelper implements UserInterfaceFactory {
+    @Override
+    public NMSMultiPanel createMultiPanel(UIMultiPanel uiMultiPanel) {
+        return null;
+    }
+
+    @Override
+    public NMSFixedSizePanel createFixedSizePanel(UIPanel uiPanel) {
+        return new NMSFixedSizePanelImpl(uiPanel);
+    }
+
+    @Override
+    public UserInterfaceFactory getInterfaceFactory() {
+        return this;
+    }
+
+    @Override
+    public UIElementResult createUIElementResult(IUIElement uiElement, int index) {
+        return ViewSlotResult.createOilInstance(uiElement, index);
+    }
+
+    @Override
+    public NMSClickData createNMSClickData(UserInterface userInterface) {
+
+        return new ClickExtraData(OilSpigotUtil.toNMS(userInterface), null);
+    }
+
+    @Override
+    public void handleInventoryClick(IInteractableUIElement iInteractableUIElement, Player player, int index, Click click, NMSClickData dataOil) {
+        ClickExtraData data = OilSpigotUtil.toNMS(dataOil);
+        data.setResult(data.getViewContainer().onClickCustom(data.getSingleSlot(),click.getSubType(), OilSpigotUtil.toNMS(click.getType()), OilSpigotUtil.toNMS(player)));
+    }
+
+    @Override
+    public UserInterface createChestInterface(Player player, UserInterfaceBuilder builder, String title, int row) {
+        return new UIChestContainer(player, builder, row, title);
+    }
+
+    @Override
+    public UserInterface createChestInterface(Player player, UserInterfaceBuilder builder, String title, int row, ItemStack background) {
+        return new UIChestContainer(player, builder, row, title, OilSpigotUtil.toNMS(background));
+    }
+
+    @Override
+    public UIPanel createPlayerPanel(UserInterface userInterface, Player player, boolean hotbarPosSwitched, boolean armor, boolean offhand, boolean filterItems) {
+        return OilSpigotUtil.toNMS(userInterface).createHumanInventorySlotView(OilSpigotUtil.toNMS(player), hotbarPosSwitched, armor, offhand, filterItems);
+    }
+
+    @Override
+    public UIPanel createPlayerPanel(UserInterface userInterface, boolean hotbarPosSwitched, boolean armor, boolean offhand, boolean filterItems) {
+        return OilSpigotUtil.toNMS(userInterface).createHumanInventorySlotView(hotbarPosSwitched, armor, offhand, filterItems);
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/inventory/custom/api/UIChestContainer.java b/src/main/java/org/oilmod/spigot/inventory/custom/api/UIChestContainer.java
new file mode 100644
index 00000000..20c46fa1
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/inventory/custom/api/UIChestContainer.java
@@ -0,0 +1,75 @@
+package org.oilmod.spigot.inventory.custom.api;
+
+import org.oilmod.api.userinterface.UIPanel;
+import org.oilmod.api.userinterface.UserInterfaceBuilder;
+import org.oilmod.api.userinterface.internal.UserInterface;
+import org.oilmod.spigot.inventory.custom.view.ISlotView;
+import org.oilmod.spigot.inventory.custom.nms.ViewContainer;
+import org.oilmod.spigot.util.OilSpigotUtil;
+import net.minecraft.server.ItemStack;
+import org.bukkit.entity.Player;
+import org.oilmod.spigot.inventory.custom.nms.ViewContainer;
+import org.oilmod.spigot.inventory.custom.view.ISlotView;
+import org.oilmod.spigot.util.OilSpigotUtil;
+
+/**
+ * Created by sirati97 on 14.06.2016 for spigot.
+ */
+public class UIChestContainer extends ViewContainer implements UserInterface {
+    private final Player player;
+    private final UserInterfaceBuilder<?> builder;
+
+    public UIChestContainer(Player player, UserInterfaceBuilder<?> builder, int rows, String title, ItemStack background) {
+        super(OilSpigotUtil.toNMS(player), rows, title, background);
+        this.player = player;
+        this.builder = builder;
+    }
+
+    public UIChestContainer(Player player, UserInterfaceBuilder<?> builder, int rows, String title) {
+        super(OilSpigotUtil.toNMS(player), rows, title);
+        this.player = player;
+        this.builder = builder;
+    }
+
+    @Override
+    public Player getPlayer() {
+        return player;
+    }
+
+    @Override
+    public void showPanel(UIPanel uiPanel) {
+        setView(OilSpigotUtil.toNMS(uiPanel));
+    }
+
+    @Override
+    public void showPanel(UIPanel uiPanelPlayer, UIPanel uiPanelChest) {
+        ISlotView viewPlayer = OilSpigotUtil.toNMS(uiPanelPlayer);
+        ISlotView viewChest = OilSpigotUtil.toNMS(uiPanelChest);
+        setSeparatedView(viewChest, viewPlayer);
+    }
+
+    @Override
+    public UIPanel getPanel() {
+        return OilSpigotUtil.toOil(getView());
+    }
+
+    @Override
+    public UserInterfaceBuilder<?> getBuilder() {
+        return builder;
+    }
+
+    @Override
+    public void display(Player player) {
+        OilSpigotUtil.toNMS(player).openContainer(getViewInventory());
+    }
+
+    @Override
+    public UIPanel createPlayerPanel(Player player, boolean hotbarPosSwitched, boolean armor, boolean offhand, boolean filterItems) {
+        return createHumanInventorySlotView(OilSpigotUtil.toNMS(player), hotbarPosSwitched, armor, offhand, filterItems);
+    }
+
+    @Override
+    public UIPanel createPlayerPanel(boolean hotbarPosSwitched, boolean armor, boolean offhand, boolean filterItems) {
+        return createHumanInventorySlotView(hotbarPosSwitched, armor, offhand, filterItems);
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/inventory/custom/api/WrappedPanel.java b/src/main/java/org/oilmod/spigot/inventory/custom/api/WrappedPanel.java
new file mode 100644
index 00000000..a6b425a3
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/inventory/custom/api/WrappedPanel.java
@@ -0,0 +1,10 @@
+package org.oilmod.spigot.inventory.custom.api;
+
+import org.oilmod.api.userinterface.UIPanel;
+
+/**
+ * Created by sirati97 on 14.06.2016 for spigot.
+ */
+public interface WrappedPanel {
+    UIPanel getOilPanel();
+}
diff --git a/src/main/java/org/oilmod/spigot/inventory/custom/bukkit/BukkitInventoryView.java b/src/main/java/org/oilmod/spigot/inventory/custom/bukkit/BukkitInventoryView.java
new file mode 100644
index 00000000..6b97ea50
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/inventory/custom/bukkit/BukkitInventoryView.java
@@ -0,0 +1,78 @@
+package org.oilmod.spigot.inventory.custom.bukkit;
+
+import net.minecraft.server.Container;
+import org.bukkit.GameMode;
+import org.bukkit.craftbukkit.entity.CraftHumanEntity;
+import org.bukkit.craftbukkit.inventory.CraftInventory;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
+import org.bukkit.entity.HumanEntity;
+import org.bukkit.event.inventory.InventoryType;
+import org.bukkit.inventory.Inventory;
+import org.bukkit.inventory.InventoryView;
+import org.bukkit.inventory.ItemStack;
+
+/**
+ * Created by sirati97 on 17.06.2016 for spigot.
+ */
+public class BukkitInventoryView extends InventoryView {
+    private final Container container;
+    private final CraftHumanEntity player;
+    private final CraftInventory viewing;
+
+    public BukkitInventoryView(HumanEntity player, Inventory viewing, Container container) {
+        // TODO: Should we make sure it really IS a CraftHumanEntity first? And a CraftInventory?
+        this.player = (CraftHumanEntity) player;
+        this.viewing = (CraftInventory) viewing;
+        this.container = container;
+    }
+
+    @Override
+    public Inventory getTopInventory() {
+        return viewing;
+    }
+
+    @Override
+    public Inventory getBottomInventory() {
+        return player.getInventory();
+    }
+
+    @Override
+    public HumanEntity getPlayer() {
+        return player;
+    }
+
+    @Override
+    public InventoryType getType() {
+        InventoryType type = viewing.getType();
+        if (type == InventoryType.CRAFTING && player.getGameMode() == GameMode.CREATIVE) {
+            return InventoryType.CREATIVE;
+        }
+        return type;
+    }
+
+    @Override
+    public void setItem(int slot, ItemStack item) {
+        net.minecraft.server.ItemStack stack = CraftItemStack.asNMSCopy(item);
+        if (slot != -999) {
+            container.getSlot(slot).set(stack);
+        } else {
+            player.getHandle().drop(stack, false);
+        }
+    }
+
+    @Override
+    public ItemStack getItem(int slot) {
+        if (slot == -999) {
+            return null;
+        }
+        return CraftItemStack.asCraftMirror(container.getSlot(slot).getItem());
+    }
+
+    public boolean isInTop(int rawSlot) {
+        return rawSlot < viewing.getSize();
+    }
+
+    public Container getHandle() {
+        return container;
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/inventory/custom/nms/MultiSlot.java b/src/main/java/org/oilmod/spigot/inventory/custom/nms/MultiSlot.java
new file mode 100644
index 00000000..4d24267c
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/inventory/custom/nms/MultiSlot.java
@@ -0,0 +1,83 @@
+package org.oilmod.spigot.inventory.custom.nms;
+
+import org.oilmod.spigot.inventory.custom.ClickExtraData;
+import org.oilmod.spigot.inventory.custom.view.ISlotView;
+import org.oilmod.spigot.inventory.custom.slot.SettableViewSlot;
+import org.oilmod.spigot.inventory.custom.slot.ViewSlotResult;
+import net.minecraft.server.EntityHuman;
+import net.minecraft.server.IInventory;
+import net.minecraft.server.InventoryClickType;
+import net.minecraft.server.ItemStack;
+import net.minecraft.server.Slot;
+import org.oilmod.spigot.inventory.custom.slot.SettableViewSlot;
+import org.oilmod.spigot.inventory.custom.slot.ViewSlotResult;
+import org.oilmod.spigot.inventory.custom.view.ISlotView;
+
+import javax.annotation.Nullable;
+
+/**
+ * Created by sirati97 on 02.04.2016.
+ */
+public class MultiSlot extends Slot {
+    private final ViewContainer viewContainer;
+
+    public MultiSlot(ViewContainer viewContainer, int index, int j, int k) {
+        super(null, index, j, k);
+        this.viewContainer = viewContainer;
+    }
+
+    @Override
+    public ItemStack getItem() {
+        ViewSlotResult result = getViewSlot();
+        return result==null?viewContainer.getNoSlotPlaceHolder():result.getSlot().getItem(result.getIndex());
+    }
+
+    @Override
+    public void set(@Nullable ItemStack itemstack) {
+        ViewSlotResult result = getViewSlot();
+        if (result != null &&result.getSlot() instanceof SettableViewSlot) {
+            ((SettableViewSlot) result.getSlot()).setItem(result.getIndex(), itemstack);
+        }
+    }
+
+    public ItemStack clickItem(int button, InventoryClickType mode, EntityHuman entityhuman) {
+        ViewSlotResult result = getViewSlot();
+        if (result == null) {
+            return ItemStack.a;
+        } else {
+            ClickExtraData data = new ClickExtraData(viewContainer, result);
+            result.getSlot().clickItem(result.getIndex(), button, mode, entityhuman, data);
+            return data.getResult();
+        }
+    }
+
+    public ViewSlotResult getViewSlot() {
+        ISlotView view = viewContainer.getView();
+        ViewSlotResult result = view==null?null:view.get(index);
+        if (result == null) {
+            return null;
+        } else {
+            result.setPacketSlotIndex(index);
+            return result;
+        }
+    }
+
+    @Override
+    public int getMaxStackSize() {
+        return 64;
+    }
+
+    @Override
+    public void f() {
+        System.out.println("invoked update");
+    }
+
+    public int getIndex() {
+        return index;
+    }
+
+    @Override
+    public IInventory getInventory() {
+        return viewContainer.getViewInventory();
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/inventory/custom/nms/SettableSlotInventorySnapshot.java b/src/main/java/org/oilmod/spigot/inventory/custom/nms/SettableSlotInventorySnapshot.java
new file mode 100644
index 00000000..f79008de
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/inventory/custom/nms/SettableSlotInventorySnapshot.java
@@ -0,0 +1,187 @@
+package org.oilmod.spigot.inventory.custom.nms;
+
+import net.minecraft.server.NonNullList;
+import org.oilmod.spigot.inventory.custom.ISingleSlot;
+import org.oilmod.spigot.util.OilSpigotUtil;
+import net.minecraft.server.ChatComponentText;
+import net.minecraft.server.ChatMessage;
+import net.minecraft.server.EntityHuman;
+import net.minecraft.server.IChatBaseComponent;
+import net.minecraft.server.IInventory;
+import net.minecraft.server.ItemStack;
+import org.bukkit.Location;
+import org.bukkit.craftbukkit.entity.CraftHumanEntity;
+import org.bukkit.entity.HumanEntity;
+
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Created by sirati97 on 17.06.2016 for spigot.
+ */
+public class SettableSlotInventorySnapshot implements IInventory {
+
+
+    //IINVENTORY
+
+    // CraftBukkit start
+    private int maxStack = MAX_STACK;
+
+
+
+    public org.bukkit.inventory.InventoryHolder getOwner() {
+        return null; // Result slots don't get an owner
+    }
+
+    // Don't need a transaction; the InventoryCrafting keeps track of it for us
+    public void onOpen(CraftHumanEntity who) {}
+    public void onClose(CraftHumanEntity who) {}
+    public java.util.List<HumanEntity> getViewers() {
+        return new java.util.ArrayList<HumanEntity>();
+    }
+
+    public void setMaxStackSize(int size) {
+        maxStack = size;
+    }
+    // CraftBukkit end
+
+
+
+    public String getName() {
+        return "Result";
+    }
+
+    public boolean hasCustomName() {
+        return false;
+    }
+
+    public IChatBaseComponent getScoreboardDisplayName() {
+        return (IChatBaseComponent) (this.hasCustomName() ? new ChatComponentText(this.getName()) : new ChatMessage(this.getName()));
+    }
+
+    public ItemStack splitStack(int i, int j) {
+        ItemStack stack = this.getItem(i);
+        this.setItem(i, ItemStack.a);
+        return stack;
+    }
+
+    public ItemStack splitWithoutUpdate(int i) {
+        return splitStack(i,0);
+    }
+
+
+    public int getMaxStackSize() {
+        return maxStack; // CraftBukkit
+    }
+
+    public void update() {}
+
+    public boolean a(EntityHuman entityhuman) {
+        return true;
+    }
+
+    public void startOpen(EntityHuman entityhuman) {}
+
+    public void closeContainer(EntityHuman entityhuman) {}
+
+    @Override
+    public boolean b(int i, ItemStack itemstack) {
+        return true;
+    }
+
+    public int getProperty(int i) {
+        return 0;
+    }
+
+    @Override
+    public void setProperty(int i, int j) {
+
+    }
+
+    public int h() {
+        return 0;
+    }
+
+    //NOT IMPLEMENTED
+    public void clear() {
+        throw OilSpigotUtil.NotImplementedException();
+    }
+
+    public NonNullList<ItemStack> getContents() {
+        throw OilSpigotUtil.NotImplementedException();
+    }
+
+    @Override
+    public Location getLocation() {
+        throw OilSpigotUtil.NotImplementedException();
+    }
+
+    //CTOR
+    private final ViewContainer container;
+
+    public SettableSlotInventorySnapshot(ViewContainer container) {
+        this.container = container;
+    }
+
+    //ACTUAL STUFF
+    private List<ISingleSlot> slots;
+    private Map<Integer, ISingleSlot> packetIdSlotMap;
+
+    void init(List<ISingleSlot> slots, Map<Integer, ISingleSlot> rawSlotMap) {
+        this.packetIdSlotMap = rawSlotMap;
+        this.slots = slots;
+    }
+
+    private void checkInit() {
+        if (slots == null || packetIdSlotMap == null) {
+            container.initSnapshot(this);
+        }
+    }
+
+
+    public int getSize() {
+        checkInit();
+        return slots.size();
+    }
+
+    @Override
+    public boolean x_() {
+        return false; //TODO help was does this method do
+    }
+
+    public ItemStack getItem(int i) {
+        return getSlot(i).getItem();
+    }
+
+    public void setItem(int i, ItemStack itemstack) {
+        getSlot(i).setItem(itemstack);
+    }
+
+    public ISingleSlot getSlot(int i) {
+        checkInit();
+        return slots.get(i);
+    }
+
+    public ISingleSlot getSlotByPacketId(int i) {
+        checkInit();
+        return packetIdSlotMap.get(i);
+    }
+
+
+
+    public int indexOfOrAdd(ISingleSlot slot) {
+        checkInit();
+        int index = slots.indexOf(slot);
+        if (index < 0) {
+            index = slots.size();
+            add(slot);
+        }
+        return index;
+    }
+
+    private void add(ISingleSlot slot) {
+        checkInit();
+        slots.add(slot);
+        packetIdSlotMap.put(slot.getPacketSlotIndex(), slot);
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/inventory/custom/nms/ViewContainer.java b/src/main/java/org/oilmod/spigot/inventory/custom/nms/ViewContainer.java
new file mode 100644
index 00000000..dfabd376
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/inventory/custom/nms/ViewContainer.java
@@ -0,0 +1,783 @@
+package org.oilmod.spigot.inventory.custom.nms;
+
+import com.google.common.collect.Sets;
+import org.oilmod.spigot.inventory.custom.ISingleSlot;
+import org.oilmod.spigot.inventory.custom.view.HumanInventorySlotView;
+import org.oilmod.spigot.inventory.custom.view.ISlotView;
+import org.oilmod.spigot.inventory.custom.view.NullSlotView;
+import org.oilmod.spigot.inventory.custom.view.StaticSplittedSlotView;
+import gnu.trove.map.hash.THashMap;
+import net.minecraft.server.Blocks;
+import net.minecraft.server.Container;
+import net.minecraft.server.EntityHuman;
+import net.minecraft.server.EntityPlayer;
+import net.minecraft.server.InventoryClickType;
+import net.minecraft.server.Item;
+import net.minecraft.server.ItemStack;
+import net.minecraft.server.MathHelper;
+import net.minecraft.server.PacketPlayOutSetSlot;
+import net.minecraft.server.PlayerInventory;
+import net.minecraft.server.Slot;
+import org.bukkit.craftbukkit.inventory.CraftInventory;
+import org.bukkit.craftbukkit.inventory.CraftInventoryView;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
+import org.bukkit.event.Event;
+import org.bukkit.event.inventory.InventoryDragEvent;
+import org.bukkit.event.inventory.InventoryType;
+import org.bukkit.inventory.InventoryView;
+import org.oilmod.spigot.inventory.custom.view.HumanInventorySlotView;
+import org.oilmod.spigot.inventory.custom.view.ISlotView;
+import org.oilmod.spigot.inventory.custom.view.NullSlotView;
+import org.oilmod.spigot.inventory.custom.view.StaticSplittedSlotView;
+
+import javax.annotation.Nullable;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+/**
+ * Created by sirati97 on 02.04.2016.
+ */
+public class ViewContainer extends Container {
+    private final EntityHuman human;
+    private final int rows;
+    private ISlotView view;
+    private final ViewInventory viewInventory;
+    private CraftInventoryView bukkitView = null;
+    private final ItemStack noSlotPlaceHolder;
+    private final String title;
+    private boolean droppingAllowed = true;
+
+
+    public ViewContainer(EntityHuman human, int rows, String title) {
+        this(human, rows, title, createBackground());
+    }
+
+    public ViewContainer(EntityHuman human, int rows, String title, ItemStack noSlotPlaceHolder) {
+        this.human = human;
+        this.rows = rows;
+        this.title = title;
+        this.viewInventory = new ViewInventory(this);
+        this.bukkitView = new CraftInventoryView(this.human.getBukkitEntity(), getViewInventory().getBukkitInventory(), this); //Will represent the visible Inventory as a BukkitInventory. rather stupid. - will be replaced whenever a play interacts with a Settable SLot
+        this.noSlotPlaceHolder = noSlotPlaceHolder;
+        int i = (rows - 4) * 18;
+        int index=0;
+        int j;
+        int k;
+
+        for (j = 0; j < rows; ++j) { //chest area
+            for (k = 0; k < 9; ++k) {
+                this.a(new MultiSlot(this, index++, 8 + k * 18, 18 + j * 18));
+            }
+        }
+
+        for (j = 0; j < 3; ++j) { //player area
+            for (k = 0; k < 9; ++k) {
+                this.a(new MultiSlot(this, index++, 8 + k * 18, 103 + j * 18 + i));
+            }
+        }
+
+        for (j = 0; j < 9; ++j) { //hotbar area
+            this.a(new MultiSlot(this, index++, 8 + j * 18, 161 + i));
+        }
+    }
+
+    private static ItemStack createBackground() {
+        ItemStack result = new ItemStack(Blocks.STAINED_GLASS_PANE, 1, 7);
+        result.c("r");
+        return result;
+    }
+
+    @Override
+    public InventoryView getBukkitView() {
+        return bukkitView;
+    }
+
+    public void setBukkitView(CraftInventoryView bukkitView) {
+        this.bukkitView = bukkitView;
+    }
+
+    @Override
+    public boolean canUse(EntityHuman entityhuman) {
+        return true;
+    }
+
+    public ISlotView getView() {
+        return view;
+    }
+
+    public void setView(ISlotView view) {
+        this.view = view;
+    }
+
+    public void setSeparatedView(ISlotView chestView, ISlotView playerView) {
+        this.view = new StaticSplittedSlotView(chestView==null?new NullSlotView(rows*9):chestView, rows*9, playerView==null?new NullSlotView(4*9):playerView, 4*9);
+    }
+
+    public void setDroppingAllowed(boolean droppingAllowed) {
+        this.droppingAllowed = droppingAllowed;
+    }
+
+    public boolean isDroppingAllowed() {
+        return droppingAllowed;
+    }
+
+    public HumanInventorySlotView createHumanInventorySlotView(EntityHuman human, boolean hotbarPosSwitched, boolean armor, boolean offhand, boolean filterItems) {
+        return new HumanInventorySlotView(human, hotbarPosSwitched, armor, offhand, filterItems);
+    }
+
+    public HumanInventorySlotView createHumanInventorySlotView(boolean hotbarPosSwitched, boolean armor, boolean offhand, boolean filterItems) {
+        return createHumanInventorySlotView(human, hotbarPosSwitched, armor, offhand, filterItems);
+    }
+
+    public ViewInventory getViewInventory() {
+        return viewInventory;
+    }
+
+    protected void onClose() {
+        if (!droppingAllowed) {
+            human.inventory.setCarried(ItemStack.a);
+        }
+        if (human instanceof EntityPlayer) {
+            ((EntityPlayer) human).updateInventory(human.defaultContainer);
+        }
+    }
+
+    @Override
+    public ItemStack a(int slotId, int button, InventoryClickType mode, EntityHuman entityhuman) {
+        if (droppingAllowed && slotId == -999) {
+            return super.a(slotId, button, mode, entityhuman); //allow dropping
+        }
+        if (slotId<0)return ItemStack.a;
+        return getSlot(slotId).clickItem(button, mode, entityhuman);
+        //((EntityPlayer) entityhuman).updateInventory(this); //TODO: improve this. only resend changed items NOTE: dont seem to be required
+    }
+
+    @Override
+    public MultiSlot getSlot(int i) {
+        return (MultiSlot) super.getSlot(i);
+    }
+
+    public int getRows() {
+        return rows;
+    }
+
+    public ItemStack getNoSlotPlaceHolder() {
+        return noSlotPlaceHolder;
+    }
+
+    public EntityHuman getHuman() {
+        return human;
+    }
+
+    @Override
+    public void b(EntityHuman entityhuman) {
+        super.b(entityhuman);
+        viewInventory.closeContainer(entityhuman);
+    }
+
+    public String getTitle() {
+        return title;
+    }
+
+    void initSnapshot(SettableSlotInventorySnapshot inventory) {
+        List<ISingleSlot> slots = new ArrayList<>();
+        Map<Integer, ISingleSlot> packetIdSlotMap = new THashMap<>();
+        for (Slot slotUncasted:this.slots) {
+            MultiSlot slot = (MultiSlot) slotUncasted;
+            ISingleSlot oilSlot = slot.getViewSlot();
+            if (oilSlot != null && oilSlot.isSettable()) {
+                slots.add(oilSlot);
+                packetIdSlotMap.put(oilSlot.getPacketSlotIndex(), oilSlot);
+            }
+        }
+        inventory.init(slots, packetIdSlotMap);
+    }
+
+    //OilSpigot - should always be like the normal onClick method
+    //TODO: do not call update. (Find other alternative than this.update() for slot.f())
+
+
+    protected void resetCustomClickData() {
+        this.customClick_g = 0;
+        this.customClick_h.clear();
+    }
+
+    public static boolean a(ISingleSlot slot, ItemStack itemstack, boolean flag) {
+        boolean flag1 = slot == null || !slot.hasItem();
+
+        if (slot != null && slot.hasItem() && !itemstack.isEmpty() && itemstack.doMaterialsMatch(slot.getItem()) && ItemStack.equals(slot.getItem(), itemstack)) {
+            flag1 |= slot.getItem().getCount() + (flag ? 0 : itemstack.getCount()) <= itemstack.getMaxStackSize();
+        }
+
+        return flag1;
+    }
+
+    public static void splitStack(Set<ISingleSlot> set, int i, ItemStack itemstack, int j) {
+        switch (i) {
+            case 0:
+                itemstack.setCount(MathHelper.d((float) itemstack.getCount() / (float) set.size()));
+                break;
+
+            case 1:
+                itemstack.setCount(1);
+                break;
+
+            case 2:
+                itemstack.setCount(itemstack.getItem().getMaxStackSize());
+        }
+
+        itemstack.add(j);
+    }
+
+
+    @Nullable
+    public ItemStack doShift(SettableSlotInventorySnapshot inventory, EntityHuman entityhuman, ISingleSlot slot) {
+        ItemStack itemstack = ItemStack.a;
+
+        if (slot != null && slot.hasItem()) {
+            ItemStack itemstack1 = slot.getItem();
+
+            itemstack = itemstack1.cloneItemStack();
+            if (slot.getPacketSlotIndex() < this.rows * 9) {
+                if (!this.execShift(inventory, entityhuman, itemstack1, this.rows * 9, this.slots.size(), true)) {
+                    return ItemStack.a;
+                }
+            } else if (!this.execShift(inventory, entityhuman, itemstack1, 0, this.rows * 9, false)) {
+                return ItemStack.a;
+            }
+
+            if (itemstack1.getCount() == 0) {
+                slot.setItem(ItemStack.a);
+            } else {
+                update();//slot.f();
+            }
+        }
+
+        return itemstack;
+    }
+
+    protected boolean execShift(SettableSlotInventorySnapshot inventory, EntityHuman entityhuman, ItemStack itemstack, int lowerBound, int upperBound, boolean flag) {
+        boolean flag1 = false;
+        int k = lowerBound;
+
+        if (flag) {
+            k = upperBound - 1;
+        }
+
+        ISingleSlot slot;
+        ItemStack itemstack1;
+
+        if (itemstack.isStackable()) {
+            while (itemstack.getCount() > 0 && (!flag && k < upperBound || flag && k >= lowerBound)) {
+                slot = inventory.getSlotByPacketId(k);
+                if (slot != null && slot.isAllowed(entityhuman) && slot.isAllowed(itemstack)) {
+                    itemstack1 = slot.getItem();
+                    if (!itemstack1.isEmpty() && ItemStack.matchesIgnoresCount(itemstack, itemstack1)) {
+                        int l = itemstack1.getCount() + itemstack.getCount();
+
+                        // CraftBukkit start - itemstack.getMaxStackSize() -> maxStack
+                        int maxStack = Math.min(itemstack.getMaxStackSize(), slot.getMaxStackSize());
+                        if (l <= maxStack) {
+                            itemstack.setCount(0);
+                            itemstack1.setCount(1);
+                            update();//slot.f();
+                            flag1 = true;
+                        } else if (itemstack1.getCount() < maxStack) {
+                            itemstack.subtract(maxStack - itemstack1.getCount());
+                            itemstack1.setCount(maxStack);
+                            // CraftBukkit end
+                            update();//slot.f();
+                            flag1 = true;
+                        }
+                    }
+                }
+
+
+                if (flag) {
+                    --k;
+                } else {
+                    ++k;
+                }
+            }
+        }
+
+        if (itemstack.getCount() > 0) {
+            if (flag) {
+                k = upperBound - 1;
+            } else {
+                k = lowerBound;
+            }
+
+            while (!flag && k < upperBound || flag && k >= lowerBound) {
+                slot = inventory.getSlotByPacketId(k);
+                if (slot != null && slot.isAllowed(entityhuman) && slot.isAllowed(itemstack)) {
+                    itemstack1 = slot.getItem();
+                    if (itemstack1.isEmpty()) {
+                        slot.setItem(itemstack.cloneItemStack());
+                        update();//slot.f();
+                        itemstack.setCount(0);
+                        flag1 = true;
+                        break;
+                    }
+                }
+
+                if (flag) {
+                    --k;
+                } else {
+                    ++k;
+                }
+            }
+        }
+
+        return flag1;
+    }
+
+    private int customClick_dragType = -1;
+    private int customClick_g;
+    private final Set<ISingleSlot> customClick_h = Sets.newHashSet();
+    @Nullable
+    public ItemStack onClickCustom(ISingleSlot slot, int button, InventoryClickType mode, EntityHuman entityhuman) {
+        SettableSlotInventorySnapshot iSnap = new SettableSlotInventorySnapshot(this);
+        CraftInventoryView bukkitView = new CraftInventoryView(entityhuman.getBukkitEntity(), new CraftInventory(iSnap), this);
+        setBukkitView(bukkitView);
+        return onClickCustom(slot, button, mode, entityhuman, iSnap, bukkitView);
+    }
+
+    //TODO: update the current version of this method
+    @Nullable
+    private  ItemStack onClickCustom(ISingleSlot slot, int button, InventoryClickType mode, EntityHuman entityhuman, SettableSlotInventorySnapshot iSnap, CraftInventoryView bukkitView) {
+        ItemStack result = ItemStack.a;
+        PlayerInventory playerinventory = entityhuman.inventory;
+        int k;
+        ItemStack slotItemStack = slot.getItem();
+
+
+
+
+
+        //##################################################
+        //##################Multi-Slot######################
+        //##################################################
+        if (mode == InventoryClickType.QUICK_CRAFT) {
+            int l = this.customClick_g;
+
+            this.customClick_g = c(button);
+            if ((l != 1 || this.customClick_g != 2) && l != this.customClick_g) {
+                this.resetCustomClickData();
+            } else if (playerinventory.getCarried().isEmpty()) {
+                this.resetCustomClickData();
+            } else if (this.customClick_g == 0) {
+                this.customClick_dragType = b(button);
+                if (a(this.customClick_dragType, entityhuman)) {
+                    this.customClick_g = 1;
+                    this.customClick_h.clear();
+                } else {
+                    this.resetCustomClickData();
+                }
+            } else if (this.customClick_g == 1) {
+
+                if (a(slot, playerinventory.getCarried(), true) && slot.isAllowed(playerinventory.getCarried()) && playerinventory.getCarried().getCount() > this.customClick_h.size()) {
+                    this.customClick_h.add(slot);
+                }
+            } else if (this.customClick_g == 2) {
+                if (!this.customClick_h.isEmpty()) {
+                    ItemStack carried = playerinventory.getCarried().cloneItemStack();
+                    k = playerinventory.getCarried().getCount();
+                    Iterator<ISingleSlot> iterator = this.customClick_h.iterator();
+
+                    Map<Integer, ItemStack> draggedSlots = new HashMap<Integer, ItemStack>(); // CraftBukkit - Store slots from drag in map (raw slot id -> new stack)
+                    while (iterator.hasNext()) {
+                        ISingleSlot slot1 = iterator.next();
+
+                        if (slot1 != null && a(slot1, playerinventory.getCarried(), true) && slot1.isAllowed(playerinventory.getCarried()) && playerinventory.getCarried().getCount() >= this.customClick_h.size()) {
+                            ItemStack itemstack2 = carried.cloneItemStack();
+                            int i1 = slot1.hasItem() ? slot1.getItem().getCount() : 0;
+
+                            splitStack(this.customClick_h, this.customClick_dragType, itemstack2, i1);
+                            if (itemstack2.getCount() > itemstack2.getMaxStackSize()) {
+                                itemstack2.setCount(itemstack2.getMaxStackSize());
+                            }
+
+                            if (itemstack2.getCount() > slot1.getMaxStackSize(itemstack2)) {
+                                itemstack2.setCount(slot1.getMaxStackSize(itemstack2));
+                            }
+
+                            k -= itemstack2.getCount() - i1;
+                            // slot1.set(itemstack2);
+                            draggedSlots.put(iSnap.indexOfOrAdd(slot1), itemstack2); // CraftBukkit - Put in map instead of setting
+                        }
+                    }
+
+                    // CraftBukkit start - InventoryDragEvent
+
+
+                    org.bukkit.inventory.ItemStack newcursor = CraftItemStack.asCraftMirror(carried);
+                    newcursor.setAmount(k);
+                    Map<Integer, org.bukkit.inventory.ItemStack> eventmap = new HashMap<Integer, org.bukkit.inventory.ItemStack>();
+                    for (Map.Entry<Integer, ItemStack> ditem : draggedSlots.entrySet()) {
+                        //OilSpigot start - use asCraftMirror
+                        eventmap.put(ditem.getKey(), CraftItemStack.asCraftMirror(ditem.getValue().cloneItemStack()));
+                        //OilSpigot end
+                    }
+
+                    // It's essential that we set the cursor to the new value here to prevent item duplication if a plugin closes the inventory.
+                    ItemStack oldCursor = playerinventory.getCarried();
+                    playerinventory.setCarried(CraftItemStack.asNMSCopy(newcursor));
+
+                    //OilSpigot start - use asCraftMirror
+                    InventoryDragEvent event = new InventoryDragEvent(bukkitView, (newcursor.getType() != org.bukkit.Material.AIR ? newcursor : null), CraftItemStack.asCraftMirror(oldCursor).clone(), this.customClick_dragType == 1, eventmap);
+                    //OilSpigot end
+                    entityhuman.world.getServer().getPluginManager().callEvent(event);
+
+                    // Whether or not a change was made to the inventory that requires an update.
+                    boolean needsUpdate = event.getResult() != Event.Result.DEFAULT;
+
+                    if (event.getResult() != Event.Result.DENY) {
+                        for (Map.Entry<Integer, ItemStack> dslot : draggedSlots.entrySet()) {
+                            //OilSpigot start - use asCraftMirror
+                            bukkitView.setItem(dslot.getKey(), CraftItemStack.asCraftMirror(dslot.getValue()).clone());
+                            //OilSpigot end
+                        }
+                        // The only time the carried item will be set to ItemStack.a is if the inventory is closed by the server.
+                        // If the inventory is closed by the server, then the cursor items are dropped.  This is why we change the cursor early.
+                        if (!playerinventory.getCarried().isEmpty()) {
+                            playerinventory.setCarried(CraftItemStack.asNMSCopy(event.getCursor()));
+                            needsUpdate = true;
+                        }
+                    } else {
+                        playerinventory.setCarried(oldCursor);
+                    }
+
+                    if (needsUpdate && entityhuman instanceof EntityPlayer) {
+                        ((EntityPlayer) entityhuman).updateInventory(this);
+                    }
+                    // CraftBukkit end
+                }
+
+                this.resetCustomClickData();
+            } else {
+                this.resetCustomClickData();
+            }
+        } else if (this.customClick_g != 0) {
+            this.resetCustomClickData();
+        }
+        
+        
+        
+        
+        
+        
+        //##################################################
+        //##################Shift-Move######################
+        //##################################################
+        else {
+            int j1;
+
+            if ((mode == InventoryClickType.PICKUP || mode == InventoryClickType.QUICK_MOVE) && (button == 0 || button == 1)) {
+                if (mode == InventoryClickType.QUICK_MOVE) {
+
+                    if (slot.isAllowed(entityhuman)) {
+                        if (!slotItemStack.isEmpty() && slotItemStack.getCount() <= 0) {
+                            result = slotItemStack.cloneItemStack();
+                            slot.setItem(ItemStack.a);
+                            slotItemStack = ItemStack.a;
+                        }
+
+                        ItemStack shiftResult = this.doShift(iSnap, entityhuman, slot);
+
+                        if (!shiftResult.isEmpty()) {
+                            Item item = shiftResult.getItem();
+
+                            result = shiftResult.cloneItemStack();
+                            if (!slotItemStack.isEmpty() && slotItemStack.getItem() == item) {
+                                this.onClickCustom(slot, button, InventoryClickType.QUICK_MOVE, entityhuman, iSnap, bukkitView); //IDK what this is doing or how it works
+                            }
+
+                        }
+                    }
+                }
+
+
+
+
+
+
+                //##################################################
+                //##################Normal-Click####################
+                //##################################################
+                else {
+                    ItemStack carried = playerinventory.getCarried();
+                    if (!slotItemStack.isEmpty()) {
+                        result = slotItemStack.cloneItemStack();
+                    }
+
+                    //OilSpigot start
+                    boolean requiresUpdate = !carried.isEmpty() && !slot.isAllowed(carried);
+                    //OilSpigot end
+
+                    if (slotItemStack.isEmpty()) {
+                        if (!carried.isEmpty() && slot.isAllowed(carried)) {
+                            j1 = button == 0 ? carried.getCount() : 1;
+                            if (j1 > slot.getMaxStackSize(carried)) {
+                                j1 = slot.getMaxStackSize(carried);
+                            }
+
+                            slot.setItem(carried.cloneAndSubtract(j1));
+                            if (carried.getCount() == 0) {
+                                playerinventory.setCarried(ItemStack.a);
+                                // CraftBukkit start - Update client cursor if we didn't empty it
+                            } else if (entityhuman instanceof EntityPlayer) {
+                                ((EntityPlayer) entityhuman).playerConnection.sendPacket(new PacketPlayOutSetSlot(-1, -1, entityhuman.inventory.getCarried()));
+                            }
+                            // CraftBukkit end
+                        }
+                    } else if (slot.isAllowed(entityhuman)) {
+                        if (carried.isEmpty()) {
+                            if (slotItemStack.getCount() > 0) {
+                                j1 = button == 0 ? slotItemStack.getCount() : (slotItemStack.getCount() + 1) / 2;
+                                playerinventory.setCarried(slot.splitItemStack(j1));
+                                if (slotItemStack.getCount() <= 0) {
+                                    slot.setItem(ItemStack.a);
+                                }
+
+                                update();//slot.a(entityhuman, playerinventory.getCarried());
+                            } else {
+                                slot.setItem(ItemStack.a);
+                                playerinventory.setCarried(ItemStack.a);
+                            }
+                        } else if (slot.isAllowed(carried)) {
+                            if (slotItemStack.getItem() == carried.getItem() && slotItemStack.getData() == carried.getData() && ItemStack.equals(slotItemStack, carried)) {
+                                j1 = button == 0 ? carried.getCount() : 1;
+                                if (j1 > slot.getMaxStackSize(carried) - slotItemStack.getCount()) {
+                                    j1 = slot.getMaxStackSize(carried) - slotItemStack.getCount();
+                                }
+
+                                if (j1 > carried.getMaxStackSize() - slotItemStack.getCount()) {
+                                    j1 = carried.getMaxStackSize() - slotItemStack.getCount();
+                                }
+
+                                carried.cloneAndSubtract(j1);
+                                if (carried.getCount() == 0) {
+                                    playerinventory.setCarried(ItemStack.a);
+                                    // CraftBukkit start - Update client cursor if we didn't empty it
+                                } else if (entityhuman instanceof EntityPlayer) {
+                                    ((EntityPlayer) entityhuman).playerConnection.sendPacket(new PacketPlayOutSetSlot(-1, -1, entityhuman.inventory.getCarried()));
+                                }
+                                // CraftBukkit end
+
+                                slotItemStack.add(j1);
+                            } else if (carried.getCount() <= slot.getMaxStackSize(carried)) {
+                                slot.setItem(carried);
+                                playerinventory.setCarried(slotItemStack);
+                            }
+                        } else if (slotItemStack.getItem() == carried.getItem() && carried.getMaxStackSize() > 1 && (!slotItemStack.usesData() || slotItemStack.getData() == carried.getData()) && ItemStack.equals(slotItemStack, carried)) {
+                            j1 = slotItemStack.getCount();
+                            // CraftBukkit start - carried.getMaxStackSize() -> maxStack
+                            int maxStack = Math.min(carried.getMaxStackSize(), slot.getMaxStackSize());
+                            if (j1 > 0 && j1 + carried.getCount() <= maxStack) {
+                                // CraftBukkit end
+                                carried.add(j1);
+                                slotItemStack = slot.splitItemStack(j1);
+                                if (slotItemStack.getCount() == 0) {
+                                    slot.setItem(ItemStack.a);
+                                }
+
+                                update();//slot.a(entityhuman, playerinventory.getCarried());
+                                // CraftBukkit start - Update client cursor if we didn't empty it
+                            } else if (entityhuman instanceof EntityPlayer) {
+                                ((EntityPlayer) entityhuman).playerConnection.sendPacket(new PacketPlayOutSetSlot(-1, -1, entityhuman.inventory.getCarried()));
+                            }
+                            // CraftBukkit end
+                        }
+                    }
+
+                    update();
+
+                    //OilSpigot start
+                    if (requiresUpdate && entityhuman instanceof EntityPlayer) {
+                        ItemStack slotUpdated = slot.getItem();
+                        ((EntityPlayer) entityhuman).playerConnection.sendPacket(new PacketPlayOutSetSlot(this.windowId, slot.getPacketSlotIndex(), slotUpdated.isEmpty()||slotUpdated.getCount()<1?ItemStack.a:slotUpdated));
+                        ItemStack carriedUpdated = playerinventory.getCarried();
+                        ((EntityPlayer) entityhuman).playerConnection.sendPacket(new PacketPlayOutSetSlot(-1, -1, carriedUpdated.isEmpty()||carriedUpdated.getCount()<1?ItemStack.a:carriedUpdated));
+                    }
+                    //OilSpigot end
+
+                    // CraftBukkit start - Make sure the client has the right slot contents
+                    if (entityhuman instanceof EntityPlayer && slot.getMaxStackSize() != 64) {
+                        ((EntityPlayer) entityhuman).playerConnection.sendPacket(new PacketPlayOutSetSlot(this.windowId, slot.getPacketSlotIndex(), slot.getItem()));
+                        // Updating a crafting inventory makes the client reset the result slot, have to send it again
+                        if (this.getBukkitView().getType() == InventoryType.WORKBENCH || this.getBukkitView().getType() == InventoryType.CRAFTING) {
+                            ((EntityPlayer) entityhuman).playerConnection.sendPacket(new PacketPlayOutSetSlot(this.windowId, 0, this.getSlot(0).getItem()));
+                        }
+                    }
+                    // CraftBukkit end
+                }
+            }
+
+
+
+
+
+            
+
+
+            
+
+            //##################################################
+            //##################Number-Swap#####################
+            //##################################################
+            else if (mode == InventoryClickType.SWAP && button >= 0 && button < 9) {
+                ISingleSlot playerSlot = iSnap.getSlotByPacketId((rows+3)*9+button);
+                if (playerSlot != null) {
+                    ItemStack playerItemStack = playerSlot.getItem();
+                    if (!playerItemStack.isEmpty() && playerItemStack.getCount() <= 0) {
+                        playerItemStack = ItemStack.a;
+                        playerSlot.setItem(ItemStack.a);
+                    }
+
+                    //OilSpigot start
+                    boolean requiresUpdate = !slot.isAllowed(entityhuman) || !playerSlot.isAllowed(entityhuman) || (!playerItemStack.isEmpty() && !slot.isAllowed(playerItemStack)) || (!slotItemStack.isEmpty() && !playerSlot.isAllowed(slotItemStack));
+                    //OilSpigot end
+
+                    if (slot.isAllowed(entityhuman) && playerSlot.isAllowed(entityhuman) && (!playerItemStack.isEmpty() || !slotItemStack.isEmpty())) {//OilSpigot - Added test for entity permission
+                        if (playerItemStack == ItemStack.a) {
+                            if (playerSlot.isAllowed(slotItemStack)) {
+                                playerSlot.setItem(slotItemStack);
+                                slot.setItem(ItemStack.a);
+                                update(); //slot
+                            }
+                        } else if (slotItemStack.isEmpty()) {
+                            if (slot.isAllowed(playerItemStack)) {
+                                j1 = slot.getMaxStackSize(playerItemStack);
+                                if (playerItemStack.getCount() > j1) {
+                                    slot.setItem(playerItemStack.cloneAndSubtract(j1));
+                                } else {
+                                    slot.setItem(playerItemStack);
+                                    playerSlot.setItem(ItemStack.a);
+                                }
+                            }
+                        } else if (slot.isAllowed(playerItemStack) && playerSlot.isAllowed(slotItemStack)) {
+                            j1 = slot.getMaxStackSize(playerItemStack);
+                            if (playerItemStack.getCount() > j1) {
+                                if (droppingAllowed) {
+                                    slot.setItem(playerItemStack.cloneAndSubtract(j1));
+                                    update(); //slot
+                                    entityhuman.drop(slotItemStack, true);
+                                }
+                            } else {
+                                slot.setItem(playerItemStack);
+                                playerSlot.setItem(slotItemStack);
+                                update(); //slot
+                            }
+                        }
+                    }
+
+
+
+                    //OilSpigot start
+                    if (requiresUpdate && entityhuman instanceof EntityPlayer) {
+                        ItemStack slotUpdated = slot.getItem();
+                        ((EntityPlayer) entityhuman).playerConnection.sendPacket(new PacketPlayOutSetSlot(this.windowId, slot.getPacketSlotIndex(), slotUpdated.isEmpty()||slotUpdated.getCount()<1?ItemStack.a:slotUpdated));
+                        ItemStack slot2Updated = slot.getItem();
+                        ((EntityPlayer) entityhuman).playerConnection.sendPacket(new PacketPlayOutSetSlot(this.windowId, playerSlot.getPacketSlotIndex(), slot2Updated.isEmpty()||slot2Updated.getCount()<1?ItemStack.a:slot2Updated));
+                    }
+                    //OilSpigot end
+                }
+
+            }
+            
+            
+
+
+
+
+
+
+
+
+
+            //##################################################
+            //#################Creatove-Clone###################
+            //##################################################
+            else if (mode == InventoryClickType.CLONE && entityhuman.abilities.canInstantlyBuild && playerinventory.getCarried().isEmpty()) {
+                if (slot.hasItem()) {
+                    if (slot.getItem().getCount() > 0) {
+                        slotItemStack = slotItemStack.cloneItemStack();
+                        slotItemStack.setCount(slotItemStack.getMaxStackSize());
+                        playerinventory.setCarried(slotItemStack);
+                    } else {
+                        slot.setItem(ItemStack.a);
+                    }
+                }
+            }
+
+
+
+
+
+
+
+
+
+
+
+            //##################################################
+            //######################Throw#######################
+            //##################################################
+            else if (mode == InventoryClickType.THROW && playerinventory.getCarried().isEmpty()) {
+                if (droppingAllowed && slot.hasItem() && slot.isAllowed(entityhuman)) {
+                    slotItemStack = slot.splitItemStack(button == 0 ? 1 : slot.getItem().getCount());
+                    update(); //slot
+                    entityhuman.drop(slotItemStack, true);
+                }
+            }
+
+
+
+
+
+
+
+
+
+
+
+            //##################################################
+            //####################Pickup-All####################
+            //##################################################
+            else if (mode == InventoryClickType.PICKUP_ALL) {
+                ItemStack carried = playerinventory.getCarried();
+                if (!carried.isEmpty() && (slot == null || !slot.hasItem() || !slot.isAllowed(entityhuman))) {
+                    k = button == 0 ? 0 : this.slots.size() - 1;
+                    j1 = button == 0 ? 1 : -1;
+
+                    for (int k1 = 0; k1 < 2; ++k1) {
+                        for (int l1 = k; l1 >= 0 && l1 < iSnap.getSize() && carried.getCount() < carried.getMaxStackSize(); l1 += j1) {
+                            ISingleSlot slot3 = iSnap.getSlot(l1);
+
+                            if (slot3.hasItem() && a(slot3, carried, true) && slot3.isAllowed(entityhuman) && (k1 != 0 || slot3.getItem().getCount() != slot3.getItem().getMaxStackSize())) {
+                                int i2 = Math.min(carried.getMaxStackSize() - carried.getCount(), slot3.getItem().getCount());
+                                ItemStack itemstack4 = slot3.splitItemStack(i2);
+
+                                carried.add(i2);
+                                if (itemstack4.getCount() <= 0) {
+                                    slot3.setItem(ItemStack.a);
+                                }
+
+                                update(); //slot3
+                            }
+                        }
+                    }
+                }
+
+                this.b();
+            }
+        }
+
+        return result;
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/inventory/custom/nms/ViewInventory.java b/src/main/java/org/oilmod/spigot/inventory/custom/nms/ViewInventory.java
new file mode 100644
index 00000000..06edd0d3
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/inventory/custom/nms/ViewInventory.java
@@ -0,0 +1,100 @@
+package org.oilmod.spigot.inventory.custom.nms;
+
+import org.oilmod.api.inventory.ModInventoryObjectBase;
+import org.oilmod.spigot.inventory.OilInventoryBase;
+import net.minecraft.server.EntityHuman;
+import net.minecraft.server.ItemStack;
+import net.minecraft.server.PlayerInventory;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
+
+/**
+ * Created by sirati97 on 02.04.2016.
+ */
+public class ViewInventory extends OilInventoryBase<ModInventoryObjectBase> {
+    private final ViewContainer viewContainer;
+
+    public ViewInventory(ViewContainer viewContainer) {
+        super(null, viewContainer.getTitle(), 0, null, null, false);
+        this.viewContainer = viewContainer;
+    }
+
+    @Override
+    public ItemStack getItem(int i) {
+        return viewContainer.getSlot(i).getItem();
+    }
+
+    @Override
+    public void setItem(int i, ItemStack itemstack) {
+        viewContainer.getSlot(i).set(itemstack);
+    }
+
+    public ItemStack splitStack(int i, int j) {
+        ItemStack stack = this.getItem(i);
+        ItemStack result;
+        if (stack.isEmpty()) return ItemStack.a;
+        if (stack.getCount() <= j) {
+            this.setItem(i, ItemStack.a);
+            result = stack;
+        } else {
+            result = CraftItemStack.copyNMSStack(stack, j);
+            stack.subtract(j);
+        }
+        this.update();
+        return result;
+    }
+
+    public ItemStack splitWithoutUpdate(int i) {
+        ItemStack stack = this.getItem(i);
+        ItemStack result;
+        if (stack.isEmpty()) return ItemStack.a;
+        if (stack.getCount() <= 1) {
+            this.setItem(i, ItemStack.a);
+            result = stack;
+        } else {
+            result = CraftItemStack.copyNMSStack(stack, 1);
+            stack.subtract(1);
+        }
+        return result;
+    }
+
+
+    public boolean b(int i, ItemStack itemstack) {
+        return true;
+    }
+
+    @Override
+    public int h() {
+        return 0;
+    }
+
+    @Override
+    public String getContainerLangKey() {
+        return "container.chest";
+    }
+
+    @Override
+    public ViewContainer createContainer(PlayerInventory playerinventory, EntityHuman entityhuman) {
+        return viewContainer;
+    }
+
+    @Override
+    public String getContainerName() {
+        return "minecraft:chest";
+    }
+
+    @Override
+    public int getSize() {
+        return viewContainer.getRows()*9;
+    }
+
+    @Override
+    public int getTotalSize() {
+        return getSize();
+    }
+
+    @Override
+    public void closeContainer(EntityHuman entityHuman) {
+        super.closeContainer(entityHuman);
+        viewContainer.onClose();
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/inventory/custom/slot/IViewSlot.java b/src/main/java/org/oilmod/spigot/inventory/custom/slot/IViewSlot.java
new file mode 100644
index 00000000..f941926c
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/inventory/custom/slot/IViewSlot.java
@@ -0,0 +1,16 @@
+package org.oilmod.spigot.inventory.custom.slot;
+
+import org.oilmod.api.userinterface.internal.NMSUIElement;
+import org.oilmod.spigot.inventory.custom.ClickExtraData;
+import net.minecraft.server.EntityHuman;
+import net.minecraft.server.InventoryClickType;
+import net.minecraft.server.ItemStack;
+
+/**
+ * Created by sirati97 on 17.06.2016 for spigot.
+ */
+public interface IViewSlot extends NMSUIElement {
+    void clickItem(int index, int button, InventoryClickType mode, EntityHuman entityhuman, ClickExtraData data);
+    ItemStack getItem(int index);
+    boolean hasItem(int index);
+}
diff --git a/src/main/java/org/oilmod/spigot/inventory/custom/slot/OilInventoryViewSlot.java b/src/main/java/org/oilmod/spigot/inventory/custom/slot/OilInventoryViewSlot.java
new file mode 100644
index 00000000..714dc767
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/inventory/custom/slot/OilInventoryViewSlot.java
@@ -0,0 +1,47 @@
+package org.oilmod.spigot.inventory.custom.slot;
+
+import org.oilmod.spigot.inventory.OilIInventory;
+import org.oilmod.spigot.inventory.custom.ClickExtraData;
+import net.minecraft.server.EntityHuman;
+import net.minecraft.server.InventoryClickType;
+import net.minecraft.server.ItemStack;
+
+/**
+ * Created by sirati97 on 26.06.2016 for spigot.
+ */
+public class OilInventoryViewSlot extends SettableViewSlotBase {
+    private final OilIInventory inventory;
+
+    public OilInventoryViewSlot(OilIInventory inventory) {
+        this.inventory = inventory;
+    }
+
+    @Override
+    public void setItem(int index, ItemStack itemStack) {
+        inventory.setItem(index, itemStack);
+    }
+
+    @Override
+    public ItemStack getItem(int index) {
+        return inventory.getItem(index);
+    }
+
+    @Override
+    public int getMaxStackSize(int index) {
+        return inventory.getMaxStackSize();
+    }
+
+    @Override
+    public boolean isItemstackAllowed(int index, ItemStack itemStack) {
+        return inventory.itemstackAddable(itemStack);
+    }
+
+    public OilIInventory getInventory() {
+        return inventory;
+    }
+
+    @Override
+    public void clickItem(int index, int button, InventoryClickType mode, EntityHuman entityhuman, ClickExtraData data) {
+        data.setResult(data.getViewContainer().onClickCustom(data.getSingleSlot(), button, mode, entityhuman));
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/inventory/custom/slot/SettableViewSlot.java b/src/main/java/org/oilmod/spigot/inventory/custom/slot/SettableViewSlot.java
new file mode 100644
index 00000000..b4caf950
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/inventory/custom/slot/SettableViewSlot.java
@@ -0,0 +1,17 @@
+package org.oilmod.spigot.inventory.custom.slot;
+
+import org.oilmod.api.userinterface.IInteractableUIElement;
+import net.minecraft.server.EntityHuman;
+import net.minecraft.server.ItemStack;
+
+/**
+ * Created by sirati97 on 14.06.2016 for spigot.
+ */
+public interface SettableViewSlot extends IViewSlot, IInteractableUIElement {
+    void setItem(int index, ItemStack itemStack);
+    boolean isItemstackAllowed(int index, ItemStack itemStack);
+    boolean isHumanAllowed(int index, EntityHuman human);
+    boolean isReadOnly(int index);
+    int getMaxStackSize(int index, ItemStack itemStack);
+    int getMaxStackSize(int index);
+}
diff --git a/src/main/java/org/oilmod/spigot/inventory/custom/slot/SettableViewSlotBase.java b/src/main/java/org/oilmod/spigot/inventory/custom/slot/SettableViewSlotBase.java
new file mode 100644
index 00000000..b8f037c3
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/inventory/custom/slot/SettableViewSlotBase.java
@@ -0,0 +1,53 @@
+package org.oilmod.spigot.inventory.custom.slot;
+
+import org.oilmod.spigot.util.OilSpigotUtil;
+import net.minecraft.server.EntityHuman;
+import net.minecraft.server.ItemStack;
+import org.bukkit.entity.Player;
+import org.oilmod.spigot.util.OilSpigotUtil;
+
+/**
+ * Created by sirati97 on 18.06.2016 for spigot.
+ */
+public abstract class SettableViewSlotBase extends ViewSlotBase implements SettableViewSlot {
+
+    @Override
+    public boolean isItemstackAllowed(int index, ItemStack itemStack) {
+        return true;
+    }
+
+    @Override
+    public boolean isHumanAllowed(int index, EntityHuman human) {
+        return true;
+    }
+
+    @Override
+    public final boolean isItemstackAllowed(int i, org.bukkit.inventory.ItemStack itemStack) {
+        return this.isItemstackAllowed(i, OilSpigotUtil.toNMS(itemStack));
+    }
+
+    @Override
+    public final boolean isPlayerAllowed(int i, Player player) {
+        return this.isHumanAllowed(i, OilSpigotUtil.toNMS(player));
+    }
+
+    @Override
+    public boolean isReadOnly(int index) {
+        return false;
+    }
+
+    @Override
+    public final int getMaxStackSize(int i, org.bukkit.inventory.ItemStack itemStack) {
+        return getMaxStackSize(i, OilSpigotUtil.toNMS(itemStack));
+    }
+
+    @Override
+    public int getMaxStackSize(int index, ItemStack itemStack) {
+        return itemStack==null?getMaxStackSize(index):itemStack.getMaxStackSize();
+    }
+
+    @Override
+    public int getMaxStackSize(int index) {
+        return 64;
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/inventory/custom/slot/ViewSlotBase.java b/src/main/java/org/oilmod/spigot/inventory/custom/slot/ViewSlotBase.java
new file mode 100644
index 00000000..ae874b16
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/inventory/custom/slot/ViewSlotBase.java
@@ -0,0 +1,55 @@
+package org.oilmod.spigot.inventory.custom.slot;
+
+import org.oilmod.api.userinterface.Click;
+import org.oilmod.api.userinterface.internal.NMSClickData;
+import org.oilmod.api.userinterface.internal.NMSUIElement;
+import org.oilmod.spigot.inventory.custom.ClickExtraData;
+import org.oilmod.spigot.util.OilSpigotUtil;
+import net.minecraft.server.EntityHuman;
+import net.minecraft.server.InventoryClickType;
+import org.bukkit.entity.Player;
+import org.oilmod.spigot.util.OilSpigotUtil;
+
+/**
+ * Created by sirati97 on 02.04.2016.
+ */
+public abstract class ViewSlotBase implements IViewSlot{
+    @Override
+    public void clickItem(int index, int button, InventoryClickType mode, EntityHuman entityhuman, ClickExtraData data) {
+    }
+
+
+    @Override
+    public final boolean hasItem(int index) {
+        return this.getItem(index) != null;
+    }
+
+    @Override
+    public final org.bukkit.inventory.ItemStack getDisplayed(int index) {
+        return OilSpigotUtil.toBukkit(getItem(index));
+    }
+
+    @Override
+    public final void setDisplayed(int index, org.bukkit.inventory.ItemStack itemStack) {
+        if (this instanceof SettableViewSlot) {
+            ((SettableViewSlot)this).setItem(index, OilSpigotUtil.toNMS(itemStack));
+        } else {
+            throw new UnsupportedOperationException("The native slot " + getClass().getName() + " does not support setting items");
+        }
+    }
+
+    @Override
+    public final void setNmsWrapper(NMSUIElement nmsWrapper) {
+        throw new UnsupportedOperationException("NMS do not require an wrapper. Plugin should never call this method");
+    }
+
+    @Override
+    public final NMSUIElement getNmsWrapper() {
+        return this;
+    }
+
+    @Override
+    public final void onClick(Player player, int index, Click click, NMSClickData nmsClickData) {
+        clickItem(index, click.getSubType(), OilSpigotUtil.toNMS(click.getType()), OilSpigotUtil.toNMS(player), OilSpigotUtil.toNMS(nmsClickData));
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/inventory/custom/slot/ViewSlotResult.java b/src/main/java/org/oilmod/spigot/inventory/custom/slot/ViewSlotResult.java
new file mode 100644
index 00000000..8418b272
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/inventory/custom/slot/ViewSlotResult.java
@@ -0,0 +1,151 @@
+package org.oilmod.spigot.inventory.custom.slot;
+
+import org.oilmod.api.userinterface.IUIElement;
+import org.oilmod.api.userinterface.UIElementResult;
+import org.oilmod.api.userinterface.internal.NMSUIElement;
+import org.oilmod.spigot.inventory.custom.ISingleSlot;
+import org.oilmod.spigot.util.OilSpigotUtil;
+import net.minecraft.server.EntityHuman;
+import net.minecraft.server.ItemStack;
+import org.oilmod.spigot.util.OilSpigotUtil;
+
+/**
+ * Created by sirati97 on 15.06.2016 for spigot.
+ */
+public class ViewSlotResult implements UIElementResult, ISingleSlot {
+    private final IViewSlot slot;
+    private final IUIElement element;
+    private final int index;
+    private int packetSlotIndex;
+
+    public static ViewSlotResult createInstance(IViewSlot slot, int index) {
+        return slot==null?null:new ViewSlotResult(slot, slot, index);
+    }
+
+    public static ViewSlotResult createOilInstance(IUIElement element, int index) {
+        return element==null?null:new OilViewSlotResult(element, index);
+    }
+
+    private ViewSlotResult(IViewSlot slot, IUIElement element, int index) {
+        if (slot == null || element == null) {
+            throw new IllegalStateException("Do not return result containing null. Instant return null directly.");
+        }
+        this.slot = slot;
+        this.element = element;
+        this.index = index;
+    }
+
+
+    @Override
+    public int getIndex() {
+        return index;
+    }
+
+    @Override
+    public int getPacketSlotIndex() {
+        return packetSlotIndex;
+    }
+
+    public void setPacketSlotIndex(int packetSlotIndex) {
+        this.packetSlotIndex = packetSlotIndex;
+    }
+
+    private SettableViewSlot toSettable() {
+        if (slot instanceof SettableViewSlot) {
+            return (SettableViewSlot) slot;
+        } else {
+            throw new IllegalStateException("This method is only available for SettableViewSlots");
+        }
+    }
+
+    @Override
+    public ItemStack getItem() {
+        return slot.getItem(getIndex());
+    }
+
+    @Override
+    public boolean hasItem() {
+        return slot.hasItem(getIndex());
+    }
+
+    @Override
+    public void setItem(ItemStack itemStack) {
+        toSettable().setItem(getIndex(), itemStack);
+    }
+
+    @Override
+    public boolean isAllowed(ItemStack itemStack) {
+        return toSettable().isItemstackAllowed(getIndex(), itemStack);
+    }
+
+    @Override
+    public boolean isReadOnly() {
+        return toSettable().isReadOnly(getIndex());
+    }
+
+    @Override
+    public boolean isSettable() {
+        return slot instanceof SettableViewSlot;
+    }
+
+    @Override
+    public int getMaxStackSize(ItemStack itemStack) {
+        return toSettable().getMaxStackSize(getIndex(), itemStack);
+    }
+
+    @Override
+    public int getMaxStackSize() {
+        return toSettable().getMaxStackSize(getIndex());
+    }
+
+    @Override
+    public boolean isAllowed(EntityHuman human) {
+        return toSettable().isHumanAllowed(getIndex(), human);
+    }
+
+    @Override
+    public ItemStack splitItemStack(int removed) {
+        ItemStack itemStack = getItem();
+        if (itemStack.isEmpty()) {
+            return ItemStack.a; //TODO: can you use util method
+        } else {
+            return itemStack.cloneAndSubtract(removed); //TODO: check this
+//            if (itemStack.count <= removed) {
+//                setItem(null);
+//                return itemStack;
+//            } else {
+//            }
+        }
+    }
+
+    @Override
+    public NMSUIElement getNMSUIElement() {
+        return slot;
+    }
+
+    @Override
+    public IUIElement getUIElement() {
+        return element;
+    }
+
+    public IViewSlot getSlot() {
+        return slot;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (obj instanceof ViewSlotResult) {
+            ViewSlotResult other = (ViewSlotResult) obj;
+            return slot.equals(other.getSlot()) && getIndex()==other.getIndex();
+        }
+        return super.equals(obj);
+    }
+
+    public static class OilViewSlotResult extends ViewSlotResult {
+
+        private OilViewSlotResult(IUIElement element, int index) {
+            super(OilSpigotUtil.toNMS(element), element, index);
+        }
+    }
+
+}
diff --git a/src/main/java/org/oilmod/spigot/inventory/custom/view/HumanInventorySlotView.java b/src/main/java/org/oilmod/spigot/inventory/custom/view/HumanInventorySlotView.java
new file mode 100644
index 00000000..2596b479
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/inventory/custom/view/HumanInventorySlotView.java
@@ -0,0 +1,99 @@
+package org.oilmod.spigot.inventory.custom.view;
+
+import org.oilmod.spigot.inventory.custom.ClickExtraData;
+import org.oilmod.spigot.inventory.custom.slot.SettableViewSlotBase;
+import org.oilmod.spigot.inventory.custom.slot.ViewSlotResult;
+import net.minecraft.server.EntityHuman;
+import net.minecraft.server.EntityInsentient;
+import net.minecraft.server.EnumItemSlot;
+import net.minecraft.server.InventoryClickType;
+import net.minecraft.server.ItemStack;
+
+/**
+ * Created by sirati97 on 18.06.2016 for spigot.
+ */
+public class HumanInventorySlotView extends SlotViewBase{
+    private static final EnumItemSlot[] ARMOR_SLOTS = new EnumItemSlot[] { EnumItemSlot.HEAD, EnumItemSlot.CHEST, EnumItemSlot.LEGS, EnumItemSlot.FEET};
+    private final int size;
+    private final EntityHuman human;
+    private final HumanInventorySlot slot;
+    private final boolean armor;
+    private final boolean offhand;
+    private final boolean hotbarPosSwitched;
+    private final boolean filterItems;
+
+
+    public HumanInventorySlotView(EntityHuman human, boolean hotbarPosSwitched, boolean armor, boolean offhand, boolean filterItems) {
+        this.size = 36+(armor?4:-0)+(offhand?1:0);
+        this.human = human;
+        this.armor = armor;
+        this.offhand = offhand;
+        this.hotbarPosSwitched = hotbarPosSwitched;
+        this.filterItems = filterItems;
+        this.slot = new HumanInventorySlot();
+    }
+
+    @Override
+    public ViewSlotResult get(int index) {
+        return index<size?ViewSlotResult.createInstance(slot, index):null;
+    }
+
+    @Override
+    public int size() {
+        return size;
+    }
+
+    private class HumanInventorySlot extends SettableViewSlotBase {
+        @Override
+        public void clickItem(int index, int button, InventoryClickType mode, EntityHuman entityhuman, ClickExtraData data) {
+            data.setResult(data.getViewContainer().onClickCustom(data.getSingleSlot(), button, mode, entityhuman));
+        }
+
+        @Override
+        public ItemStack getItem(int index) {
+            if (index < 36) {
+                if (!hotbarPosSwitched) {
+                    return human.inventory.getItem(index);
+                } else if (index < 27) {
+                    return human.inventory.getItem(index+9);
+                } else{
+                    return human.inventory.getItem(index-27);
+                }
+            } else if (armor && index >= 36 && index < 40) {
+                return human.inventory.getItem(75-index);
+            } else if (offhand && index == 36+(armor?4:0)) {
+                return human.inventory.getItem(index+(armor?0:4));
+            } else {
+                System.out.println("should not be called");
+                return ItemStack.a;
+            }
+        }
+
+        @Override
+        public void setItem(int index, ItemStack itemStack) {
+            if (index < 36) {
+                if (!hotbarPosSwitched) {
+                    human.inventory.setItem(index, itemStack);
+                } else if (index < 27) {
+                    human.inventory.setItem(index+9, itemStack);
+                } else {
+                    human.inventory.setItem(index-27, itemStack);
+                }
+            } else if (armor && index >= 36 && index < 40) {
+                human.inventory.setItem(75-index, itemStack);
+            } else if (offhand && index == 36+(armor?4:0)) {
+                human.inventory.setItem(index+(armor?0:4), itemStack);
+            }
+        }
+
+        @Override
+        public boolean isItemstackAllowed(int index, ItemStack itemStack) {
+            if (armor && filterItems && index >= 36 && index < 40 && !itemStack.isEmpty()) {
+                EnumItemSlot itemSlot = EntityInsentient.d(itemStack);
+                return itemSlot == ARMOR_SLOTS[index-36];
+            } else {
+                return true;
+            }
+        }
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/inventory/custom/view/ISlotView.java b/src/main/java/org/oilmod/spigot/inventory/custom/view/ISlotView.java
new file mode 100644
index 00000000..7b273339
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/inventory/custom/view/ISlotView.java
@@ -0,0 +1,13 @@
+package org.oilmod.spigot.inventory.custom.view;
+
+import org.oilmod.api.userinterface.UIPanel;
+import org.oilmod.api.userinterface.internal.NMSPanel;
+import org.oilmod.spigot.inventory.custom.slot.ViewSlotResult;
+
+/**
+ * Created by sirati97 on 02.04.2016.
+ */
+public interface ISlotView extends UIPanel, NMSPanel {
+    ViewSlotResult get(int index);
+    int size();
+}
diff --git a/src/main/java/org/oilmod/spigot/inventory/custom/view/NullSlotView.java b/src/main/java/org/oilmod/spigot/inventory/custom/view/NullSlotView.java
new file mode 100644
index 00000000..3bbc8505
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/inventory/custom/view/NullSlotView.java
@@ -0,0 +1,24 @@
+package org.oilmod.spigot.inventory.custom.view;
+
+import org.oilmod.spigot.inventory.custom.slot.ViewSlotResult;
+
+/**
+ * Created by sirati97 on 14.06.2016 for spigot.
+ */
+public class NullSlotView extends SlotViewBase {
+    private final int size;
+
+    public NullSlotView(int size) {
+        this.size = size;
+    }
+
+    @Override
+    public ViewSlotResult get(int index) {
+        return null;
+    }
+
+    @Override
+    public int size() {
+        return size;
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/inventory/custom/view/ScalableSlotView.java b/src/main/java/org/oilmod/spigot/inventory/custom/view/ScalableSlotView.java
new file mode 100644
index 00000000..cca58d60
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/inventory/custom/view/ScalableSlotView.java
@@ -0,0 +1,33 @@
+package org.oilmod.spigot.inventory.custom.view;
+
+import org.oilmod.spigot.inventory.custom.slot.ViewSlotBase;
+import org.oilmod.spigot.inventory.custom.slot.ViewSlotResult;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+/**
+ * Created by sirati97 on 02.04.2016.
+ */
+public class ScalableSlotView extends SlotViewBase{
+    protected final List<ViewSlotBase> slots;
+
+    public ScalableSlotView(ViewSlotBase... slots) {
+        this.slots = new ArrayList<>(Arrays.asList(slots));
+    }
+
+    public ScalableSlotView() {
+        slots = new ArrayList<>();
+    }
+
+    @Override
+    public ViewSlotResult get(int index) {
+        return size()>index?ViewSlotResult.createInstance(slots.get(index), index):null;
+    }
+
+    @Override
+    public int size() {
+        return slots.size();
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/inventory/custom/view/ScrollableSlotView.java b/src/main/java/org/oilmod/spigot/inventory/custom/view/ScrollableSlotView.java
new file mode 100644
index 00000000..bac85301
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/inventory/custom/view/ScrollableSlotView.java
@@ -0,0 +1,117 @@
+package org.oilmod.spigot.inventory.custom.view;
+
+import org.oilmod.spigot.inventory.custom.ClickExtraData;
+import org.oilmod.spigot.inventory.custom.slot.ViewSlotBase;
+import org.oilmod.spigot.inventory.custom.slot.ViewSlotResult;
+import net.minecraft.server.EntityHuman;
+import net.minecraft.server.InventoryClickType;
+import net.minecraft.server.ItemStack;
+import org.bukkit.Material;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
+import org.bukkit.inventory.meta.SkullMeta;
+
+/**
+ * Created by sirati97 on 02.04.2016.
+ */
+public class ScrollableSlotView extends SlotViewBase {
+    private final int height;
+    private final int width;
+    private final int size;
+    private ISlotView innerView;
+    private int offset = 0;
+    protected final ViewSlotBase[] sidebarSlots;
+
+    public ScrollableSlotView(int height, int width, ISlotView innerView) {
+        if (height < 2) {
+            throw new IllegalArgumentException("height is smaller than 2");
+        }
+        if (width < 2) {
+            throw new IllegalArgumentException("width is smaller than 2");
+        }
+        this.height = height;
+        this.width = width;
+        this.size = width * height;
+        this.innerView = innerView;
+        this.sidebarSlots = new ViewSlotBase[height];
+        initSidebarSlots();
+    }
+
+    protected void initSidebarSlots() {
+        if (height < 4) {
+            sidebarSlots[height-2]= new ViewSlotMove(-1);
+            sidebarSlots[height-1]= new ViewSlotMove(1);
+        } else {
+            sidebarSlots[height-4]= new ViewSlotMove(-3);
+            sidebarSlots[height-3]= new ViewSlotMove(-1);
+            sidebarSlots[height-2]= new ViewSlotMove(1);
+            sidebarSlots[height-1]= new ViewSlotMove(3);
+        }
+    }
+
+    @Override
+    public ViewSlotResult get(int index) {
+        if ((index+1)%width==0) {
+            return ViewSlotResult.createInstance(sidebarSlots[index/width], index);
+        }
+        int realIndex = index - (index / width) + offset * (width - 1);
+        return getInnerView().size() > realIndex ? getInnerView().get(realIndex) : null;
+    }
+
+    @Override
+    public int size() {
+        return size;
+    }
+
+    public int getHeight() {
+        return height;
+    }
+
+    public int getOffset() {
+        return offset;
+    }
+
+    public int getWidth() {
+        return width;
+    }
+
+    public ISlotView getInnerView() {
+        return innerView;
+    }
+
+    public void setInnerView(ISlotView innerView) {
+        this.innerView = innerView;
+    }
+
+    public void move(int i) {
+        offset += i;
+        int rows = getInnerView().size() / (width - 1) + (getInnerView().size() % (width - 1) == 0 ? 0 : 1);
+        offset = offset < 0 ? 0 : (offset > rows - height ? (rows - height <= 0 ? 0 : rows - height) : offset);
+    }
+
+    private class ViewSlotMove extends ViewSlotBase {
+        private final ItemStack item;
+        private final int move;
+
+        public ViewSlotMove(int move) {
+            this.move = move;
+            org.bukkit.inventory.ItemStack bukkitItemStack = new org.bukkit.inventory.ItemStack(Material.SKULL_ITEM, 1, (short) 3);
+            SkullMeta meta = (SkullMeta) bukkitItemStack.getItemMeta();
+            meta.setOwner(move > 0 ? "MHF_ArrowDown" : "MHF_ArrowUp");
+            meta.setDisplayName("rGo " + (move > 0 ? "down" : "up") + " " + Math.abs(move) + "x");
+            bukkitItemStack.setItemMeta(meta);
+            item = CraftItemStack.asNMSCopy(bukkitItemStack);
+        }
+
+        @Override
+        public void clickItem(int index, int button, InventoryClickType mode, EntityHuman entityhuman, ClickExtraData data) {
+            if (mode != InventoryClickType.PICKUP_ALL) {
+                move(move);
+            }
+        }
+
+        @Override
+        public ItemStack getItem(int index) {
+            return item;
+        }
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/inventory/custom/view/SlotView.java b/src/main/java/org/oilmod/spigot/inventory/custom/view/SlotView.java
new file mode 100644
index 00000000..b9f34aa7
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/inventory/custom/view/SlotView.java
@@ -0,0 +1,40 @@
+package org.oilmod.spigot.inventory.custom.view;
+
+import org.oilmod.spigot.inventory.custom.slot.IViewSlot;
+import org.oilmod.spigot.inventory.custom.slot.ViewSlotResult;
+
+/**
+ * Created by sirati97 on 02.04.2016.
+ */
+public class SlotView extends SlotViewBase {
+    private final IViewSlot[] slots;
+
+    private SlotView(int size, IViewSlot[] slots) {
+        if (size != slots.length) {
+            throw new IllegalArgumentException("Slots has wrong length");
+        }
+        this.slots = slots;
+    }
+
+    public SlotView(IViewSlot... slots) {
+        this(slots.length, slots);
+    }
+
+    public SlotView(int size) {
+        this(size, new IViewSlot[size]);
+    }
+
+    @Override
+    public ViewSlotResult get(int index) {
+        return ViewSlotResult.createInstance(slots[index], index); //TODO: not a fan of object creation each time
+    }
+
+    @Override
+    public int size() {
+        return slots.length;
+    }
+
+    public void set(int index, IViewSlot slot) {
+        slots[index]=slot;
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/inventory/custom/view/SlotViewBase.java b/src/main/java/org/oilmod/spigot/inventory/custom/view/SlotViewBase.java
new file mode 100644
index 00000000..b3de652e
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/inventory/custom/view/SlotViewBase.java
@@ -0,0 +1,18 @@
+package org.oilmod.spigot.inventory.custom.view;
+
+import org.oilmod.spigot.inventory.custom.slot.ViewSlotResult;
+
+/**
+ * Created by sirati97 on 14.06.2016 for spigot.
+ */
+public abstract class SlotViewBase implements ISlotView {
+    @Override
+    public boolean hasForm() {
+        return false;
+    }
+
+    @Override
+    public ViewSlotResult getUIElement(int i) {
+        return get(i);
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/inventory/custom/view/SplittedSlotView.java b/src/main/java/org/oilmod/spigot/inventory/custom/view/SplittedSlotView.java
new file mode 100644
index 00000000..21db678c
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/inventory/custom/view/SplittedSlotView.java
@@ -0,0 +1,26 @@
+package org.oilmod.spigot.inventory.custom.view;
+
+import org.oilmod.spigot.inventory.custom.slot.ViewSlotResult;
+
+/**
+ * Created by sirati97 on 02.04.2016.
+ */
+public class SplittedSlotView extends SlotViewBase {
+    private final ISlotView upperView;
+    private final ISlotView lowerView;
+
+    public SplittedSlotView(ISlotView upperView, ISlotView lowerView) {
+        this.upperView = upperView;
+        this.lowerView = lowerView;
+    }
+
+    @Override
+    public ViewSlotResult get(int index) {
+        return upperView.size()<index?upperView.get(index):lowerView.get(index-upperView.size());
+    }
+
+    @Override
+    public int size() {
+        return upperView.size()+lowerView.size();
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/inventory/custom/view/StaticSplittedSlotView.java b/src/main/java/org/oilmod/spigot/inventory/custom/view/StaticSplittedSlotView.java
new file mode 100644
index 00000000..33ccc19f
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/inventory/custom/view/StaticSplittedSlotView.java
@@ -0,0 +1,32 @@
+package org.oilmod.spigot.inventory.custom.view;
+
+import org.oilmod.spigot.inventory.custom.slot.ViewSlotResult;
+
+/**
+ * Created by sirati97 on 02.04.2016.
+ */
+public class StaticSplittedSlotView extends SlotViewBase {
+    private final ISlotView upperView;
+    private final int upperSize;
+    private final ISlotView lowerView;
+    private final int lowerSize;
+    private final int size;
+
+    public StaticSplittedSlotView(ISlotView upperView, int upperSize, ISlotView lowerView, int lowerSize) {
+        this.upperView = upperView;
+        this.upperSize = upperSize;
+        this.lowerView = lowerView;
+        this.lowerSize = lowerSize;
+        this.size = upperSize+lowerSize;
+    }
+
+    @Override
+    public ViewSlotResult get(int index) {
+        return upperSize>index?(upperView==null?null:upperView.get(index)):(lowerView==null?null:lowerView.get(index-upperSize));
+    }
+
+    @Override
+    public int size() {
+        return size;
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/items/ItemStackCreator.java b/src/main/java/org/oilmod/spigot/items/ItemStackCreator.java
new file mode 100644
index 00000000..956bde2f
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/items/ItemStackCreator.java
@@ -0,0 +1,18 @@
+package org.oilmod.spigot.items;
+
+
+import org.oilmod.api.config.Compound;
+import org.oilmod.spigot.config.DeserializationMethod;
+import net.minecraft.server.Item;
+import net.minecraft.server.ItemStack;
+import net.minecraft.server.NBTTagCompound;
+import org.oilmod.spigot.items.itemstackimpl.internal.ModItemStack;
+
+import java.util.Map;
+
+public interface ItemStackCreator {
+    public ItemStack createStack(Compound compound);
+    public ItemStack createStack(Item item, int i, int j, NBTTagCompound tag, Compound mTag);
+    public ModItemStack deserialize(Map<String, Object> args, DeserializationMethod type);
+    public String getInternalName();
+}
diff --git a/src/main/java/org/oilmod/spigot/items/ItemStackRegistry.java b/src/main/java/org/oilmod/spigot/items/ItemStackRegistry.java
new file mode 100644
index 00000000..79a7b7c5
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/items/ItemStackRegistry.java
@@ -0,0 +1,42 @@
+package org.oilmod.spigot.items;
+
+import gnu.trove.map.hash.THashMap;
+
+import java.util.Map;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+public class ItemStackRegistry {
+    public final static Pattern NAME_CHECKER = Pattern.compile("^[a-z0-9_]*$");
+    private static ItemStackRegistry instance= new ItemStackRegistry();
+    private ItemStackRegistry() {}
+
+    public static ItemStackRegistry getInstance() {
+        return instance;
+    }
+
+    private Map<String, ItemStackCreator> register = new THashMap<String, ItemStackCreator>();
+
+    public void register(ItemStackCreator itemStackCreator) {
+        Matcher matcher = NAME_CHECKER.matcher(itemStackCreator.getInternalName());
+        if (matcher.matches()) {
+            register.put(itemStackCreator.getInternalName(), itemStackCreator);
+        } else {
+            throw new IllegalStateException("'"+itemStackCreator.getInternalName()  + "' must only contain letters, numbers and underscores");
+        }
+    }
+
+
+    public void unregister(ItemStackCreator itemStackCreator) {
+        register.remove(itemStackCreator.getInternalName());
+    }
+
+    public ItemStackCreator get(String internalName) {
+        return register.get(internalName);
+    }
+    public boolean exists(String internalName) {
+        return register.containsKey(internalName);
+    }
+
+
+}
\ No newline at end of file
diff --git a/src/main/java/org/oilmod/spigot/items/ItemUtil.java b/src/main/java/org/oilmod/spigot/items/ItemUtil.java
new file mode 100644
index 00000000..3b993472
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/items/ItemUtil.java
@@ -0,0 +1,34 @@
+package org.oilmod.spigot.items;
+
+import net.minecraft.server.EntityPlayer;
+import net.minecraft.server.Item;
+import net.minecraft.server.ItemStack;
+import net.minecraft.server.Items;
+import org.bukkit.craftbukkit.util.CraftMagicNumbers;
+import org.oilmod.api.config.Compound;
+import org.oilmod.api.items.OilItem;
+import org.oilmod.api.items.type.IShears;
+
+public class ItemUtil {
+
+    public static ItemStack createNew(EntityPlayer player,  Item item, int count, int damage) {
+        if (item instanceof RealItem) {
+            return createOil(((RealItem) item).getApiItem(), count, damage);
+        }
+        return new ItemStack(item, count, damage);
+    }
+
+    public static RealItemStack createNBT(RealItem item, Compound compound) {
+        return new RealItemStack(item, compound);
+    }
+
+    public static RealItemStack createOil(OilItem apiItem, int size, int damage) {
+        RealItemStack result = new RealItemStack((RealItem)apiItem.getNmsItem(), size, damage);
+        return result;
+    }
+
+
+    public static boolean isShears(Item item) {
+        return item == Items.SHEARS || (item instanceof RealItem && ((RealItem) item).getApiItem() instanceof IShears);
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/items/RealCraftItemStack.java b/src/main/java/org/oilmod/spigot/items/RealCraftItemStack.java
new file mode 100644
index 00000000..7e1c0f05
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/items/RealCraftItemStack.java
@@ -0,0 +1,94 @@
+package org.oilmod.spigot.items;
+
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
+import org.bukkit.inventory.meta.ItemMeta;
+import org.oilmod.api.items.OilBukkitItemStack;
+import org.oilmod.api.items.OilItemStack;
+import org.oilmod.spigot.config.DeserializationMethod;
+import org.oilmod.spigot.config.yaml.YamlCompound;
+import org.oilmod.spigot.items.itemstackimpl.internal.ModItemStack;
+
+import java.util.LinkedHashMap;
+import java.util.Map;
+
+
+/**
+ * Subclasses need to add the annotation @DelegateDeserialization(ModCraftItemStack.class) or add the method public static [? extends ModCraftItemStack] deserialize(Map<String, Object> args) {...}
+ */
+public class RealCraftItemStack extends CraftItemStack implements OilBukkitItemStack {
+    protected RealCraftItemStack(RealItemStack item) {
+        super(item);
+    }
+
+
+    //TODO: add support for item serialisation
+    /*
+    public Map<String, Object> serialize() {
+        Map<String, Object> result = new LinkedHashMap();
+        result.put("type", this.getType().name());
+        if(this.getDurability() != 0) {
+            result.put("damage", this.getDurability());
+        }
+
+        if(this.getAmount() != 1) {
+            result.put("amount", this.getAmount());
+        }
+
+        ItemMeta meta = this.getItemMeta();
+        if(!Bukkit.getItemFactory().equals(meta, null)) {
+            result.put("meta", meta);
+        }
+        ModItemStack handle = getHandle();
+        YamlCompound compound = new YamlCompound();
+        handle.saveModBaseCompound(compound);
+        result.putAll(compound.getParent().getValues(false));
+        return result;
+    }
+
+    public static RealCraftItemStack deserialize(Map<String, Object> args) {
+        String mType = (String)args.get("mType");
+        ItemStackCreator creator = ItemStackRegistry.getInstance().get(mType);
+        if (creator != null) {
+            RealCraftItemStack itemstack = null;
+            try {
+                itemstack = creator.deserialize(args, DeserializationMethod.Bukkit).asCraftItemStack();
+            } catch (Exception ex) {
+                ex.printStackTrace();
+                System.err.println("Exception thrown while deserializing with ItemStackCreator '" + mType + "'! Cancelling deserialization of ModCraftItemStack! " + ex.toString());
+            }
+            return itemstack;
+        } else {
+            System.err.println("Cannot found ItemStackCreator for " + mType + "! Cancelling deserialization of ModCraftItemStack!");
+            return null;
+        }
+    }*/
+
+    @Override
+    public RealItemStack getHandle() {
+        return (RealItemStack) super.getHandle();
+    }
+
+    @Override
+    public ItemMeta getItemMeta() { //TODO this is probably not going to be needed if we apply mod lore while packet encoding
+        ItemMeta result = super.getItemMeta();
+        if (result != null) {
+            result.setLore(getHandle().getLore());
+        }
+        return result;
+    }
+
+    @Override
+    public boolean setItemMeta(ItemMeta itemMeta) {
+        boolean result = super.setItemMeta(itemMeta);
+        if (result && itemMeta!=null && itemMeta.hasLore()) {
+            getHandle().setLore(itemMeta.getLore());
+        }
+        return result;
+    }
+
+    @Override
+    public OilItemStack getOilItemStack() {
+        return getHandle().getOilItemStack();
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/items/RealItem.java b/src/main/java/org/oilmod/spigot/items/RealItem.java
new file mode 100644
index 00000000..ff9d26d7
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/items/RealItem.java
@@ -0,0 +1,145 @@
+package org.oilmod.spigot.items;
+
+import net.minecraft.server.*;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
+import org.bukkit.craftbukkit.util.CraftMagicNumbers;
+import org.bukkit.entity.LivingEntity;
+import org.oilmod.api.items.ItemInteractionResult;
+import org.oilmod.api.items.NMSItem;
+import org.oilmod.api.items.OilItem;
+import org.oilmod.api.items.type.IDurable;
+import org.oilmod.api.items.type.IToolBlockBreaking;
+import org.oilmod.api.items.type.IVDAdapter;
+import org.oilmod.spigot.block.RealOilBlockState;
+import org.oilmod.spigot.util.OilSpigotUtil;
+
+public class RealItem extends Item implements NMSItem {
+    private final OilItem apiItem;
+    private final MinecraftKey key;
+
+
+    public RealItem(OilItem apiItem) {
+        this.apiItem = apiItem;
+        this.key = (MinecraftKey) apiItem.getOilKey().getNmsKey();
+        c(key.toString()); // set unlocalized name
+        if (apiItem instanceof IDurable) {
+            setMaxDurability(((IDurable) apiItem).getMaxDurability());
+        }
+        maxStackSize = apiItem.getMaxStackSize();
+    }
+
+    public OilItem getApiItem() {
+        return apiItem;
+    }
+
+    //OilAPI
+    public Item getVanillaFakeItem(RealItemStack stack) {
+        //noinspection unchecked
+        return CraftMagicNumbers.getItem(apiItem.getVanillaMaterial(stack.getOilItemStack()));
+    }
+
+    public int getVanillaFakeData(RealItemStack stack) {
+        //noinspection unchecked
+        return apiItem instanceof IVDAdapter ?((IVDAdapter) apiItem).getVanillaData(stack.getOilItemStack()):0;
+    }
+
+    public MinecraftKey getKey() {
+        return key;
+    }
+
+    //NMS
+
+    @Override
+    public float getDestroySpeed(ItemStack itemstack, IBlockData iblockdata) {
+        if (apiItem instanceof IToolBlockBreaking) {
+            return ((IToolBlockBreaking)apiItem).getDestroySpeed(((RealItemStack)itemstack).getOilItemStack(), OilSpigotUtil.toBukkit(iblockdata), iblockdata.getMaterial().getOilBlockType());
+        }
+        return super.getDestroySpeed(itemstack, iblockdata);
+    }
+
+    @Override
+    public boolean canDestroySpecialBlock(IBlockData iblockdata) {
+        if (apiItem instanceof IToolBlockBreaking) {
+            return ((IToolBlockBreaking)apiItem).canHarvestBlock(OilSpigotUtil.toBukkit(iblockdata), iblockdata.getMaterial().getOilBlockType());
+        }
+        return super.canDestroySpecialBlock(iblockdata);
+    }
+
+    @Override
+    public boolean usesDurability() {
+        return super.usesDurability(); //apiItem instanceof IDurable;
+    }
+
+
+    @Override
+    public int c() {
+        return apiItem.getItemEnchantability();
+    }
+
+    //OilSpigot Pail b -> getDisplayName
+    public  final String b(ItemStack itemstack) {return getDisplayName(itemstack);}
+    public String getDisplayName(ItemStack itemstack) {
+        return LocaleI18n.get(this.j(itemstack) + ".name").trim();
+    }
+
+    //OilSpigot Pail g -> getBaseDamage
+    public final float g() {
+        return this.getBaseDamage();
+    }
+    public float getBaseDamage() {
+        return 0;
+    }
+
+    //OilSpigot Pail g -> getSwingSpeed
+    public final int csaf() { //TODO: wrong name
+        return this.getSwingSpeed();
+    }
+    public int getSwingSpeed() {
+        return 0;
+    }
+
+
+    //OilSpigot Pail a -> onItemUseOnBlock
+    @Override
+    public final EnumInteractionResult a(EntityHuman human, World world, BlockPosition pos, EnumHand hand, EnumDirection facing, float hitX, float hitY, float hitZ) {
+        return onItemUseOnBlock(human, world, pos, hand, facing, hitX, hitY, hitZ);
+    }
+
+
+    public EnumInteractionResult onItemUseOnBlock(EntityHuman human, World w, BlockPosition pos, EnumHand hand, EnumDirection facing, float hitX, float hitY, float hitZ) {
+        RealItemStack itemstack = (RealItemStack) human.b(hand);
+        return OilSpigotUtil.toNMS(apiItem.onItemUseOnBlock(itemstack.getOilItemStack(), human.getBukkitEntity(), OilSpigotUtil.toBukkit(w, pos), hand==EnumHand.OFF_HAND, OilSpigotUtil.toBukkit(facing), hitX, hitY, hitZ));
+    }
+
+    //OilSpigot Pail a -> onEntityHit
+    @Override
+    public final boolean a(ItemStack stack, EntityLiving target, EntityLiving attacker) {
+        return onEntityHit(stack, target, attacker);
+    }
+
+    public boolean onEntityHit(ItemStack stack, EntityLiving target, EntityLiving attacker) {
+        return apiItem.onEntityHit(((RealItemStack)stack).getOilItemStack(), (LivingEntity)target.getBukkitEntity(), (LivingEntity)attacker.getBukkitEntity());
+    }
+
+    //OilSpigot Pail a -> onBlockDestroyed
+    @Override
+    public final boolean a(ItemStack stack, World w, IBlockData data, BlockPosition pos, EntityLiving entity) {
+        return onBlockDestroyed(stack, w, data, pos, entity);
+    }
+
+    public boolean onBlockDestroyed(ItemStack stack, World w, IBlockData data, BlockPosition pos, EntityLiving entity) {
+        return apiItem.onBlockDestroyed(((RealItemStack)stack).getOilItemStack(), new RealOilBlockState(data), OilSpigotUtil.toBukkit(w, pos), (LivingEntity)entity.getBukkitEntity());
+    }
+
+    //OilSpigot Pail a -> onItemRightClick
+    public final InteractionResultWrapper<ItemStack> a(World w, EntityHuman human, EnumHand hand) {
+        return onItemRightClick(w, human, hand);
+    }
+
+    public final InteractionResultWrapper<ItemStack> onItemRightClick(World w, EntityHuman human, EnumHand hand) {
+        RealItemStack itemstack = (RealItemStack) human.b(hand);
+        ItemInteractionResult result = apiItem.onItemRightClick(itemstack.getOilItemStack(), w.getWorld(), human.getBukkitEntity(), hand==EnumHand.OFF_HAND);
+
+        return new InteractionResultWrapper<>(OilSpigotUtil.toNMS(result.getInteractionResult()), CraftItemStack.asNMSCopy(result.getItemStack()));
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/items/RealItemClassMap.java b/src/main/java/org/oilmod/spigot/items/RealItemClassMap.java
new file mode 100644
index 00000000..4248eb0e
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/items/RealItemClassMap.java
@@ -0,0 +1,35 @@
+package org.oilmod.spigot.items;
+
+import gnu.trove.map.TMap;
+import gnu.trove.map.hash.THashMap;
+import gnu.trove.set.hash.THashSet;
+import org.oilmod.api.items.OilItem;
+import org.oilmod.api.items.internal.ItemClassMap;
+
+import java.lang.reflect.Array;
+import java.util.Set;
+
+/**
+ * Created by sirati97 on 02.04.2016.
+ */
+public class RealItemClassMap extends ItemClassMap {
+    private TMap<Class<? extends OilItem>,Set<? extends OilItem>> itemClassMap = new THashMap<>();
+
+    @Override
+    public <T extends OilItem> T[] getOilItemsByClass(Class<T> clazz) {
+        Set<T> set = (Set<T>) itemClassMap.get(clazz);
+        return set==null||set.size()==0?array(clazz, 0):set.toArray(array(clazz, set.size()));
+    }
+
+    public <T extends OilItem> void register(T item) {
+        Class<T> clazz = (Class<T>) item.getClass();
+        Set<T> newSet = new THashSet<>();
+        Set<T> set = (Set<T>) itemClassMap.putIfAbsent(clazz, newSet);
+        set = set==null?newSet:set;
+        set.add(item);
+    }
+
+    private <T extends OilItem> T[] array(Class<T> clazz, int capacity) {
+        return (T[]) Array.newInstance(clazz, capacity);
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/items/RealItemFactory.java b/src/main/java/org/oilmod/spigot/items/RealItemFactory.java
new file mode 100644
index 00000000..6fbe1be2
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/items/RealItemFactory.java
@@ -0,0 +1,20 @@
+package org.oilmod.spigot.items;
+
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
+import org.bukkit.entity.Player;
+import org.bukkit.inventory.ItemStack;
+import org.oilmod.api.items.OilItem;
+import org.oilmod.api.items.internal.ItemFactory;
+
+/**
+ * Created by sirati97 on 15.01.2016.
+ */
+public class RealItemFactory extends ItemFactory {
+    @Override
+    public ItemStack createStack(OilItem apiItem, Player player, int count, int damage) {
+        String displayName = apiItem.getDisplayName(player);
+        RealItem modItem = (RealItem) apiItem.getNmsItem();
+        RealItemStack itemStack = ItemUtil.createOil(apiItem, count, damage);
+        return CraftItemStack.asCraftMirror(itemStack);
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/items/RealItemRegistryHelper.java b/src/main/java/org/oilmod/spigot/items/RealItemRegistryHelper.java
new file mode 100644
index 00000000..31bc9347
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/items/RealItemRegistryHelper.java
@@ -0,0 +1,35 @@
+package org.oilmod.spigot.items;
+
+import net.minecraft.server.Item;
+import org.oilmod.api.items.ItemRegistry;
+import org.oilmod.api.items.OilItem;
+import org.oilmod.spigot.inventory.creative.OilCreativeInventory;
+
+/**
+ * Created by sirati97 on 16.01.2016.
+ */
+public class RealItemRegistryHelper extends ItemRegistry.ItemRegistryHelper {
+    private ItemStackRegistry register = ItemStackRegistry.getInstance();
+    private final RealItemClassMap itemClassMap;
+
+    public RealItemRegistryHelper(RealItemClassMap itemClassMap) {
+        this.itemClassMap = itemClassMap;
+    }
+
+    @Override
+    public <T extends OilItem> void register(ItemRegistry itemRegistry, T oilItem) {
+        RealItem item = new RealItem(oilItem);
+        Item.registerItem(Item.getHighestId()+1, item.getKey(), item);
+        setNMSModItem(item, oilItem);
+        itemClassMap.register(oilItem);
+        OilCreativeInventory.instance.addFactories(oilItem.getCreativeItems());
+    }
+
+    @Override
+    public void initRegister(ItemRegistry itemRegistry, InitRegisterCallback initRegisterCallback) {
+        if (register.exists(itemRegistry.getMod().getInternalName()))throw new IllegalStateException("There is already a ItemRegister with the id '" + itemRegistry.getMod().getInternalName() + "'");
+        //ApiItemStackCreator creator = new ApiItemStackCreator(itemRegistry);
+        //register.register(creator);
+        initRegisterCallback.callback(true, null);
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/items/RealItemStack.java b/src/main/java/org/oilmod/spigot/items/RealItemStack.java
new file mode 100644
index 00000000..6e4778ba
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/items/RealItemStack.java
@@ -0,0 +1,317 @@
+package org.oilmod.spigot.items;
+
+import de.sirati97.spigot.optimisation.ItemStackFreeze;
+import net.minecraft.server.*;
+import org.apache.commons.lang3.Validate;
+import org.bukkit.entity.LivingEntity;
+import org.oilmod.api.config.Compound;
+import org.oilmod.api.data.IData;
+import org.oilmod.api.items.NMSItemStack;
+import org.oilmod.api.items.OilItem;
+import org.oilmod.api.items.OilItemStack;
+import org.oilmod.api.items.type.IDurable;
+import org.oilmod.spigot.config.nbttag.NBTCompound;
+
+import java.lang.ref.WeakReference;
+import java.util.Map;
+
+public class RealItemStack extends ItemStack implements NMSItemStack {
+    private WeakReference<RealCraftItemStack> craftItemStack = null;
+    private OilItemStack oilItemStack;
+    private long lastClientUpdate;
+
+    //Constructors
+    public RealItemStack(RealItem item, Compound compound) { //TODO do we really need item here
+        super(compound);
+        initNormal();
+        if (compound.containsKey("mTag") && item != null) {
+            loadModData(compound.getCompound("mTag")); //manual loading required as early attempt is canelled due to not being initalised yet
+        }
+    }
+
+    public RealItemStack(RealItem item, int count, int data, NBTTagCompound tag, Compound mTag) {
+        super(item, count, data, false); //don't convert - this cannot go well as we aren't even initialised properly.  //TODO: add support in future version
+        setTag(tag);
+        initNormal();
+        loadModData(mTag);
+    }
+
+    private RealItemStack(RealItemStack original) {
+        super(original.getItem(), original.getCount(), original.getData(), false);//don't convert - this is a clone anyway
+
+        //NMS clone
+        if (original.getTag() != null) {
+            setTag(original.getTag().g());
+        }
+        this.d(original.D());
+
+        if (original.isDegenerate()) {
+            setDegenerate(true);
+        } else if (original.getOilItemStack() != null) {
+            //init api stack
+
+            initNormal();
+
+            //copy data from api stacks
+            OilItemStack original_OilItemStack = original.getOilItemStack();
+            Map<String, IData<?>> iData = oilItemStack.getRegisteredIData();
+            for (Map.Entry<String, IData<?>> entry:original_OilItemStack.getRegisteredIData().entrySet()) {
+                IData<?> clone = iData.get(entry.getKey());
+                clone.onCloned(entry.getValue());
+            }
+
+            //inform api
+            oilItemStack.onCloned(original_OilItemStack);
+        }
+    }
+
+    public RealItemStack(RealItem item, int count, int data) {
+        super(item, count, data, false);
+        initNormal();
+    }
+
+    public static ItemStack createModdedStack(RealItem item, int count, int data, NBTTagCompound tag, NBTTagCompound oilTag) {
+        if (oilTag.hasKey("mTag")) {
+            return new RealItemStack(item, count, data, tag, new NBTCompound(oilTag.getCompound("mTag")));
+        } else {
+            throw new IllegalStateException("NBT oilTag does not contain mod data!");
+        }
+    }
+
+    private void initNormal() {
+        Validate.isTrue(oilItemStack==null, "Cannot init twice");
+        oilItemStack = getApiItem().createOilStack(this);
+        oilItemStack.init();
+    }
+    //Constructors end
+
+
+
+
+
+    //Getters
+    public RealItem getRealItem() {
+        return (RealItem) super.getItem();
+    }
+
+    @Override
+    public void setItem(Item item) {
+        Validate.isTrue(item instanceof RealItem, "Modded item stacks can only represent modded items!");
+        if (isEmpty() || item != getItem()) {
+            initNormal();
+        }
+        super.setItem(item);
+    }
+
+    public OilItem getApiItem() {
+        return getRealItem().getApiItem();
+    }
+
+    public long getLastClientUpdate() {
+        return lastClientUpdate;
+    }
+    //Getters end
+
+
+
+
+
+    //OilAPI
+
+
+    @Override
+    public OilItemStack getOilItemStack() {
+        return oilItemStack;
+    }
+
+    public OilItem getOilItem() {
+        return oilItemStack.getItem();
+    }
+
+    @Override
+    public org.bukkit.inventory.ItemStack asBukkitItemStack() {
+        return asCraftItemStack();
+    }
+
+
+    @Override
+    public int getDataNMS() {
+        return getData();
+    }
+
+    @Override
+    public void setDataNMS(int data) {
+        setData(data);
+    }
+
+    @Override
+    public String getRenameNMS() {
+        return hasName()?getName():null;
+    }
+
+    //OilAPI end
+
+
+
+
+
+    //NBT
+    @Override
+    public void load(NBTTagCompound nbttagcompound) {
+        super.load(nbttagcompound);
+        Validate.isTrue(super.getItem() instanceof RealItem, "Modded item stacks can only represent modded items!");
+        if (nbttagcompound.hasKeyOfType("mTag", 10)) {
+            loadModData(new NBTCompound(nbttagcompound.getCompound("mTag")));
+        }
+    }
+
+    @Override
+    public void load(Compound compound) {
+        super.load(compound);
+        Validate.isTrue(super.getItem() instanceof RealItem, "Modded item stacks can only represent modded items!");
+        if (oilItemStack != null && compound.containsKey("mTag")) {
+            loadModData(compound.getCompound("mTag"));
+        }
+    }
+
+    @Override
+    public NBTTagCompound save(NBTTagCompound nbttagcompound) {
+        super.save(nbttagcompound);
+        if (isDegenerate())return nbttagcompound;
+        try { //better not crash the entire server
+            saveModBaseCompound(new NBTCompound(nbttagcompound));
+        } catch (Exception ex) {
+            ex.printStackTrace();
+            throw ex;
+        }
+
+        return nbttagcompound;
+    }
+
+    @Override
+    public Compound save(Compound compound) {
+        super.save(compound);
+        if (isDegenerate())return compound;
+        try { //better not crash the entire server
+            saveModBaseCompound(compound);
+        } catch (Exception ex) {
+            ex.printStackTrace();
+            throw ex;
+        }
+        return compound;
+    }
+
+
+    public void saveModBaseCompound(Compound compound) {
+        if (isDegenerate())return;
+        Compound mTag = compound.createCompound();
+        compound.set("mTag", saveModData(mTag));
+    }
+
+    public Compound saveModData(Compound compound) {
+        for (Map.Entry<String, IData<?>> entry:oilItemStack.getRegisteredIData().entrySet()) {
+            entry.getValue().saveTo(compound, entry.getKey());
+        }
+        return compound;
+    }
+
+    public Compound loadModData(Compound compound) {
+        for (Map.Entry<String, IData<?>> entry:oilItemStack.getRegisteredIData().entrySet()) {
+            entry.getValue().loadFrom(compound, entry.getKey());
+        }
+        return compound;
+    }
+
+    //NBT end
+
+
+
+
+
+    //Cloning
+
+    @Override
+    public ItemStack cloneItemStack() {
+        if (isEmpty() || isDegenerate())return ItemStack.a;
+        RealItemStack itemstack = new RealItemStack(this);
+        itemstack.onCloned(this);
+        return itemstack;
+    } //make use thet cloneAndSubtract //wut
+
+    protected void onCloned(RealItemStack original) {}
+    //Cloning end
+
+
+
+
+
+    //CraftBukkit inter-opt
+    public RealCraftItemStack asCraftItemStack() {
+        if (isDegenerate()) return null;
+        if (craftItemStack == null || craftItemStack.get() == null) {
+            craftItemStack = new WeakReference<>(createCraftItemStack());
+        }
+        return craftItemStack.get();
+    }
+
+    public RealCraftItemStack createCraftItemStack() {
+        return new RealCraftItemStack(this);
+    }
+    //CraftBukkit inter-opt end
+
+
+
+
+
+    //Util overrides
+    /*@Override
+    protected void setDegenerate(boolean v) {
+        if (v) {
+            oilItemStack = null;
+            craftItemStack = null;
+        } else if (getItem() instanceof RealItem) {
+            initNormal();
+        }
+        super.setDegenerate(v);
+    }*/
+
+    @Override
+    protected boolean handleDamage(int damage, EntityLiving entityliving) {
+        if (getOilItem() instanceof IDurable) {
+            //noinspection unchecked
+            return ((IDurable) getOilItem()).handleDamage(getOilItemStack(), damage, (LivingEntity) entityliving.getBukkitEntity());
+        }
+        return handleDamageVanilla(damage, entityliving);
+    }
+
+
+    protected boolean handleDamageVanilla(int damage, EntityLiving entityliving) {
+        return super.handleDamage(damage, entityliving);
+    }
+
+    @Override
+    public void damage(int damage, EntityLiving entityliving) {
+        if (getOilItem() instanceof IDurable) {
+            //noinspection unchecked
+            ((IDurable) getOilItem()).damageItem(getOilItemStack(), damage, (LivingEntity) entityliving.getBukkitEntity());
+            return;
+        }
+        damageVanilla(damage, entityliving);
+    }
+
+
+    public void damageVanilla(int damage, EntityLiving entityliving) {
+        super.damage(damage, entityliving);
+    }
+
+    @Override
+    public ItemStackFreeze createFreeze() {
+        return isEmpty()||isDegenerate()? super.createFreeze():new RealItemStackFreeze(getTag(), getRealItem(), getCount(), getData(), lastClientUpdate);
+    }
+
+
+
+    //Util overrides end
+
+
+}
diff --git a/src/main/java/org/oilmod/spigot/items/RealItemStackFreeze.java b/src/main/java/org/oilmod/spigot/items/RealItemStackFreeze.java
new file mode 100644
index 00000000..75c0fd6d
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/items/RealItemStackFreeze.java
@@ -0,0 +1,23 @@
+package org.oilmod.spigot.items;
+
+import de.sirati97.spigot.optimisation.ItemStackFreeze;
+import net.minecraft.server.Item;
+import net.minecraft.server.ItemStack;
+import net.minecraft.server.NBTTagCompound;
+import org.oilmod.spigot.items.itemstackimpl.internal.ModItem;
+import org.oilmod.spigot.items.itemstackimpl.internal.ModItemStack;
+import org.oilmod.spigot.items.itemstackimpl.internal.ModItemStackFreeze;
+
+public class RealItemStackFreeze extends ItemStackFreeze {
+    public final long lastClientUpdate;
+
+    public RealItemStackFreeze(NBTTagCompound tag, RealItem item, int count, int damage, long lastClientUpdate) {
+        super(tag, item, count, damage);
+        this.lastClientUpdate = lastClientUpdate;
+    }
+
+    @Override
+    public boolean fastMatchTo(ItemStack itemstack) {
+        return super.fastMatchTo(itemstack) && itemstack instanceof RealItemStack && lastClientUpdate==((RealItemStack) itemstack).getLastClientUpdate();
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/items/RealItemTypeHelper.java b/src/main/java/org/oilmod/spigot/items/RealItemTypeHelper.java
new file mode 100644
index 00000000..565161a5
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/items/RealItemTypeHelper.java
@@ -0,0 +1,18 @@
+package org.oilmod.spigot.items;
+
+import org.bukkit.craftbukkit.entity.CraftLivingEntity;
+import org.bukkit.entity.LivingEntity;
+import org.oilmod.api.items.OilItemStack;
+import org.oilmod.api.items.type.ItemTypeHelper;
+
+public class RealItemTypeHelper extends ItemTypeHelper {
+    @Override
+    public boolean handleDamage(OilItemStack stack, int damage, LivingEntity entity) {
+        return ((RealItemStack)stack.getNmsItemStack()).handleDamageVanilla(damage, ((CraftLivingEntity)entity).getHandle());
+    }
+
+    @Override
+    public void damageItem(OilItemStack stack, int damage, LivingEntity entity) {
+        ((RealItemStack)stack.getNmsItemStack()).damageVanilla(damage, ((CraftLivingEntity)entity).getHandle());
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/items/RealSpecificItemStackFactory.java b/src/main/java/org/oilmod/spigot/items/RealSpecificItemStackFactory.java
new file mode 100644
index 00000000..93737ad2
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/items/RealSpecificItemStackFactory.java
@@ -0,0 +1,21 @@
+package org.oilmod.spigot.items;
+
+import org.oilmod.api.items.OilItemStackFactory;
+import net.minecraft.server.ItemStack;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
+
+/**
+ * Created by sirati97 on 06.03.2016.
+ */
+public class RealSpecificItemStackFactory implements SpecificItemStackFactory {
+    private final OilItemStackFactory oil;
+
+    public RealSpecificItemStackFactory(OilItemStackFactory oil) {
+        this.oil = oil;
+    }
+
+    @Override
+    public ItemStack create() {
+        return CraftItemStack.asNMSCopy(oil.create());
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/items/SpecificItemStackFactory.java b/src/main/java/org/oilmod/spigot/items/SpecificItemStackFactory.java
new file mode 100644
index 00000000..36bdd729
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/items/SpecificItemStackFactory.java
@@ -0,0 +1,10 @@
+package org.oilmod.spigot.items;
+
+import net.minecraft.server.ItemStack;
+
+/**
+ * Created by sirati97 on 06.03.2016.
+ */
+public interface SpecificItemStackFactory {
+    ItemStack create();
+}
diff --git a/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/BukkitCraftingIngredient.java b/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/BukkitCraftingIngredient.java
new file mode 100644
index 00000000..570aedee
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/BukkitCraftingIngredient.java
@@ -0,0 +1,39 @@
+package org.oilmod.spigot.items.itemstackimpl.crafting;
+
+import org.oilmod.api.items.crafting.DataHolder;
+import org.oilmod.api.items.crafting.OilCraftingIngredient;
+import org.oilmod.spigot.util.OilSpigotUtil;
+import net.minecraft.server.ItemStack;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
+
+import java.util.Random;
+
+/**
+ * Created by sirati97 on 24.03.2016.
+ */
+public class BukkitCraftingIngredient implements NMSCraftingIngredient {
+    private final OilCraftingIngredient oilCraftingIngredient;
+
+    public BukkitCraftingIngredient(OilCraftingIngredient oilCraftingIngredient) {
+        this.oilCraftingIngredient = oilCraftingIngredient;
+    }
+
+    @Override
+    public boolean match(ItemStack itemStack, DataHolder dataHolder) {
+        return oilCraftingIngredient.match(OilSpigotUtil.toBukkit(itemStack), dataHolder);
+    }
+
+    @Override
+    public ItemStack getRandomExample(Random rnd, DataHolder dataHolder) {
+        return CraftItemStack.asNMSCopy(oilCraftingIngredient.getRandomExample(rnd, dataHolder));
+    }
+
+    public ItemStack onCrafted(ItemStack oldItemStack, DataHolder dataHolder) {
+        return CraftItemStack.asNMSCopy(oilCraftingIngredient.onCrafted(OilSpigotUtil.toBukkit(oldItemStack), dataHolder));
+    }
+
+    @Override
+    public boolean matchesNull() {
+        return oilCraftingIngredient.matchesNull();
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/BukkitCraftingResultFactory.java b/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/BukkitCraftingResultFactory.java
new file mode 100644
index 00000000..3c805f4a
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/BukkitCraftingResultFactory.java
@@ -0,0 +1,28 @@
+package org.oilmod.spigot.items.itemstackimpl.crafting;
+
+import net.minecraft.server.NonNullList;
+import org.oilmod.api.items.crafting.OilCraftingResult;
+import net.minecraft.server.ItemStack;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
+
+/**
+ * Created by sirati97 on 24.03.2016.
+ */
+public class BukkitCraftingResultFactory implements NMSCraftingResultFactory {
+    private final OilCraftingResult oilCraftingResult;
+
+    public BukkitCraftingResultFactory(OilCraftingResult oilCraftingResult) {
+        this.oilCraftingResult = oilCraftingResult;
+    }
+
+    @Override
+    public ItemStack preCraftResult(NonNullList<ItemStack> matrix, boolean shaped, int width, int height) {
+        return CraftItemStack.asNMSCopy(oilCraftingResult.preCraftResult(CraftItemStack.asCraftMirrorArray(matrix), shaped, width, height));
+    }
+
+    @Override
+    public void craftResult(ItemStack result, NonNullList<ItemStack> matrix, boolean shaped, int width, int height) {
+        oilCraftingResult.craftResult(CraftItemStack.asCraftMirror(result), CraftItemStack.asCraftMirrorArray(matrix), shaped, width, height);
+
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/ItemStackCraftingInventoryReference.java b/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/ItemStackCraftingInventoryReference.java
new file mode 100644
index 00000000..a76c268c
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/ItemStackCraftingInventoryReference.java
@@ -0,0 +1,27 @@
+package org.oilmod.spigot.items.itemstackimpl.crafting;
+
+import net.minecraft.server.oilmod.IInventoryCrafting;
+import net.minecraft.server.ItemStack;
+
+/**
+ * Created by sirati97 on 03.04.2016.
+ */
+public class ItemStackCraftingInventoryReference {
+    private final int left;
+    private final int top;
+    private final IInventoryCrafting inventory;
+
+    public ItemStackCraftingInventoryReference(int left, int top, IInventoryCrafting inventory) {
+        this.left = left;
+        this.top = top;
+        this.inventory = inventory;
+    }
+
+    public ItemStack get() {
+        return inventory.c(left, top);
+    }
+
+    public void set(ItemStack itemStack, boolean update) {
+        inventory.setItem(left, top, itemStack, update);
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/NMSCraftingIngredient.java b/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/NMSCraftingIngredient.java
new file mode 100644
index 00000000..b3106e41
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/NMSCraftingIngredient.java
@@ -0,0 +1,16 @@
+package org.oilmod.spigot.items.itemstackimpl.crafting;
+
+import org.oilmod.api.items.crafting.DataHolder;
+import net.minecraft.server.ItemStack;
+
+import java.util.Random;
+
+/**
+ * Created by sirati97 on 24.03.2016.
+ */
+public interface NMSCraftingIngredient {
+    boolean match(ItemStack itemStack, DataHolder dataHolder);
+    ItemStack getRandomExample(Random rnd, DataHolder dataHolder);
+    ItemStack onCrafted(ItemStack oldItemStack, DataHolder dataHolder);
+    boolean matchesNull();
+}
diff --git a/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/NMSCraftingResultFactory.java b/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/NMSCraftingResultFactory.java
new file mode 100644
index 00000000..b0bfd03e
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/NMSCraftingResultFactory.java
@@ -0,0 +1,13 @@
+package org.oilmod.spigot.items.itemstackimpl.crafting;
+
+import net.minecraft.server.ItemStack;
+import net.minecraft.server.NonNullList;
+
+/**
+ * Created by sirati97 on 24.03.2016.
+ */
+public interface NMSCraftingResultFactory {
+    ItemStack preCraftResult(NonNullList<ItemStack> matrix, boolean shaped, int width, int height);
+    void craftResult(ItemStack result, NonNullList<ItemStack> matrix, boolean shaped, int width, int height);
+
+}
diff --git a/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/OilRecipe.java b/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/OilRecipe.java
new file mode 100644
index 00000000..6dfd40a2
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/OilRecipe.java
@@ -0,0 +1,128 @@
+package org.oilmod.spigot.items.itemstackimpl.crafting;
+
+import org.apache.commons.lang3.Validate;
+import org.oilmod.api.items.crafting.DataHolder;
+import org.oilmod.spigot.items.itemstackimpl.crafting.help.CHView;
+import net.minecraft.server.EntityHuman;
+import net.minecraft.server.oilmod.IInventoryCrafting;
+import net.minecraft.server.IRecipe;
+import net.minecraft.server.ItemStack;
+import net.minecraft.server.MinecraftKey;
+import net.minecraft.server.NonNullList;
+import net.minecraft.server.RecipeItemStack;
+import org.apache.commons.lang3.NotImplementedException;
+import org.bukkit.inventory.Recipe;
+
+/**
+ * Created by sirati97 on 24.03.2016.
+ */
+public abstract class OilRecipe implements IRecipe {
+    protected final NMSCraftingIngredient[] ingredients;
+    protected final NMSCraftingResultFactory resultItem;
+    private CHView chViews[];
+
+    //OilSpigot start - key and global id
+    // CraftBukkit start
+    private MinecraftKey key; //OilSpigot PAIL public private
+
+    public MinecraftKey getKey() {
+        return key;
+    }
+    // CraftBukkit end
+    private int globalId= -1;
+
+    @Override
+    public int getGlobalId() {
+        return globalId;
+    }
+
+    @Override
+    public boolean isRegistered() {
+        return globalId >= 0;
+    }
+
+    @Override
+    public void registered(MinecraftKey key, int globalId) {
+        Validate.isTrue(!isRegistered(), "Cannot register recipe into global register twice");
+        Validate.isTrue(globalId >= 0, "global id needs to bigger than 0");
+        this.key = key;
+        this.globalId = globalId;
+    }
+    //OilSpigot end
+
+    public OilRecipe(NMSCraftingIngredient[] ingredients, NMSCraftingResultFactory resultItem) {
+        this.ingredients = ingredients;
+        this.resultItem = resultItem;
+    }
+
+
+    //OilSpigot KEEPSYNC ShapedRecipes.b() and ShapelessRecipes.b()
+    public NonNullList<ItemStack> b(IInventoryCrafting inventorycrafting) { //OilSpigot changed from InventoryCrafting to IInventoryCrafting
+        NonNullList nonnulllist = NonNullList.a(inventorycrafting.getSize(), ItemStack.a);
+
+        for (int i = 0; i < nonnulllist.size(); ++i) {
+            ItemStack itemstack = inventorycrafting.getItem(i);
+
+            if (itemstack.getItem().r()) {
+                nonnulllist.set(i, new ItemStack(itemstack.getItem().q()));
+            }
+        }
+
+        return nonnulllist;
+    }
+
+    public abstract void onCrafted(IInventoryCrafting inventoryCrafting, EntityHuman human, ItemStack result);
+
+    @Override
+    public Recipe toBukkitRecipe() {
+        throw throwUnsupported();
+    }
+
+    @Override
+    public ItemStack b() { //TODO: needed for /recipe command
+        throw throwUnsupported();
+    }
+
+    protected final NotImplementedException throwUnsupported() throws NotImplementedException {
+        return new NotImplementedException("This recipe it used as a generic recipe factory. It will create a valid recipe while crafting.");
+    }
+
+    protected final boolean matchIngredient(NMSCraftingIngredient craftingIngredient, DataHolder dataHolder, ItemStack itemStack) {
+        return (craftingIngredient==null&&itemStack.isEmpty())||
+                (craftingIngredient!=null&&     (craftingIngredient.matchesNull() || !itemStack.isEmpty())&&     craftingIngredient.match(itemStack, dataHolder));
+    }
+
+    public NonNullList<RecipeItemStack> getIngredients() {
+        throw throwUnsupported();
+    }
+    public NonNullList<RecipeItemStack> d() {
+        throw throwUnsupported();
+    }
+
+    protected final NonNullList<ItemStack> getIngredientItemStacks(IInventoryCrafting inventoryCrafting) {
+        return refToStack(getIngredientReferences(inventoryCrafting));
+    }
+    protected final NonNullList<ItemStack> refToStack(ItemStackCraftingInventoryReference[] refs) {
+        NonNullList<ItemStack> result = NonNullList.a(refs.length, ItemStack.a);
+        for (int i=0;i<refs.length;i++) {
+            result.set(i, refs[i].get());
+        }
+        return result;
+    }
+
+    protected abstract ItemStackCraftingInventoryReference[] getIngredientReferences(IInventoryCrafting inventoryCrafting);
+
+
+
+    @Override
+    public final CHView[] getCraftingHelps() {
+        return chViews ==null? chViews = createCraftingHelps(): chViews;
+    }
+
+    protected CHView[] createCraftingHelps() {
+        CHView view = createCraftingHelp();
+        return view == null?new CHView[]{}:new CHView[]{view};
+    }
+
+    protected abstract CHView createCraftingHelp();
+}
diff --git a/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/OilShapedRecipe.java b/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/OilShapedRecipe.java
new file mode 100644
index 00000000..e8dba552
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/OilShapedRecipe.java
@@ -0,0 +1,167 @@
+package org.oilmod.spigot.items.itemstackimpl.crafting;
+
+import org.oilmod.api.items.crafting.DataHolder;
+import org.oilmod.spigot.items.itemstackimpl.crafting.help.CHView;
+import org.oilmod.spigot.items.itemstackimpl.crafting.help.OilCHView;
+import org.oilmod.spigot.items.itemstackimpl.crafting.nms.NMS_OilShapedRecipe;
+import net.minecraft.server.EntityHuman;
+import net.minecraft.server.oilmod.IInventoryCrafting;
+import net.minecraft.server.ItemStack;
+import net.minecraft.server.NonNullList;
+import net.minecraft.server.World;
+import org.oilmod.spigot.util.BetterNonNullList;
+
+import java.util.List;
+
+/**
+ * Created by sirati97 on 24.03.2016.
+ */
+public class OilShapedRecipe extends OilRecipe {
+    private final int width;
+    private final int height;
+
+    public OilShapedRecipe(int width, int height, NMSCraftingIngredient[] ingredients, NMSCraftingResultFactory result) {
+        super(ingredients, result);
+        this.width = width;
+        this.height = height;
+    }
+
+
+    //
+    public boolean a(IInventoryCrafting inventoryCrafting, World world) { //OilSpigot changed from InventoryCrafting to IInventoryCrafting
+        for (int i = 0; i <= 3 - this.width; ++i) {
+            for (int j = 0; j <= 3 - this.height; ++j) {
+                if (this.a(inventoryCrafting, i, j, true)) {
+                    return true;
+                }
+
+                if (this.a(inventoryCrafting, i, j, false)) {
+                    return true;
+                }
+            }
+        }
+
+        return false;
+    }
+
+    private boolean a(IInventoryCrafting inventoryCrafting, int i, int j, boolean flag) { //OilSpigot changed from InventoryCrafting to IInventoryCrafting
+        DataHolder dataHolder = new DataHolder();
+        for (int k = 0; k < 3; ++k) {
+            for (int l = 0; l < 3; ++l) {
+                int i1 = k - i;
+                int j1 = l - j;
+                NMSCraftingIngredient craftingIngredient = null;
+
+                if (i1 >= 0 && j1 >= 0 && i1 < this.width && j1 < this.height) {
+                    if (flag) {
+                        craftingIngredient = this.ingredients[this.width - i1 - 1 + j1 * this.width];
+                    } else {
+                        craftingIngredient = this.ingredients[i1 + j1 * this.width];
+                    }
+                }
+
+                ItemStack itemstack1 = inventoryCrafting.c(k, l);
+
+                if (!itemstack1.isEmpty() || craftingIngredient != null) {
+                    if (!matchIngredient(craftingIngredient, dataHolder, itemstack1)) {
+                        return false;
+                    }
+                }
+            }
+        }
+        return true;
+    }
+
+    public ItemStack craftItem(IInventoryCrafting inventoryCrafting) { //OilSpigot changed from InventoryCrafting to IInventoryCrafting
+        NonNullList<ItemStack> ingredients = getIngredientItemStacks(inventoryCrafting);
+        ItemStack result = resultItem.preCraftResult(ingredients, true, width, height);
+        NMS_OilShapedRecipe shapedRecipe = new NMS_OilShapedRecipe(width, height, ingredients, result, this);
+        //TODO: fake recipes dont have key and so on
+        inventoryCrafting.setCurrentRecipe(shapedRecipe); //set bukkit compatible recipe
+        return result;
+    }
+
+    public int a() {
+        return this.width * this.height;
+    }
+
+    @Override
+    public void onCrafted(IInventoryCrafting inventoryCrafting, EntityHuman human, ItemStack result) {
+        ItemStackCraftingInventoryReference[] ingredientReferences = getIngredientReferences(inventoryCrafting);
+        resultItem.craftResult(result, refToStack(ingredientReferences), true, width, height);
+        DataHolder dataHolder = new DataHolder();
+        for (int i=0;i<ingredientReferences.length;i++) {
+            NMSCraftingIngredient ingredient = ingredients[i];
+            if (ingredient != null) {
+                ItemStack oldStack = ingredientReferences[i].get();
+                ItemStack newStack = ingredients[i].onCrafted(oldStack, dataHolder);
+                if (oldStack != newStack) {
+                    ingredientReferences[i].set(newStack, false);
+                }
+            }
+        }
+        inventoryCrafting.updateResult();
+    }
+
+    @Override
+    protected ItemStackCraftingInventoryReference[] getIngredientReferences(IInventoryCrafting inventoryCrafting) {
+        int left = Integer.MAX_VALUE;
+        int top = Integer.MAX_VALUE;
+        for (int i = inventoryCrafting.i()-1/*width*/; i >= 0 ; i--) {
+            for (int j = inventoryCrafting.h()-1/*height*/; j >= 0; j--) {
+                if (inventoryCrafting.c(i, j) != null) {
+                    if (left > i) {
+                        left = i;
+                    }
+                    if (top > j) {
+                        top = j;
+                    }
+                }
+            }
+        }
+        int leftEnd = left + width;
+        int topEnd = top + height;
+        int counter = 0;
+        ItemStackCraftingInventoryReference[] result = new ItemStackCraftingInventoryReference[a()];
+        for (int i = top; i <topEnd; ++i) {
+            for (int j = left; j < leftEnd; ++j) {
+                result[counter++] = new ItemStackCraftingInventoryReference(j, i, inventoryCrafting);
+            }
+        }
+        return result;
+    }
+
+    @Override
+    protected CHView createCraftingHelp() {
+        return new OilShapelessCHView();
+    }
+
+    private class OilShapelessCHView extends OilCHView {
+
+        protected OilShapelessCHView() {
+            super(a());
+        }
+
+        @Override
+        public ItemStack getItemStack(int left, int top) {
+            if (top >= height || left >= width) {
+                return ItemStack.a;
+            }
+            int index = left+top*width;
+            return getItems().get(index);
+        }
+
+        @Override
+        protected void fillIngredients(List<ItemStack> ingredients) {
+            DataHolder dataHolder = new DataHolder();
+            for (NMSCraftingIngredient ingredient:OilShapedRecipe.this.ingredients) {
+                ingredients.add(ingredient==null?ItemStack.a:ingredient.getRandomExample(rnd, dataHolder));
+            }
+        }
+
+        @Override
+        protected ItemStack createResult(BetterNonNullList<ItemStack> ingredients) {
+            return resultItem.preCraftResult(ingredients, true, width, height);
+        }
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/OilShapelessRecipe.java b/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/OilShapelessRecipe.java
new file mode 100644
index 00000000..c956b85c
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/OilShapelessRecipe.java
@@ -0,0 +1,137 @@
+package org.oilmod.spigot.items.itemstackimpl.crafting;
+
+import com.google.common.collect.Lists;
+import org.oilmod.api.items.crafting.DataHolder;
+import org.oilmod.spigot.items.itemstackimpl.crafting.help.CHView;
+import org.oilmod.spigot.items.itemstackimpl.crafting.help.OilCHView;
+import org.oilmod.spigot.items.itemstackimpl.crafting.nms.NMS_OilShapelessRecipe;
+import net.minecraft.server.EntityHuman;
+import net.minecraft.server.oilmod.IInventoryCrafting;
+import net.minecraft.server.ItemStack;
+import net.minecraft.server.NonNullList;
+import net.minecraft.server.World;
+import org.oilmod.spigot.util.BetterNonNullList;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
+/**
+ * Created by sirati97 on 24.03.2016.
+ */
+public class OilShapelessRecipe extends OilRecipe {
+
+    public OilShapelessRecipe(NMSCraftingIngredient[] ingredients, NMSCraftingResultFactory resultItem) {
+        super(ingredients, resultItem);
+    }
+
+    //OilSpigot KEEPSYNC ShapedRecipes.a(SAME PARAM)
+    public boolean a(IInventoryCrafting inventoryCrafting, World world) { //OilSpigot changed from InventoryCrafting to IInventoryCrafting
+        ArrayList<NMSCraftingIngredient> ingredientsRemaining = Lists.newArrayList(this.ingredients);
+        DataHolder dataHolder = new DataHolder();
+
+        for (int i = 0; i < inventoryCrafting.h(); ++i) {
+            for (int j = 0; j < inventoryCrafting.i(); ++j) {
+                ItemStack itemStack = inventoryCrafting.c(j, i);
+
+                if (!itemStack.isEmpty()) {
+                    boolean flag = false;
+                    Iterator<NMSCraftingIngredient> iterator = ingredientsRemaining.iterator();
+
+                    while (iterator.hasNext()) {
+                        NMSCraftingIngredient craftingIngredient = iterator.next();
+                        if (matchIngredient(craftingIngredient, dataHolder, itemStack)) {
+                            flag = true;
+                            ingredientsRemaining.remove(craftingIngredient);
+                            break;
+                        }
+                    }
+
+                    if (!flag) {
+                        return false;
+                    }
+                }
+            }
+        }
+
+        return ingredientsRemaining.isEmpty();
+    }
+
+    public ItemStack craftItem(IInventoryCrafting inventoryCrafting) { //OilSpigot changed from InventoryCrafting to IInventoryCrafting
+        NonNullList<ItemStack> ingredients = getIngredientItemStacks(inventoryCrafting);
+        ItemStack result = resultItem.preCraftResult(ingredients, false, a(), 1);
+        NMS_OilShapelessRecipe shapelessRecipes = new NMS_OilShapelessRecipe(result, ingredients, this);
+        //TODO: fake recipes dont have key and so on
+        inventoryCrafting.setCurrentRecipe(shapelessRecipes); //set bukkit compatible recipe
+        return result;
+    }
+
+    public int a() {
+        return this.ingredients.length;
+    }
+
+    @Override
+    public void onCrafted(IInventoryCrafting inventoryCrafting, EntityHuman human, ItemStack result) {
+        ItemStackCraftingInventoryReference[] ingredientReferences = getIngredientReferences(inventoryCrafting);
+        resultItem.craftResult(result, refToStack(ingredientReferences), false, a(), 1);
+        DataHolder dataHolder = new DataHolder();
+        for (int i=0;i<a();i++) {
+            ItemStack oldStack = ingredientReferences[i].get();
+            ItemStack newStack = ingredients[i].onCrafted(oldStack, dataHolder);
+            if (oldStack != newStack) {
+                ingredientReferences[i].set(newStack, false);
+            }
+        }
+        inventoryCrafting.updateResult();
+    }
+
+    @Override
+    protected ItemStackCraftingInventoryReference[] getIngredientReferences(IInventoryCrafting inventoryCrafting) {
+        ItemStackCraftingInventoryReference[] result = new ItemStackCraftingInventoryReference[this.ingredients.length];
+        int counter = 0;
+        for (int i = 0; i < inventoryCrafting.i(); ++i) {
+            for (int j = 0; j < inventoryCrafting.h(); ++j) {
+                ItemStack itemStack = inventoryCrafting.c(i, j);
+                if (itemStack.isEmpty()) {
+                    result[counter++] = new ItemStackCraftingInventoryReference(i, j, inventoryCrafting);
+                }
+            }
+        }
+        return result;
+    }
+
+    @Override
+    protected CHView createCraftingHelp() {
+        return new OilShapelessCHView();
+    }
+
+    private class OilShapelessCHView extends OilCHView {
+
+        protected OilShapelessCHView() {
+            super(a());
+        }
+
+        @Override
+        public ItemStack getItemStack(int left, int top) {
+            int index = left+top*3;
+            List<ItemStack> items = getItems();
+            if (index>=items.size()) {
+                return ItemStack.a;
+            }
+            return items.get(index);
+        }
+
+        @Override
+        protected void fillIngredients(List<ItemStack> ingredients) {
+            DataHolder dataHolder = new DataHolder();
+            for (NMSCraftingIngredient ingredient:OilShapelessRecipe.this.ingredients) {
+                ingredients.add(ingredient.getRandomExample(rnd, dataHolder));
+            }
+        }
+
+        @Override
+        protected ItemStack createResult(BetterNonNullList<ItemStack> ingredients) {
+            return resultItem.preCraftResult(ingredients, false, a(), 1);
+        }
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/RealItemCraftingFactory.java b/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/RealItemCraftingFactory.java
new file mode 100644
index 00000000..6d021335
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/RealItemCraftingFactory.java
@@ -0,0 +1,50 @@
+package org.oilmod.spigot.items.itemstackimpl.crafting;
+
+import net.minecraft.server.MinecraftKey;
+import org.oilmod.api.items.crafting.OilCraftingIngredient;
+import org.oilmod.api.items.crafting.OilCraftingRecipe;
+import org.oilmod.api.items.crafting.OilCraftingResult;
+import org.oilmod.api.items.internal.ItemCraftingFactory;
+import org.oilmod.api.util.OilKey;
+import net.minecraft.server.CraftingManager;
+import net.minecraft.server.IRecipe;
+
+/**
+ * Created by sirati97 on 24.03.2016.
+ */
+public class RealItemCraftingFactory extends ItemCraftingFactory {
+    @Override
+    public OilCraftingRecipe createShapedRecipe(OilKey key, int width, int height, OilCraftingResult result, OilCraftingIngredient... ingredients) {
+        OilShapedRecipe recipe = new OilShapedRecipe(width, height, toNMSCraftingComparators(ingredients), new BukkitCraftingResultFactory(result));
+        return new OilCraftingRecipe(key, recipe);
+    }
+
+    @Override
+    public OilCraftingRecipe createShapelessRecipe(OilKey key, OilCraftingResult result, OilCraftingIngredient... ingredients) {
+        OilShapelessRecipe recipe = new OilShapelessRecipe(toNMSCraftingComparators(ingredients), new BukkitCraftingResultFactory(result));
+        return new OilCraftingRecipe(key, recipe);
+    }
+
+    @Override
+    public void registerGlobal(OilCraftingRecipe oilCraftingRecipe) {
+        CraftingManager craftingManager = CraftingManager.getInstance();
+        registerNMS(oilCraftingRecipe, craftingManager);
+    }
+
+    private void registerNMS(OilCraftingRecipe oilCraftingRecipe, CraftingManager craftingManager) {
+        craftingManager.a((MinecraftKey) oilCraftingRecipe.getOilKey().getNmsKey(), (IRecipe) oilCraftingRecipe.getNmsRecipe());
+        /*CHView[] views = ((OilRecipe) oilCraftingRecipe.getNmsRecipe()).getCraftingHelps(); - should be done effeciently inside of craftingmanager now
+        for(CHView view:views) {
+            craftingManager.oilChViews.add(view);
+        }
+        //craftingManager.updateChView();*/
+    }
+
+    private NMSCraftingIngredient[] toNMSCraftingComparators(OilCraftingIngredient[] ingredients) {
+        NMSCraftingIngredient[] result = new NMSCraftingIngredient[ingredients.length];
+        for (int i=0;i<ingredients.length;i++) {
+            result[i] = ingredients[i]==null?null:new BukkitCraftingIngredient(ingredients[i]);
+        }
+        return result;
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/CHCollection.java b/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/CHCollection.java
new file mode 100644
index 00000000..b652c27d
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/CHCollection.java
@@ -0,0 +1,25 @@
+package org.oilmod.spigot.items.itemstackimpl.crafting.help;
+
+import net.minecraft.server.CraftingManager;
+import net.minecraft.server.ItemStack;
+
+import java.util.List;
+
+/**
+ * Created by sirati97 on 03.04.2016.
+ */
+public class CHCollection {
+    public final String name;
+    public final String type;
+    public final ItemStack item;
+    public final CraftingManager craftingManager;
+    public final List<CHView> views;
+
+    public CHCollection(String name, String type, ItemStack item, CraftingManager craftingManager, List<CHView> views) {
+        this.name = name;
+        this.type = type;
+        this.item = item;
+        this.craftingManager = craftingManager;
+        this.views = views;
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/CHCommand.java b/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/CHCommand.java
new file mode 100644
index 00000000..64eb8b4a
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/CHCommand.java
@@ -0,0 +1,57 @@
+package org.oilmod.spigot.items.itemstackimpl.crafting.help;
+
+import org.oilmod.spigot.inventory.custom.nms.ViewContainer;
+import net.minecraft.server.CraftingManager;
+import net.minecraft.server.EntityPlayer;
+import net.minecraft.server.IInventory;
+import net.minecraft.server.ItemStack;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+/**
+ * Created by sirati97 on 06.03.2016.
+ */
+public class CHCommand extends Command {
+
+    public CHCommand(String name, String... aliases) { //TODO crafting help is updating non stop
+        super(name, "Shows all crafting recipes", "/"+name, Arrays.asList(aliases));
+        this.setPermission( "oilmod.command.CraftingHelp" );
+    }
+
+    @Override
+    public boolean execute(CommandSender commandSender, String currentAlias, String[] args) {
+        commandSender.sendMessage("debug: was executed");
+        if (commandSender instanceof CraftPlayer) {
+            EntityPlayer player = ((CraftPlayer) commandSender).getHandle();
+            List<CHCollection> collections = new ArrayList<>(CraftingManager.REGISTERED_CRAFTING_MANAGERS.size()*2);
+            for (CraftingManager craftingManager:CraftingManager.REGISTERED_CRAFTING_MANAGERS) {
+                if (craftingManager.vanillaChViews.size() > 0) {
+                    ItemStack item = craftingManager.helpDisplayItem.cloneItemStack();
+                    item.setDisplayName("r"+ craftingManager.name + " - Vanilla and Plugin recipes");
+                    collections.add(new CHCollection(craftingManager.name, "Bukkit", item, craftingManager, craftingManager.vanillaChViews));
+                }
+                if (craftingManager.vanillaSpecialChViews.size() > 0) {
+                    ItemStack item = craftingManager.helpDisplayItem2.cloneItemStack();
+                    item.setDisplayName("r"+ craftingManager.name + " - Special Vanilla recipes");
+                    collections.add(new CHCollection(craftingManager.name, "Minecraft-Special", item, craftingManager, craftingManager.vanillaSpecialChViews));
+                }
+                if (craftingManager.oilChViews.size() > 0) {
+                    ItemStack item = craftingManager.helpDisplayItem.cloneItemStack();
+                    item.setDisplayName("r"+ craftingManager.name + " - OilMod recipes");
+                    collections.add(new CHCollection(craftingManager.name, "OilMod", item, craftingManager, craftingManager.oilChViews));
+                }
+            }
+            ViewContainer container = new CHContainer(player, collections);
+            IInventory inventory = container.getViewInventory();
+            player.openContainer(inventory);
+        } else {
+            commandSender.sendMessage("This command is only for players");
+        }
+        return true;
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/CHContainer.java b/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/CHContainer.java
new file mode 100644
index 00000000..f54606da
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/CHContainer.java
@@ -0,0 +1,24 @@
+package org.oilmod.spigot.items.itemstackimpl.crafting.help;
+
+import org.oilmod.spigot.inventory.custom.view.ISlotView;
+import org.oilmod.spigot.inventory.custom.view.ScrollableSlotView;
+import org.oilmod.spigot.inventory.custom.nms.ViewContainer;
+import net.minecraft.server.EntityHuman;
+
+import java.util.List;
+
+/**
+ * Created by sirati97 on 03.04.2016.
+ */
+public class CHContainer extends ViewContainer {
+
+    public CHContainer(EntityHuman human, List<CHCollection> collections) {
+        super(human, 6, "Crafting Help");
+        CHSelectorSlotView selectorSlotView = new CHSelectorSlotView(this);
+        setSeparatedView(new ScrollableSlotView(6, 9, selectorSlotView), null);
+        ISlotView mainView = getView();
+        for (CHCollection collection:collections) {
+            selectorSlotView.add(new CHDisplaySlotView(this, collection, mainView));
+        }
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/CHDisplaySlotView.java b/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/CHDisplaySlotView.java
new file mode 100644
index 00000000..f36cc304
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/CHDisplaySlotView.java
@@ -0,0 +1,163 @@
+package org.oilmod.spigot.items.itemstackimpl.crafting.help;
+
+import org.oilmod.spigot.inventory.custom.ClickExtraData;
+import org.oilmod.spigot.inventory.custom.view.ISlotView;
+import org.oilmod.spigot.inventory.custom.view.SlotView;
+import org.oilmod.spigot.inventory.custom.slot.ViewSlotBase;
+import net.minecraft.server.Blocks;
+import net.minecraft.server.EntityHuman;
+import net.minecraft.server.InventoryClickType;
+import net.minecraft.server.ItemStack;
+import net.minecraft.server.Items;
+import org.bukkit.Material;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
+import org.bukkit.inventory.meta.SkullMeta;
+
+import java.util.Arrays;
+
+/**
+ * Created by sirati97 on 03.04.2016.
+ */
+public class CHDisplaySlotView extends SlotView {
+    private final CHCollection collection;
+    private final ISlotView lastView;
+    private final CHContainer container;
+    private int index=0;
+
+    public CHDisplaySlotView(CHContainer container, CHCollection collection, ISlotView lastView) {
+        super(90);
+        this.container = container;
+        this.collection = collection;
+        this.lastView = lastView;
+        set(8, new ViewSlotInfo());
+        for (int row=0;row<3;row++) {
+            for (int i=0;i<3;i++) {
+                for (int j=0;j<3;j++) {
+                    set(row*27+i*9+j, new ViewSlotDisplayCHIngredients(j, i, row));
+                }
+            }
+            set(row*27+13, new ViewSlotDisplayCHResult(row));
+        }
+        set(85, new ViewSlotGoBack());
+        set(86, new ViewSlotMove(-5));
+        set(87, new ViewSlotMove(-1));
+        set(88, new ViewSlotMove(1));
+        set(89, new ViewSlotMove(5));
+    }
+
+    public void move(int i) {
+        index += i*3;
+        int cappedSize = (collection.views.size()/3+(collection.views.size()%3==0?0:1))*3;
+        index = index < 0 ? 0 : (index > cappedSize - 3 ? cappedSize - 3 : index);
+    }
+
+    public CHCollection getCollection() {
+        return collection;
+    }
+
+    private class ViewSlotDisplayCHIngredients extends ViewSlotBase {
+        private final int left;
+        private final int top;
+        private final int offset;
+
+        private ViewSlotDisplayCHIngredients(int left, int top, int offset) {
+            this.left = left;
+            this.top = top;
+            this.offset = offset;
+        }
+
+        @Override
+        public ItemStack getItem(int i) {
+            int recipeIndex = index+offset;
+            if (collection.views.size()>recipeIndex) {
+                return collection.views.get(recipeIndex).getItemStack(left, top);
+            }
+            return ItemStack.a;
+        }
+    }
+
+    private class ViewSlotDisplayCHResult extends ViewSlotBase {
+        private final int offset;
+
+        private ViewSlotDisplayCHResult(int offset) {
+            this.offset = offset;
+        }
+
+        @Override
+        public ItemStack getItem(int i) {
+            int recipeIndex = index+offset;
+            if (collection.views.size()>recipeIndex) {
+                return collection.views.get(recipeIndex).getResult();
+            }
+            return ItemStack.a;
+        }
+    }
+
+    private class ViewSlotMove extends ViewSlotBase {
+        private final ItemStack item;
+        private final int move;
+
+        public ViewSlotMove(int move) {
+            this.move = move;
+            org.bukkit.inventory.ItemStack bukkitItemStack = new org.bukkit.inventory.ItemStack(Material.SKULL_ITEM, 1, (short) 3);
+            SkullMeta meta = (SkullMeta) bukkitItemStack.getItemMeta();
+            meta.setOwner(move > 0 ? "MHF_ArrowRight" : "MHF_ArrowLeft");
+            meta.setDisplayName("rGo " + Math.abs(move) + " " + (Math.abs(move)==1?"site":"sites") + " " + (move > 0 ? "left" : "right"));
+            bukkitItemStack.setItemMeta(meta);
+            item = CraftItemStack.asNMSCopy(bukkitItemStack);
+        }
+
+        @Override
+        public void clickItem(int index, int button, InventoryClickType mode, EntityHuman entityhuman, ClickExtraData data) {
+            if (mode != InventoryClickType.PICKUP_ALL) {
+                move(move);
+            }
+        }
+
+        @Override
+        public ItemStack getItem(int index) {
+            return item;
+        }
+    }
+
+    private class ViewSlotInfo extends ViewSlotBase {
+        private final ItemStack itemStack;
+        private int lastIndex = -1;
+        private final String line1;
+        private String line3;
+
+        public ViewSlotInfo() {
+            itemStack = new ItemStack(Items.BOOK);
+            itemStack.setDisplayName("bInformation");
+            line1 = "r7"+collection.name + " - " + collection.type + " recipes!";
+        }
+
+        @Override
+        public ItemStack getItem(int i) {
+            if (lastIndex != index) {
+                line3 = "r7You are looking at recipe " + (index+1) + " to recipe " + (index+3) + ".";
+                itemStack.setLore(Arrays.asList(line1,"",line3));
+            }
+            return itemStack;
+        }
+    }
+
+    private class ViewSlotGoBack extends ViewSlotBase {
+        private final ItemStack itemStack;
+
+        public ViewSlotGoBack() {
+            itemStack = new ItemStack(Blocks.REDSTONE_BLOCK);
+            itemStack.setDisplayName("rGo back");
+        }
+
+        @Override
+        public ItemStack getItem(int index) {
+            return itemStack;
+        }
+
+        @Override
+        public void clickItem(int index, int button, InventoryClickType mode, EntityHuman entityhuman, ClickExtraData data) {
+            container.setView(lastView);
+        }
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/CHSelectorSlotView.java b/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/CHSelectorSlotView.java
new file mode 100644
index 00000000..e26b3cd8
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/CHSelectorSlotView.java
@@ -0,0 +1,34 @@
+package org.oilmod.spigot.items.itemstackimpl.crafting.help;
+
+import org.oilmod.spigot.inventory.custom.ClickExtraData;
+import org.oilmod.spigot.inventory.custom.view.ScalableSlotView;
+import org.oilmod.spigot.inventory.custom.slot.ViewSlotBase;
+import net.minecraft.server.EntityHuman;
+import net.minecraft.server.InventoryClickType;
+import net.minecraft.server.ItemStack;
+
+/**
+ * Created by sirati97 on 03.04.2016.
+ */
+public class CHSelectorSlotView extends ScalableSlotView {
+    private final CHContainer container;
+
+    public CHSelectorSlotView(CHContainer container) {
+        this.container = container;
+    }
+
+
+    public void add(final CHDisplaySlotView view) {
+        slots.add(new ViewSlotBase() {
+            @Override
+            public ItemStack getItem(int index) {
+                return view.getCollection().item;
+            }
+
+            @Override
+            public void clickItem(int index, int button, InventoryClickType mode, EntityHuman entityhuman, ClickExtraData data) {
+                container.setView(view);
+            }
+        });
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/CHView.java b/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/CHView.java
new file mode 100644
index 00000000..53cf5847
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/CHView.java
@@ -0,0 +1,54 @@
+package org.oilmod.spigot.items.itemstackimpl.crafting.help;
+
+import net.minecraft.server.ItemStack;
+import net.minecraft.server.NonNullList;
+import org.oilmod.spigot.util.BetterNonNullList;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Random;
+
+/**
+ * Created by sirati97 on 02.04.2016.
+ */
+public abstract class CHView { //TODO add support for RecipeItemStack
+    private long lastUpdate=0;
+    private int updateDelay=0;
+    private final BetterNonNullList<ItemStack> lastItems;
+    private final List<ItemStack> lastItemsRead;
+
+    public CHView(int size) {
+        this(size, 666);
+    }
+
+    public CHView(int size, int updateDelay) {
+        this.updateDelay = updateDelay;
+        lastItems = new BetterNonNullList<>(ItemStack.a);
+        lastItemsRead = Collections.unmodifiableList(lastItems);
+    }
+
+    public List<ItemStack> getItems() {
+        testUpdate();
+        return lastItemsRead;
+    }
+
+    protected void testUpdate() {
+        if (lastUpdate+updateDelay<System.currentTimeMillis()) {
+            lastUpdate = System.currentTimeMillis();
+            lastItems.clear();
+            update(lastItems);
+        }
+    }
+
+    public abstract ItemStack getItemStack(int left, int top);
+    public abstract ItemStack getResult();
+
+    protected abstract void update(List<ItemStack> result);
+
+    protected static Random rnd = new Random();
+
+    public boolean isSpecialRecipe() {
+        return false;
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/OilCHView.java b/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/OilCHView.java
new file mode 100644
index 00000000..c052f4dc
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/OilCHView.java
@@ -0,0 +1,30 @@
+package org.oilmod.spigot.items.itemstackimpl.crafting.help;
+
+import net.minecraft.server.ItemStack;
+import org.oilmod.spigot.util.BetterNonNullList;
+
+import java.util.List;
+
+/**
+ * Created by sirati97 on 03.04.2016.
+ */
+public abstract class OilCHView extends CHView {
+    private ItemStack result;
+
+    protected OilCHView(int size) {
+        super(size);
+    }
+
+    @Override
+    protected final void update(List<ItemStack> ingredients) {
+        fillIngredients(ingredients);
+        result = createResult((BetterNonNullList<ItemStack>) ingredients);
+    }
+    protected abstract void fillIngredients(List<ItemStack> ingredients);
+    protected abstract ItemStack createResult(BetterNonNullList<ItemStack> ingredients);
+
+    @Override
+    public final ItemStack getResult() {
+        return result;
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/ShapedCHView.java b/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/ShapedCHView.java
new file mode 100644
index 00000000..b7570f8d
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/ShapedCHView.java
@@ -0,0 +1,47 @@
+package org.oilmod.spigot.items.itemstackimpl.crafting.help;
+
+import net.minecraft.server.ItemStack;
+
+import java.util.List;
+
+/**
+ * Created by sirati97 on 13.06.2016 for spigot.
+ */
+public abstract class ShapedCHView extends CHView {
+    private ItemStack result;
+
+    public ShapedCHView(int size) {
+        super(size);
+    }
+
+    public ShapedCHView(int size, int updateDelay) {
+        super(size, updateDelay);
+    }
+
+    @Override
+    public ItemStack getItemStack(int left, int top) {
+        List<ItemStack> items = getItems();
+        return getItemStackShaped(left, top, getHeight(), getWidth(), items);
+    }
+
+    @Override
+    public ItemStack getResult() {
+        return result;
+    }
+
+    public void setResult(ItemStack result) {
+        this.result = result;
+    }
+
+
+    public abstract int getHeight();
+    public abstract int getWidth();
+
+    public static ItemStack getItemStackShaped(int left, int top, int height, int width, List<ItemStack> items) {
+        if (top >= height || left >= width) {
+            return ItemStack.a;
+        }
+        int index = left+top*width;
+        return items.get(index);
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/ShapelessCHView.java b/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/ShapelessCHView.java
new file mode 100644
index 00000000..e559af93
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/ShapelessCHView.java
@@ -0,0 +1,45 @@
+package org.oilmod.spigot.items.itemstackimpl.crafting.help;
+
+import net.minecraft.server.ItemStack;
+
+import java.util.List;
+
+/**
+ * Created by sirati97 on 13.06.2016 for spigot.
+ */
+public abstract class ShapelessCHView extends CHView {
+    private ItemStack result;
+
+    public ShapelessCHView(int size) {
+        super(size);
+    }
+
+    public ShapelessCHView(int size, int updateDelay) {
+        super(size, updateDelay);
+    }
+
+
+    @Override
+    public ItemStack getResult() {
+        return result;
+    }
+
+    public void setResult(ItemStack result) {
+        this.result = result;
+    }
+
+    @Override
+    public ItemStack getItemStack(int left, int top) {
+        List<ItemStack> items = getItems();
+        return getItemStackShapeless(left, top, items);
+    }
+
+    public static ItemStack getItemStackShapeless(int left, int top, List<ItemStack> items) {
+        int index = left+top*3;
+        System.out.println(index);
+        if (index>=items.size()) {
+            return ItemStack.a;
+        }
+        return items.get(index);
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/VanillaArmorDyeChView.java b/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/VanillaArmorDyeChView.java
new file mode 100644
index 00000000..16c454c4
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/VanillaArmorDyeChView.java
@@ -0,0 +1,97 @@
+package org.oilmod.spigot.items.itemstackimpl.crafting.help;
+
+import net.minecraft.server.EntitySheep;
+import net.minecraft.server.EnumColor;
+import net.minecraft.server.Item;
+import net.minecraft.server.ItemArmor;
+import net.minecraft.server.ItemStack;
+import net.minecraft.server.Items;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
+/**
+ * Created by sirati97 on 13.06.2016 for spigot.
+ */
+public class VanillaArmorDyeChView extends ShapelessCHView {
+    private final static ItemArmor[] repairItems;
+
+    static {
+        List<ItemArmor> itemList = new ArrayList<>();
+        Iterator<Item> iterator = Item.REGISTRY.iterator();
+        //noinspection WhileLoopReplaceableByForEach
+        while (iterator.hasNext()) {
+            Item item = iterator.next();
+            if (item instanceof ItemArmor && ((ItemArmor) item).d() == ItemArmor.EnumArmorMaterial.LEATHER) {
+                itemList.add((ItemArmor) item);
+            }
+        }
+        repairItems = itemList.toArray(new ItemArmor[itemList.size()]);
+    }
+
+    public VanillaArmorDyeChView() {
+        super(9);
+    }
+
+    @Override
+    protected void update(List<ItemStack> result) {
+        EnumColor[] allColors = EnumColor.values();
+        EnumColor[] usedColors = new EnumColor[rnd.nextInt(8)+1];
+        for (int i = 0; i < usedColors.length; i++) {
+            usedColors[i] = allColors[rnd.nextInt(allColors.length)];
+        }
+        ItemArmor itemarmor = repairItems[rnd.nextInt(repairItems.length)];
+        ItemStack armor = new ItemStack(itemarmor);
+        result.add(armor);
+        for (EnumColor color:usedColors) {
+            result.add(new ItemStack(Items.DYE, 1, color.getInvColorIndex()));
+        }
+        setResult(color(armor, itemarmor, usedColors));
+    }
+
+
+    private ItemStack color(ItemStack uncolored, ItemArmor itemarmor, EnumColor[] colors) {
+        ItemStack result = uncolored.cloneItemStack();
+        int[] a = new int[3];
+        int i = 0;
+        int j = 0;
+        int k;
+        int l;
+        float f;
+        float f1;
+        int i1;
+
+        for(EnumColor color:colors) {
+            float[] afloat = EntitySheep.getFloatColor(color);
+            int j1 = (int) (afloat[0] * 255.0F);
+            int k1 = (int) (afloat[1] * 255.0F);
+
+            i1 = (int) (afloat[2] * 255.0F);
+            i += Math.max(j1, Math.max(k1, i1));
+            a[0] += j1;
+            a[1] += k1;
+            a[2] += i1;
+            ++j;
+        }
+
+        k = a[0] / j;
+        int l1 = a[1] / j;
+
+        l = a[2] / j;
+        f = (float) i / (float) j;
+        f1 = (float) Math.max(k, Math.max(l1, l));
+        k = (int) ((float) k * f / f1);
+        l1 = (int) ((float) l1 * f / f1);
+        l = (int) ((float) l * f / f1);
+        i1 = (k << 8) + l1;
+        i1 = (i1 << 8) + l;
+        itemarmor.a(result, i1);
+        return result;
+    }
+
+    @Override
+    public boolean isSpecialRecipe() {
+        return true;
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/VanillaBannerAddCHView.java b/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/VanillaBannerAddCHView.java
new file mode 100644
index 00000000..6355f3e6
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/VanillaBannerAddCHView.java
@@ -0,0 +1,129 @@
+package org.oilmod.spigot.items.itemstackimpl.crafting.help;
+
+import net.minecraft.server.*;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Created by sirati97 on 13.06.2016 for spigot.
+ */
+public class VanillaBannerAddCHView extends CHView {
+    private final static EnumBannerPatternType[] PATTERN_TYPES;
+    private ItemStack result = null;
+    private boolean shaped = false;
+    private int height;
+    private int width;
+
+    static {
+        List<EnumBannerPatternType> patternList = new ArrayList<>();
+        for(EnumBannerPatternType patternType:EnumBannerPatternType.values()) {
+            if (patternType.d()) {
+                patternList.add(patternType);
+            }
+            if (patternType.e()) {
+                patternList.add(patternType);
+            }
+        }
+        PATTERN_TYPES = patternList.toArray(new EnumBannerPatternType[patternList.size()]);
+    }
+
+    public VanillaBannerAddCHView() {
+        super(9);
+    }
+
+
+    @Override
+    public ItemStack getItemStack(int left, int top) {
+        List<ItemStack> items = getItems();
+        if (shaped) {
+            return ShapedCHView.getItemStackShaped(left, top, height, width, items);
+        } else {
+            return ShapelessCHView.getItemStackShapeless(left, top, items);
+        }
+    }
+
+    @Override
+    public ItemStack getResult() {
+        return result;
+    }
+
+    @Override
+    protected void update(List<ItemStack> result) {
+        EnumBannerPatternType patternType = PATTERN_TYPES[rnd.nextInt(PATTERN_TYPES.length)];
+        EnumColor[] colors = EnumColor.values();
+        EnumColor colorBanner = colors[rnd.nextInt(colors.length)];
+        EnumColor colorFeature = colors[rnd.nextInt(colors.length)];
+        ItemStack banner = new ItemStack(Items.BANNER, 1, colorBanner.getInvColorIndex());
+        ItemStack color = new  ItemStack(Items.DYE, 1, colorFeature.getInvColorIndex());
+        if (patternType.e()) {
+            boolean colored = rnd.nextBoolean();
+            shaped = false;
+            height=1;
+            width=colored?3:2;
+            if (colored) {
+                result.add(color);
+            } else {
+                colorFeature = EnumColor.BLACK;
+            }
+            result.add(patternType.f());
+            result.add(banner);
+        } else {
+            shaped = true;
+            height=3;
+            width=3;
+            byte[] slots = new byte[9];
+            byte[] freeSlots = new byte[9];
+            byte index = 0;
+            byte freeSlotsCount = 0;
+
+            for (String line:patternType.c()) {
+                for (char c:line.toCharArray()) {
+                    if (c == ' ') {
+                        freeSlots[freeSlotsCount++] = index;
+                    } else {
+                        slots[index] = 1;
+                    }
+                    index++;
+                }
+            }
+            slots[freeSlots[rnd.nextInt(freeSlotsCount)]] = 2; //banner position
+
+            for (byte type:slots) {
+                if (type == 1) {
+                    result.add(color);
+                } else if (type == 2) {
+                    result.add(banner);
+                } else {
+                    result.add(ItemStack.a);
+                }
+            }
+        }
+        this.result = addPatternToBannerWithClone(banner, patternType, colorFeature);
+    }
+
+    public static ItemStack addPatternToBannerWithClone(ItemStack banner, EnumBannerPatternType patternType, EnumColor color) {
+        ItemStack result = banner.cloneItemStack();
+        NBTTagCompound blockEntityTag = result.c("BlockEntityTag");
+        NBTTagList patternList;
+
+        if (blockEntityTag.hasKeyOfType("Patterns", 9)) {
+            patternList = blockEntityTag.getList("Patterns", 10);
+        } else {
+            patternList = new NBTTagList();
+            blockEntityTag.set("Patterns", patternList);
+        }
+
+        NBTTagCompound newPattern = new NBTTagCompound();
+
+        newPattern.setString("Pattern", patternType.b());
+        newPattern.setInt("Color", color.getInvColorIndex());
+        patternList.add(newPattern);
+        return result;
+    }
+
+    @Override
+    public boolean isSpecialRecipe() {
+        return true;
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/VanillaBannerDuplicateCHView.java b/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/VanillaBannerDuplicateCHView.java
new file mode 100644
index 00000000..caa8c5b1
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/VanillaBannerDuplicateCHView.java
@@ -0,0 +1,62 @@
+package org.oilmod.spigot.items.itemstackimpl.crafting.help;
+
+import net.minecraft.server.EnumBannerPatternType;
+import net.minecraft.server.EnumColor;
+import net.minecraft.server.ItemStack;
+import net.minecraft.server.Items;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Created by sirati97 on 13.06.2016 for spigot.
+ */
+public class VanillaBannerDuplicateCHView extends CHView {
+    public final static EnumBannerPatternType[] PATTERN_TYPES;
+    private ItemStack result = null;
+
+    static {
+        List<EnumBannerPatternType> patternList = new ArrayList<>();
+        for(EnumBannerPatternType patternType:EnumBannerPatternType.values()) {
+            if (patternType.d()) {
+                patternList.add(patternType);
+            }
+        }
+        PATTERN_TYPES = patternList.toArray(new EnumBannerPatternType[patternList.size()]);
+    }
+
+    public VanillaBannerDuplicateCHView() {
+        super(9);
+    }
+
+
+    @Override
+    public ItemStack getItemStack(int left, int top) {
+        return ShapelessCHView.getItemStackShapeless(left, top,  getItems());
+    }
+
+    @Override
+    public ItemStack getResult() {
+        return result;
+    }
+
+    @Override
+    protected void update(List<ItemStack> result) {
+        EnumBannerPatternType patternType = PATTERN_TYPES[rnd.nextInt(PATTERN_TYPES.length)];
+        EnumColor[] colors = EnumColor.values();
+        EnumColor colorBanner = colors[rnd.nextInt(colors.length)];
+        EnumColor colorFeature = colors[rnd.nextInt(colors.length)];
+        ItemStack banner1 = new ItemStack(Items.BANNER, 1, colorBanner.getInvColorIndex());
+        ItemStack banner2 = VanillaBannerAddCHView.addPatternToBannerWithClone(banner1, patternType, colorFeature);
+
+        result.add(banner2);
+        result.add(banner1);
+        this.result = banner2;
+
+    }
+
+    @Override
+    public boolean isSpecialRecipe() {
+        return true;
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/VanillaCHView.java b/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/VanillaCHView.java
new file mode 100644
index 00000000..0633f70f
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/VanillaCHView.java
@@ -0,0 +1,55 @@
+package org.oilmod.spigot.items.itemstackimpl.crafting.help;
+
+
+import net.minecraft.server.*;
+
+import java.util.List;
+
+/**
+ * Created by sirati97 on 02.04.2016.
+ */
+public abstract class VanillaCHView extends CHView {
+    private final IRecipe recipe;
+
+    protected VanillaCHView(int size, IRecipe recipe) {
+        super(size);
+        this.recipe = recipe;
+    }
+
+    public IRecipe getRecipe() {
+        return recipe;
+    }
+
+    @Override
+    public ItemStack getResult() {
+        return recipe.b();
+    }
+
+    protected ItemStack nextItemStack(ItemStack ingredient) {
+        if (ingredient.isEmpty()) {
+            return ItemStack.a;
+        }
+        if (ingredient.getData()==32767) {
+            Item item = ingredient.getItem();
+            int newData = 0;
+            if (item instanceof ItemBlock) {
+                Block block = ((ItemBlock) item).getBlock();
+                BlockStateList stateList = block.s();
+                newData = block.getDropData(stateList.a().get(rnd.nextInt(stateList.a().size())));
+            }
+            ItemStack result = ingredient.cloneItemStack();
+            result.setData(newData);
+            return result;
+        } else {
+            return ingredient;
+        }
+
+    }
+
+    @Override
+    protected void update(List<ItemStack> result) {
+        for (RecipeItemStack itemStack:getRecipe().d()) {
+            result.add(nextItemStack(itemStack.choices.length == 0?ItemStack.a:itemStack.choices[rnd.nextInt(itemStack.choices.length)]));
+        }
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/VanillaFireworksCHView.java b/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/VanillaFireworksCHView.java
new file mode 100644
index 00000000..6a16db93
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/VanillaFireworksCHView.java
@@ -0,0 +1,26 @@
+package org.oilmod.spigot.items.itemstackimpl.crafting.help;
+
+import net.minecraft.server.ItemStack;
+
+import java.util.List;
+
+/**
+ * Created by sirati97 on 13.06.2016 for spigot.
+ */
+public class VanillaFireworksCHView extends ShapelessCHView {
+
+
+    public VanillaFireworksCHView() {
+        super(9);
+    }
+
+    @Override
+    protected void update(List<ItemStack> result) {
+
+    }
+
+    @Override
+    public boolean isSpecialRecipe() {
+        return true;
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/VanillaRepairCHView.java b/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/VanillaRepairCHView.java
new file mode 100644
index 00000000..b4ff5606
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/VanillaRepairCHView.java
@@ -0,0 +1,54 @@
+package org.oilmod.spigot.items.itemstackimpl.crafting.help;
+
+import net.minecraft.server.Item;
+import net.minecraft.server.ItemStack;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
+/**
+ * Created by sirati97 on 13.06.2016 for spigot.
+ */
+public class VanillaRepairCHView extends ShapelessCHView{
+    private final static Item[] repairItems;
+
+    static {
+        List<Item> itemList = new ArrayList<>();
+        Iterator<Item> iterator = Item.REGISTRY.iterator();
+        //noinspection WhileLoopReplaceableByForEach
+        while (iterator.hasNext()) {
+            Item item = iterator.next();
+            if (item.usesDurability()) {
+                itemList.add(item);
+            }
+        }
+        repairItems = itemList.toArray(new Item[itemList.size()]);
+    }
+
+    public VanillaRepairCHView() {
+        super(2);
+    }
+
+    @Override
+    protected void update(List<ItemStack> result) {
+        Item item = repairItems[rnd.nextInt(repairItems.length)];
+        ItemStack itemStack1 = new ItemStack(item, 1, rnd.nextInt(item.getMaxDurability()));
+        ItemStack itemStack2 = new ItemStack(item, 1, rnd.nextInt(item.getMaxDurability()/2));
+        int j = item.getMaxDurability() - itemStack1.i(); //get damage
+        int k = item.getMaxDurability() - itemStack2.i();
+        int l = j + k + item.getMaxDurability() * 5 / 100;
+        int i1 = item.getMaxDurability() - l;
+        if (i1 < 0) {
+            i1 = 0;
+        }
+        result.add(itemStack1);
+        result.add(itemStack2);
+        setResult(new ItemStack(item, 1, i1));
+    }
+
+    @Override
+    public boolean isSpecialRecipe() {
+        return true;
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/VanillaShapedCHView.java b/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/VanillaShapedCHView.java
new file mode 100644
index 00000000..c484ab09
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/VanillaShapedCHView.java
@@ -0,0 +1,24 @@
+package org.oilmod.spigot.items.itemstackimpl.crafting.help;
+
+import net.minecraft.server.ItemStack;
+import net.minecraft.server.ShapedRecipes;
+
+/**
+ * Created by sirati97 on 02.04.2016.
+ */
+public class VanillaShapedCHView extends VanillaCHView {
+
+    public VanillaShapedCHView(ShapedRecipes recipe) {
+        super(recipe.getSize(), recipe);
+    }
+
+    @Override
+    public ShapedRecipes getRecipe() {
+        return (ShapedRecipes) super.getRecipe();
+    }
+
+    @Override
+    public ItemStack getItemStack(int left, int top) {
+        return ShapedCHView.getItemStackShaped(left, top, getRecipe().getHeight(), getRecipe().getWidth(),  getItems());
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/VanillaShapelessCHView.java b/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/VanillaShapelessCHView.java
new file mode 100644
index 00000000..b2ff41e3
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/VanillaShapelessCHView.java
@@ -0,0 +1,24 @@
+package org.oilmod.spigot.items.itemstackimpl.crafting.help;
+
+import net.minecraft.server.ItemStack;
+import net.minecraft.server.ShapelessRecipes;
+
+/**
+ * Created by sirati97 on 02.04.2016.
+ */
+public class VanillaShapelessCHView extends VanillaCHView {
+
+    public VanillaShapelessCHView(ShapelessRecipes recipe) {
+        super(recipe.getSize(), recipe);
+    }
+
+    @Override
+    public ShapelessRecipes getRecipe() {
+        return (ShapelessRecipes) super.getRecipe();
+    }
+
+    @Override
+    public ItemStack getItemStack(int left, int top) {
+        return ShapelessCHView.getItemStackShapeless(left, top,  getItems());
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/VanillaShieldBannerCHView.java b/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/VanillaShieldBannerCHView.java
new file mode 100644
index 00000000..955845ab
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/VanillaShieldBannerCHView.java
@@ -0,0 +1,51 @@
+package org.oilmod.spigot.items.itemstackimpl.crafting.help;
+
+import net.minecraft.server.*;
+
+import java.util.List;
+
+import static org.oilmod.spigot.items.itemstackimpl.crafting.help.VanillaBannerAddCHView.addPatternToBannerWithClone;
+
+/**
+ * Created by sirati97 on 13.06.2016 for spigot.
+ */
+public class VanillaShieldBannerCHView extends ShapelessCHView {
+
+    public VanillaShieldBannerCHView() {
+        super(2);
+    }
+
+    @Override
+    protected void update(List<ItemStack> result) {
+        EnumBannerPatternType patternType = VanillaBannerDuplicateCHView.PATTERN_TYPES[rnd.nextInt(VanillaBannerDuplicateCHView.PATTERN_TYPES.length)];
+        EnumColor[] colors = EnumColor.values();
+        EnumColor colorBanner = colors[rnd.nextInt(colors.length)];
+        EnumColor colorFeature = colors[rnd.nextInt(colors.length)];
+        ItemStack shield = new ItemStack(Items.SHIELD);
+        ItemStack banner = new ItemStack(Items.BANNER, 1, colorBanner.getInvColorIndex());
+        banner = addPatternToBannerWithClone(banner, patternType, colorFeature);
+
+        result.add(shield);
+        result.add(banner);
+
+
+        ItemStack resultStack = new ItemStack(Items.SHIELD);
+
+        NBTTagCompound nbttagcompound;
+        if (banner.hasTag()) {
+            //noinspection ConstantConditions
+            nbttagcompound = banner.getTag().g();
+        } else {
+            nbttagcompound = new NBTTagCompound();
+        }
+
+        resultStack.setTag(nbttagcompound);
+        TileEntityBanner.setBaseColor(resultStack, colorBanner);
+        setResult(resultStack);
+    }
+
+    @Override
+    public boolean isSpecialRecipe() {
+        return true;
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/VanillaTippedArrowCHView.java b/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/VanillaTippedArrowCHView.java
new file mode 100644
index 00000000..071fdbd5
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/help/VanillaTippedArrowCHView.java
@@ -0,0 +1,62 @@
+package org.oilmod.spigot.items.itemstackimpl.crafting.help;
+
+import net.minecraft.server.ItemStack;
+import net.minecraft.server.Items;
+import net.minecraft.server.PotionRegistry;
+import net.minecraft.server.PotionUtil;
+import net.minecraft.server.Potions;
+
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Set;
+
+/**
+ * Created by sirati97 on 13.06.2016 for spigot.
+ */
+public class VanillaTippedArrowCHView extends ShapedCHView {
+    private static final PotionRegistry[] potions;
+    private static final ItemStack arrow = new ItemStack(Items.ARROW);
+
+    static {
+        Set<PotionRegistry> potionSet= new HashSet<>();
+        Iterator<PotionRegistry> iterator = PotionRegistry.a.iterator();
+        //noinspection WhileLoopReplaceableByForEach
+        while (iterator.hasNext()) {
+            PotionRegistry potion = iterator.next();
+            potionSet.add(potion);
+        }
+        potionSet.remove(Potions.EMPTY);
+        potions = potionSet.toArray(new PotionRegistry[potionSet.size()]);
+    }
+
+    public VanillaTippedArrowCHView() {
+        super(9);
+    }
+
+    @Override
+    public int getHeight() {
+        return 3;
+    }
+
+    @Override
+    public int getWidth() {
+        return 3;
+    }
+
+    @Override
+    protected void update(List<ItemStack> result) {
+        PotionRegistry potion = potions[rnd.nextInt(potions.length)];
+        ItemStack lingeringPotion = PotionUtil.a(new ItemStack(Items.LINGERING_POTION), potion);
+        for (int i = 0; i < 8; i++) {
+            result.add(arrow);
+        }
+        result.add(4, lingeringPotion);
+        setResult(PotionUtil.a(new ItemStack(Items.TIPPED_ARROW, 8), potion));
+    }
+
+    @Override
+    public boolean isSpecialRecipe() {
+        return true;
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/nms/NMS_OilRecipe.java b/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/nms/NMS_OilRecipe.java
new file mode 100644
index 00000000..c6c1177a
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/nms/NMS_OilRecipe.java
@@ -0,0 +1,11 @@
+package org.oilmod.spigot.items.itemstackimpl.crafting.nms;
+
+import org.oilmod.spigot.items.itemstackimpl.crafting.OilRecipe;
+import net.minecraft.server.IRecipe;
+
+/**
+ * Created by sirati97 on 28.03.2016.
+ */
+public interface NMS_OilRecipe extends IRecipe {
+    OilRecipe getOilRecipe();
+}
diff --git a/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/nms/NMS_OilShapedRecipe.java b/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/nms/NMS_OilShapedRecipe.java
new file mode 100644
index 00000000..f08c6139
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/nms/NMS_OilShapedRecipe.java
@@ -0,0 +1,24 @@
+package org.oilmod.spigot.items.itemstackimpl.crafting.nms;
+
+import org.oilmod.spigot.items.itemstackimpl.crafting.OilRecipe;
+import org.oilmod.spigot.items.itemstackimpl.crafting.OilShapedRecipe;
+import net.minecraft.server.ItemStack;
+import net.minecraft.server.NonNullList;
+import net.minecraft.server.ShapedRecipes;
+
+/**
+ * Created by sirati97 on 28.03.2016.
+ */
+public class NMS_OilShapedRecipe extends ShapedRecipes implements NMS_OilRecipe {
+    private final OilRecipe oilRecipe;
+
+    public NMS_OilShapedRecipe(int i, int j, NonNullList<ItemStack> aitemstack, ItemStack itemstack, OilShapedRecipe oilRecipe) {
+        super(null, i, j, NMS_OilShapelessRecipe.convert(aitemstack), itemstack); //TODO set first arg and deal with key
+        this.oilRecipe = oilRecipe;
+    }
+
+    @Override
+    public OilRecipe getOilRecipe() {
+        return oilRecipe;
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/nms/NMS_OilShapelessRecipe.java b/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/nms/NMS_OilShapelessRecipe.java
new file mode 100644
index 00000000..c4ff0305
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/items/itemstackimpl/crafting/nms/NMS_OilShapelessRecipe.java
@@ -0,0 +1,33 @@
+package org.oilmod.spigot.items.itemstackimpl.crafting.nms;
+
+import org.oilmod.spigot.items.itemstackimpl.crafting.OilRecipe;
+import org.oilmod.spigot.items.itemstackimpl.crafting.OilShapelessRecipe;
+import net.minecraft.server.ItemStack;
+import net.minecraft.server.NonNullList;
+import net.minecraft.server.RecipeItemStack;
+import net.minecraft.server.ShapelessRecipes;
+
+/**
+ * Created by sirati97 on 28.03.2016.
+ */
+public class NMS_OilShapelessRecipe extends ShapelessRecipes implements NMS_OilRecipe {
+    private final OilRecipe oilRecipe;
+
+    public NMS_OilShapelessRecipe(ItemStack itemstack, NonNullList<ItemStack> list, OilShapelessRecipe oilRecipe) {
+        super(null, itemstack, convert(list)); //TODO set first arg and deal with key
+        this.oilRecipe = oilRecipe;
+    }
+
+    @Override
+    public OilRecipe getOilRecipe() {
+        return oilRecipe;
+    }
+
+    protected static NonNullList<RecipeItemStack> convert(NonNullList<ItemStack> list) { //TODO: get rid of this
+        NonNullList<RecipeItemStack> result = NonNullList.a(list.size(), RecipeItemStack.a);
+        for (int i = 0; i < list.size(); i++) {
+            result.set(i, RecipeItemStack.a(new ItemStack[]{list.get(i)}));
+        }
+        return result;
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/items/itemstackimpl/internal/ItemStackDescription.java b/src/main/java/org/oilmod/spigot/items/itemstackimpl/internal/ItemStackDescription.java
new file mode 100644
index 00000000..037b6b6e
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/items/itemstackimpl/internal/ItemStackDescription.java
@@ -0,0 +1,57 @@
+package org.oilmod.spigot.items.itemstackimpl.internal;
+
+import org.oilmod.api.config.Compound;
+import org.oilmod.spigot.config.DeserializationMethod;
+import net.minecraft.server.Item;
+import net.minecraft.server.NBTTagCompound;
+import org.apache.commons.lang3.NotImplementedException;
+import org.bukkit.Material;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
+import org.bukkit.inventory.meta.ItemMeta;
+import org.oilmod.spigot.config.DeserializationMethod;
+
+/**
+ * Created by sirati97 on 16.01.2016.
+ */
+public class ItemStackDescription { //TODO not done
+    public final Item item;
+    public final int data;
+    public final int size;
+    public final NBTTagCompound tag;
+
+    public ItemStackDescription(Compound compound, DeserializationMethod type) {
+        if (type == DeserializationMethod.Bukkit) { //Similar to ItemStack.deserialize
+            Material mat = Material.getMaterial(compound.getString("type"));
+            if(compound.containsKey("damage")) {
+                data = compound.getShort("damage");
+            } else {
+                data = 0;
+            }
+
+            if(compound.containsKey("amount")) {
+                size = compound.getInt("amount");
+            } else {
+                size = 1;
+            }
+            item = Item.getById(mat.getId());
+            if(compound.containsKey("meta")) {
+                Object raw = compound.getRaw("meta");
+                if(raw instanceof ItemMeta) {
+                    NBTTagCompound nbtTagCompound = new NBTTagCompound();
+                    if (CraftItemStack.setItemMeta(nbtTagCompound, mat, (ItemMeta)raw)) {
+                        tag = nbtTagCompound;
+                    } else {
+                        tag = null;
+                    }
+
+                } else {
+                    tag = null;
+                }
+            } else {
+                tag = null;
+            }
+        } else {
+            throw new NotImplementedException("There is no deserialization method for " + type.toString());
+        }
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/items/itemstackimpl/internal/ModCraftItemStack.java b/src/main/java/org/oilmod/spigot/items/itemstackimpl/internal/ModCraftItemStack.java
new file mode 100644
index 00000000..d493ef16
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/items/itemstackimpl/internal/ModCraftItemStack.java
@@ -0,0 +1,89 @@
+package org.oilmod.spigot.items.itemstackimpl.internal;
+
+import org.oilmod.spigot.config.DeserializationMethod;
+import org.oilmod.spigot.config.yaml.YamlCompound;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
+import org.bukkit.inventory.meta.ItemMeta;
+import org.oilmod.spigot.items.ItemStackCreator;
+import org.oilmod.spigot.items.ItemStackRegistry;
+
+import java.util.LinkedHashMap;
+import java.util.Map;
+
+
+/**
+ * Subclasses need to add the annotation @DelegateDeserialization(ModCraftItemStack.class) or add the method public static [? extends ModCraftItemStack] deserialize(Map<String, Object> args) {...}
+ */
+public class ModCraftItemStack extends CraftItemStack {
+    protected ModCraftItemStack(ModItemStack item) {
+        super(item);
+    }
+    public Map<String, Object> serialize() {
+        Map<String, Object> result = new LinkedHashMap();
+        result.put("type", this.getType().name());
+        if(this.getDurability() != 0) {
+            result.put("damage", this.getDurability());
+        }
+
+        if(this.getAmount() != 1) {
+            result.put("amount", this.getAmount());
+        }
+
+        ItemMeta meta = this.getItemMeta();
+        if(!Bukkit.getItemFactory().equals(meta, null)) {
+            result.put("meta", meta);
+        }
+        ModItemStack handle = getHandle();
+        YamlCompound compound = new YamlCompound();
+        handle.saveModBaseCompound(compound);
+        result.putAll(compound.getParent().getValues(false));
+        return result;
+    }
+
+    public static ModCraftItemStack deserialize(Map<String, Object> args) {
+        String mType = (String)args.get("mType");
+        ItemStackCreator creator = ItemStackRegistry.getInstance().get(mType);
+        if (creator != null) {
+            ModCraftItemStack itemstack = null;
+            try {
+                itemstack = creator.deserialize(args, DeserializationMethod.Bukkit).asCraftItemStack();
+            } catch (Exception ex) {
+                ex.printStackTrace();
+                System.err.println("Exception thrown while deserializing with ItemStackCreator '" + mType + "'! Cancelling deserialization of ModCraftItemStack! " + ex.toString());
+            }
+            return itemstack;
+        } else {
+            System.err.println("Cannot found ItemStackCreator for " + mType + "! Cancelling deserialization of ModCraftItemStack!");
+            return null;
+        }
+    }
+
+    @Override
+    public ModItemStack getHandle() {
+        return (ModItemStack) super.getHandle();
+    }
+
+    @Override
+    public ItemMeta getItemMeta() {
+        ItemMeta result = super.getItemMeta();
+        if (result != null) {
+            result.setLore(getHandle().getLore());
+        }
+        return result;
+    }
+
+    @Override
+    public boolean setItemMeta(ItemMeta itemMeta) {
+        boolean result = super.setItemMeta(itemMeta);
+        if (result && itemMeta!=null && itemMeta.hasLore()) {
+            getHandle().setLore(itemMeta.getLore());
+        }
+        return result;
+    }
+
+    @Override
+    public int getMaxStackSize() {
+        return getHandle().getMaxStackSize();
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/items/itemstackimpl/internal/ModItem.java b/src/main/java/org/oilmod/spigot/items/itemstackimpl/internal/ModItem.java
new file mode 100644
index 00000000..dccb10bd
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/items/itemstackimpl/internal/ModItem.java
@@ -0,0 +1,20 @@
+package org.oilmod.spigot.items.itemstackimpl.internal;
+
+import net.minecraft.server.MinecraftKey;
+import org.oilmod.api.items.OilItem;
+import net.minecraft.server.Item;
+import net.minecraft.server.NBTTagCompound;
+import org.oilmod.spigot.items.ItemStackCreator;
+
+/**
+ * Created by sirati97 on 15.01.2016.
+ */
+public interface ModItem {
+    MinecraftKey getKey();
+    ModItemStack createNMSItemStackForCloning(Item item, int i, int j, Object... objects);
+    ModItemStack createNMSItemStack(NBTTagCompound nbttagcompound);
+    ModItemStack createNMSItemStack(OilItem apiItem, int size, String displayName);
+    int getMaxStackSize();
+    boolean hasNBTCreator();
+    ItemStackCreator getCreator();
+}
diff --git a/src/main/java/org/oilmod/spigot/items/itemstackimpl/internal/ModItemStack.java b/src/main/java/org/oilmod/spigot/items/itemstackimpl/internal/ModItemStack.java
new file mode 100644
index 00000000..c60eae0d
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/items/itemstackimpl/internal/ModItemStack.java
@@ -0,0 +1,257 @@
+package org.oilmod.spigot.items.itemstackimpl.internal;
+
+import org.oilmod.api.config.Compound;
+import org.oilmod.spigot.config.nbttag.NBTCompound;
+import de.sirati97.spigot.optimisation.ItemStackFreeze;
+import net.minecraft.server.BlockPosition;
+import net.minecraft.server.Enchantment;
+import net.minecraft.server.EntityHuman;
+import net.minecraft.server.EnumDirection;
+import net.minecraft.server.Item;
+import net.minecraft.server.ItemStack;
+import net.minecraft.server.NBTTagCompound;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
+import org.bukkit.event.block.Action;
+
+import java.lang.ref.WeakReference;
+
+/**
+ * Created by sirati97 on 10.01.2016.
+ */
+public class ModItemStack extends ItemStack {
+    private ModItem modItem;
+    private WeakReference<ModCraftItemStack> craftItemStack = null;
+    private long lastChange=System.currentTimeMillis();
+
+    public ModItemStack(ModItem modItem, Item item, int count, int data) {
+        super(item, count, data, false); //don't convert - this cannot go well as we aren't even initialised properly.  //TODO: add support in future version
+        this.modItem = modItem;
+    }
+    public ModItemStack(ModItem modItem, Compound compound) {
+        super(compound);
+        this.modItem = modItem;
+        if (compound.containsKey("mTag") && modItem != null) {
+            loadModData(compound.getCompound("mTag"));
+        }
+    }
+
+    public ModItemStack(ModItem modItem, Item item, int count, int data, NBTTagCompound tag, Compound mTag) {
+        super(item, count, data, false); //don't convert - this cannot go well as we aren't even initialised properly.  //TODO: add support in future version
+        this.modItem = modItem;
+        setTag(tag);
+        loadModData(mTag);
+    }
+
+    public ModItemStack(ModItem modItem, ItemStackDescription description, Compound mTag) {
+        this(modItem, description.item, description.size, description.data, description.tag, mTag);
+    }
+
+
+    protected Object[] getCloneMeta() {
+        return new Object[]{};
+    }
+
+    @Override
+    public ModItemStack cloneItemStack() {
+        ModItemStack itemstack = getModItem().createNMSItemStackForCloning(this.getItem(), this.getCount(), this.getData(), getCloneMeta());
+        if (this.getTag() != null) {
+            itemstack.setTag(((NBTTagCompound) this.getTag().clone()));
+        }
+        itemstack.onCloned(this);
+        return itemstack;
+    }
+
+    @Override
+    public ModItemStack cloneAndSubtract(int i) {
+        ModItemStack itemstack = getModItem().createNMSItemStackForCloning(this.getItem(), i, this.getData(), getCloneMeta());
+        if (this.getTag() != null) {
+            itemstack.setTag(((NBTTagCompound) this.getTag().clone()));
+        }
+        this.subtract(i);
+        itemstack.onCloned(this);
+        return itemstack;
+    }
+
+    protected void onCloned(ModItemStack original) {}
+
+
+    public ModItem getModItem() {
+        return modItem;
+    }
+
+    public static ModItemStack getBukkitHandle(org.bukkit.inventory.ItemStack bukkitItem) {
+        ItemStack handle = getBukkitHandleNMS(bukkitItem);
+        if (handle instanceof ModItemStack) return (ModItemStack) handle;
+        return null;
+    }
+
+    public static ItemStack getBukkitHandleNMS(org.bukkit.inventory.ItemStack bukkitItem) {
+        if (!(bukkitItem instanceof CraftItemStack))return ItemStack.a;
+        return ((CraftItemStack) bukkitItem).getHandle();
+    }
+
+    @Override
+    public void load(NBTTagCompound nbttagcompound) {
+        super.load(nbttagcompound);
+        if (nbttagcompound.hasKeyOfType("mTag", 10) && modItem != null) {
+            loadModData(new NBTCompound(nbttagcompound.getCompound("mTag")));
+        }
+    }
+
+    @Override
+    public void load(Compound compound) {
+        super.load(compound);
+        if (compound.containsKey("mTag") && modItem != null) {
+            loadModData(compound.getCompound("mTag"));
+        }
+    }
+
+    @Override
+    public NBTTagCompound save(NBTTagCompound nbttagcompound) {
+        super.save(nbttagcompound);
+        try {
+            if (getModItem().hasNBTCreator()) {
+                NBTCompound compound = new NBTCompound(nbttagcompound);
+                saveModBaseCompound(compound);
+            }
+        } catch (Exception ex) {
+            ex.printStackTrace();
+            throw ex;
+        }
+
+        return nbttagcompound;
+    }
+
+    @Override
+    public Compound save(Compound compound) {
+        super.save(compound);
+        try {
+            if (getModItem().hasNBTCreator()) {
+                saveModBaseCompound(compound);
+            }
+        } catch (Exception ex) {
+            ex.printStackTrace();
+            throw ex;
+        }
+        return compound;
+    }
+
+
+    public Compound saveModBaseCompound(Compound compound) {
+        if (getModItem().hasNBTCreator()) {
+            compound.setString("mType", getModItem().getCreator().getInternalName());
+            Compound mTag = compound.createCompound();
+            mTag.setString("mItemId", getModItem().getKey().getKey());
+            compound.set("mTag", saveModData(mTag));
+        }
+        return compound;
+    }
+
+    public Compound saveModData(Compound compound) {
+        return compound;
+    }
+
+    public Compound loadModData(Compound compound) {
+        return compound;
+    }
+
+    @Override
+    public int getMaxStackSize() {
+        return modItem.getMaxStackSize()>0?modItem.getMaxStackSize():super.getMaxStackSize();
+    }
+
+    public boolean onUse(EntityHuman who, Action action) {
+        return false;
+    }
+
+    public boolean onUseOnBlock(EntityHuman who, Action action, BlockPosition position, EnumDirection direction) {
+        return false;
+    }
+
+    public boolean onLeftClick(EntityHuman who, Action action) {
+        return false;
+    }
+
+    public boolean onLeftClickOnBlock(EntityHuman who, Action action, BlockPosition position, EnumDirection direction) {
+        return false;
+    }
+
+    public ModCraftItemStack asCraftItemStack() {
+        if (craftItemStack == null || craftItemStack.get() == null) {
+            craftItemStack = new WeakReference<ModCraftItemStack>(createCraftItemStack());
+        }
+        return craftItemStack.get();
+    }
+
+    public ModCraftItemStack createCraftItemStack() {
+        return new ModCraftItemStack(this);
+    }
+
+
+    public boolean canEnchant(Enchantment enchantment) {
+        return false;
+    }
+
+    public boolean isEnchantable() {
+        return false;
+    }
+
+    public int getEnchantSelectModifier() {
+        return 0;
+    }
+
+    @Override
+    public boolean canEnchant() {
+        return isEnchantable() && !this.hasEnchantments();
+    }
+
+    public long getLastChange() {
+        return lastChange;
+    }
+
+    /**
+     *Used to indicate that this item needs the be resynchronised with the client */
+    protected void setChanged() {
+        this.lastChange = System.currentTimeMillis();
+    }
+
+    @Override
+    public ItemStackFreeze createFreeze() {
+        return isDegenerate()?ItemStackFreeze.EMPTY:new ModItemStackFreeze<>(getTag(),getItem(),getCount(),getData(), getModItem(), getLastChange());
+    }
+
+    public String getCorrectDisplayName() {
+        return "";
+    }
+
+    public boolean canRepairAnvil(ItemStack itemStack, EntityHuman human) {
+        return false;
+    }
+
+    public int prepareRepairAnvil(ItemStack itemStack, EntityHuman human) {
+        return 0;
+    }
+
+    public void repairAnvil(ItemStack itemStack, EntityHuman human) {
+    }
+
+    public boolean canCombineAnvil(ItemStack itemStack, EntityHuman human) {
+        return false;
+    }
+
+    public void combineAnvil(ItemStack itemStack, EntityHuman human) {
+
+    }
+
+    public void prepareCombineAnvil(ItemStack itemStack, EntityHuman human) {
+
+    }
+
+
+    @Override
+    public String toString() {
+        return super.toString() + (isDegenerate()?"":( "-ModItem:" + getModItem().getKey().toString()));
+    }
+
+
+}
diff --git a/src/main/java/org/oilmod/spigot/items/itemstackimpl/internal/ModItemStackFreeze.java b/src/main/java/org/oilmod/spigot/items/itemstackimpl/internal/ModItemStackFreeze.java
new file mode 100644
index 00000000..67bb992a
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/items/itemstackimpl/internal/ModItemStackFreeze.java
@@ -0,0 +1,38 @@
+package org.oilmod.spigot.items.itemstackimpl.internal;
+
+import de.sirati97.spigot.optimisation.ItemStackFreeze;
+import net.minecraft.server.Item;
+import net.minecraft.server.ItemStack;
+import net.minecraft.server.NBTTagCompound;
+
+/**
+ * Created by sirati97 on 14.03.2016.
+ */
+public class ModItemStackFreeze<T extends ModItemStack> extends ItemStackFreeze {
+    public final ModItem modItem;
+    public final long lastChange;
+
+    public ModItemStackFreeze(NBTTagCompound tag, Item item, int count, int damage, ModItem modItem, long lastChange) {
+        super(tag, item, count, damage);
+        this.modItem = modItem;
+        this.lastChange = lastChange;
+    }
+
+    @Override
+    public boolean fastMatchTo(ItemStack itemstack) {
+        return super.fastMatchTo(itemstack) && checkClass(itemstack) && checkSpecific((T) itemstack);
+    }
+
+    protected boolean checkSpecific(T itemstack) {
+        return modItem.equals(itemstack.getModItem()) && lastChange==itemstack.getLastChange();
+    }
+
+    protected boolean checkClass(ItemStack itemStack) {
+        return itemStack instanceof ModItemStack;
+    }
+
+    @Override
+    public String toString() {
+        return super.toString() + "-ModItem:" + modItem.getKey().toString();
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/items/itemstackimpl/internal/RealItemClassMap.java b/src/main/java/org/oilmod/spigot/items/itemstackimpl/internal/RealItemClassMap.java
new file mode 100644
index 00000000..9d1d46c1
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/items/itemstackimpl/internal/RealItemClassMap.java
@@ -0,0 +1,35 @@
+package org.oilmod.spigot.items.itemstackimpl.internal;
+
+import org.oilmod.api.items.OilItem;
+import org.oilmod.api.items.internal.ItemClassMap;
+import gnu.trove.map.TMap;
+import gnu.trove.map.hash.THashMap;
+import gnu.trove.set.hash.THashSet;
+
+import java.lang.reflect.Array;
+import java.util.Set;
+
+/**
+ * Created by sirati97 on 02.04.2016.
+ */
+public class RealItemClassMap extends ItemClassMap {
+    private TMap<Class<? extends OilItem>,Set<? extends OilItem>> itemClassMap = new THashMap<>();
+
+    @Override
+    public <T extends OilItem> T[] getOilItemsByClass(Class<T> clazz) {
+        Set<T> set = (Set<T>) itemClassMap.get(clazz);
+        return set==null||set.size()==0?array(clazz, 0):set.toArray(array(clazz, set.size()));
+    }
+
+    public <T extends OilItem> void register(T item) {
+        Class<T> clazz = (Class<T>) item.getClass();
+        Set<T> newSet = new THashSet<>();
+        Set<T> set = (Set<T>) itemClassMap.putIfAbsent(clazz, newSet);
+        set = set==null?newSet:set;
+        set.add(item);
+    }
+
+    private <T extends OilItem> T[] array(Class<T> clazz, int capacity) {
+        return (T[]) Array.newInstance(clazz, capacity);
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/items/itemstackimpl/internal/RealItemFactory.java b/src/main/java/org/oilmod/spigot/items/itemstackimpl/internal/RealItemFactory.java
new file mode 100644
index 00000000..06b03e83
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/items/itemstackimpl/internal/RealItemFactory.java
@@ -0,0 +1,20 @@
+package org.oilmod.spigot.items.itemstackimpl.internal;
+
+import org.oilmod.api.items.OilItem;
+import org.oilmod.api.items.internal.ItemFactory;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
+import org.bukkit.entity.Player;
+import org.bukkit.inventory.ItemStack;
+
+/**
+ * Created by sirati97 on 15.01.2016.
+ */
+public class RealItemFactory extends ItemFactory {
+    @Override
+    public ItemStack createStack(OilItem apiItem, Player player, int count, int data) {
+        String displayName = apiItem.getDisplayName(player);
+        ModItem modItem = (ModItem) apiItem.getNmsItem();
+        ModItemStack itemStack = modItem.createNMSItemStack(apiItem, count, displayName);
+        return CraftItemStack.asCraftMirror(itemStack);
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/items/itemtype/RealAxe.java b/src/main/java/org/oilmod/spigot/items/itemtype/RealAxe.java
new file mode 100644
index 00000000..f250dd90
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/items/itemtype/RealAxe.java
@@ -0,0 +1,40 @@
+package org.oilmod.spigot.items.itemtype;
+
+import net.minecraft.server.Block;
+import net.minecraft.server.ItemAxe;
+import net.minecraft.server.Material;
+import org.bukkit.block.BlockState;
+import org.oilmod.api.blocks.BlockType;
+import org.oilmod.api.items.OilItemStack;
+import org.oilmod.api.items.type.IToolBlockBreaking;
+import org.oilmod.spigot.util.OilSpigotUtil;
+
+
+//KEEPSYNC ItemPickaxe
+public class RealAxe extends RealTBBTool {
+    protected RealAxe() {
+        super(TBBEnum.AXE, 1, 2);
+    }
+
+    @Override
+    protected boolean canHarvestBlock(IToolBlockBreaking item, BlockState blockState, BlockType blockType) {
+
+        Block block = OilSpigotUtil.toNMS(blockState.getType());
+        Material material = (Material) blockType.getNmsBlockType();
+
+        //OilSpigot auto-simplify + added own check
+        return (!block.isVanilla() && blockType.breakableAxe(OilSpigotUtil.toBukkit(block)));
+    }
+
+    @Override
+    protected float getDestroySpeed(IToolBlockBreaking item, OilItemStack itemStack, BlockState blockState, BlockType blockType) {
+        Block block = OilSpigotUtil.toNMS(blockState.getType());
+        Material material = (Material) blockType.getNmsBlockType();
+
+        boolean result = material == Material.WOOD || material == Material.PLANT || material == Material.REPLACEABLE_PLANT ||
+                (!block.isVanilla() && blockType.breakableAxe(OilSpigotUtil.toBukkit(block))) ||
+                ItemAxe.BLOCKS.contains(block);
+
+        return result? item.getDestroySpeed(itemStack) : 1;
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/items/itemtype/RealPickaxe.java b/src/main/java/org/oilmod/spigot/items/itemtype/RealPickaxe.java
new file mode 100644
index 00000000..9a21cf51
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/items/itemtype/RealPickaxe.java
@@ -0,0 +1,47 @@
+package org.oilmod.spigot.items.itemtype;
+
+import net.minecraft.server.Block;
+import net.minecraft.server.ItemPickaxe;
+import net.minecraft.server.Material;
+import org.bukkit.block.BlockState;
+import org.oilmod.api.blocks.BlockType;
+import org.oilmod.api.items.OilItemStack;
+import org.oilmod.api.items.type.IPickaxe;
+import org.oilmod.api.items.type.IToolBlockBreaking;
+import org.oilmod.api.items.type.TBBType;
+import org.oilmod.spigot.util.OilSpigotUtil;
+
+
+//KEEPSYNC ItemPickaxe
+public class RealPickaxe extends RealTBBTool {
+    protected RealPickaxe() {
+        super(TBBType.TBBEnum.PICKAXE, 1, 2);
+    }
+
+    @Override
+    protected boolean canHarvestBlock(IToolBlockBreaking item, BlockState blockState, BlockType blockType) {
+        IPickaxe pickaxe = (IPickaxe) item;
+
+        Block block = OilSpigotUtil.toNMS(blockState.getType());
+        Material material = (Material) blockType.getNmsBlockType();
+
+        //OilSpigot auto-simplify + added own check
+        boolean result = material == Material.STONE || material == Material.ORE || material == Material.HEAVY ||
+                (!block.isVanilla() && blockType.breakablePickaxe(OilSpigotUtil.toBukkit(block)));
+
+        //OilSpigot use new method getHardness instead of doing this weird if
+        return result && block.getHardness() >= 0 ? pickaxe.getPickaxeStrength() >= block.getHardness() : result;
+    }
+
+    @Override
+    protected float getDestroySpeed(IToolBlockBreaking item, OilItemStack itemStack, BlockState blockState, BlockType blockType) {
+        Block block = OilSpigotUtil.toNMS(blockState.getType());
+        Material material = (Material) blockType.getNmsBlockType();
+
+        boolean result = material == Material.STONE || material == Material.ORE || material == Material.HEAVY ||
+                (!block.isVanilla() && blockType.breakablePickaxe(OilSpigotUtil.toBukkit(block))) ||
+                ItemPickaxe.BLOCKS.contains(block);
+
+        return result? item.getDestroySpeed(itemStack) : 1;
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/items/itemtype/RealShears.java b/src/main/java/org/oilmod/spigot/items/itemtype/RealShears.java
new file mode 100644
index 00000000..c04622cb
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/items/itemtype/RealShears.java
@@ -0,0 +1,59 @@
+package org.oilmod.spigot.items.itemtype;
+
+import net.minecraft.server.Block;
+import net.minecraft.server.Blocks;
+import net.minecraft.server.IBlockData;
+import net.minecraft.server.Material;
+import org.bukkit.Location;
+import org.bukkit.block.BlockState;
+import org.bukkit.entity.LivingEntity;
+import org.oilmod.api.blocks.BlockType;
+import org.oilmod.api.blocks.IBlockState;
+import org.oilmod.api.items.OilItemStack;
+import org.oilmod.api.items.type.IToolBlockBreaking;
+import org.oilmod.spigot.util.OilSpigotUtil;
+
+
+//KEEPSYNC ItemShears
+public class RealShears extends RealTBBTool {
+    protected RealShears() {
+        super(TBBEnum.SHEARS, 1, 2);
+    }
+
+    @Override
+    protected boolean canHarvestBlock(IToolBlockBreaking item, BlockState blockState, BlockType blockType) {
+
+        Block block = OilSpigotUtil.toNMS(blockState.getType());
+
+        //OilSpigot auto-simplify + added own check
+        return block == Blocks.WEB || block == Blocks.REDSTONE_WIRE || block == Blocks.TRIPWIRE ||
+                (!block.isVanilla() && blockType.breakableShovel(OilSpigotUtil.toBukkit(block)));
+    }
+
+    @Override
+    protected float getDestroySpeed(IToolBlockBreaking item, OilItemStack itemStack, BlockState blockState, BlockType blockType) {
+        Block block = OilSpigotUtil.toNMS(blockState.getType());
+        Material material = (Material) blockType.getNmsBlockType();
+
+
+        if (block == Blocks.WOOL || material == Material.WOOL) {
+            return item.getDestroySpeed(itemStack)/3;
+        }
+
+        boolean result = material == Material.WEB || material != Material.LEAVES ||
+                (!block.isVanilla() && blockType.breakableShovel(OilSpigotUtil.toBukkit(block)));
+
+        return result? item.getDestroySpeed(itemStack) : 1;
+    }
+
+    @Override
+    protected boolean onBlockDestroyed(IToolBlockBreaking item, OilItemStack stack, IBlockState blockState, Location pos, LivingEntity entityLiving) {
+        IBlockData iblockdata = (IBlockData) blockState.getNMS();
+
+        Block block = iblockdata.getBlock();
+
+        super.onBlockDestroyed(item, stack, blockState, pos, entityLiving);
+        return iblockdata.getMaterial() == Material.LEAVES || block == Blocks.WEB || block == Blocks.TALLGRASS || block == Blocks.VINE || block == Blocks.TRIPWIRE || block == Blocks.WOOL;
+
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/items/itemtype/RealShovel.java b/src/main/java/org/oilmod/spigot/items/itemtype/RealShovel.java
new file mode 100644
index 00000000..0f872ff7
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/items/itemtype/RealShovel.java
@@ -0,0 +1,52 @@
+package org.oilmod.spigot.items.itemtype;
+
+import net.minecraft.server.*;
+import org.bukkit.Location;
+import org.bukkit.block.BlockFace;
+import org.bukkit.block.BlockState;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.entity.CraftHumanEntity;
+import org.bukkit.entity.HumanEntity;
+import org.oilmod.api.blocks.BlockType;
+import org.oilmod.api.items.OilItemStack;
+import org.oilmod.api.items.type.IToolBlockBreaking;
+import org.oilmod.api.util.InteractionResult;
+import org.oilmod.spigot.util.OilSpigotUtil;
+
+
+//KEEPSYNC ItemSpade
+public class RealShovel extends RealTBBTool {
+    protected RealShovel() {
+        super(TBBEnum.SHOVEL, 1, 2);
+    }
+
+    @Override
+    protected boolean canHarvestBlock(IToolBlockBreaking item, BlockState blockState, BlockType blockType) {
+
+        Block block = OilSpigotUtil.toNMS(blockState.getType());
+        Material material = (Material) blockType.getNmsBlockType();
+
+        //OilSpigot vanilla + added own check
+        return block == Blocks.SNOW_LAYER || block == Blocks.SNOW || (!block.isVanilla() && material.getOilBlockType().breakableShovel(OilSpigotUtil.toBukkit(block)));
+    }
+
+    @Override
+    protected float getDestroySpeed(IToolBlockBreaking item, OilItemStack itemStack, BlockState blockState, BlockType blockType) {
+        Block block = OilSpigotUtil.toNMS(blockState.getType());
+
+        boolean result = (!block.isVanilla() && blockType.breakableShovel(OilSpigotUtil.toBukkit(block))) ||
+                ItemPickaxe.BLOCKS.contains(block);
+
+        return result? item.getDestroySpeed(itemStack) : 1;
+    }
+
+    @Override
+    protected InteractionResult onItemUseOnBlock(IToolBlockBreaking item, OilItemStack stack, HumanEntity humanEntity, Location pos, boolean offhand, BlockFace facing, float hitX, float hitY, float hitZ) {
+        EntityHuman entityhuman = ((CraftHumanEntity)humanEntity).getHandle();
+        ItemStack itemstack = (ItemStack) stack.getNmsItemStack();
+        World world = ((CraftWorld)pos.getWorld()).getHandle();
+        BlockPosition blockposition = new BlockPosition(pos.getX(), pos.getY(), pos.getZ());
+        EnumDirection enumdirection = OilSpigotUtil.toNMS(facing);
+        return OilSpigotUtil.toOil(ItemSpade.onItemUse(entityhuman, itemstack, world, blockposition, enumdirection));
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/items/itemtype/RealSword.java b/src/main/java/org/oilmod/spigot/items/itemtype/RealSword.java
new file mode 100644
index 00000000..f4cd46fd
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/items/itemtype/RealSword.java
@@ -0,0 +1,46 @@
+package org.oilmod.spigot.items.itemtype;
+
+import net.minecraft.server.Block;
+import net.minecraft.server.Blocks;
+import net.minecraft.server.ItemPickaxe;
+import net.minecraft.server.Material;
+import org.bukkit.block.BlockState;
+import org.oilmod.api.blocks.BlockType;
+import org.oilmod.api.items.OilItemStack;
+import org.oilmod.api.items.type.IToolBlockBreaking;
+import org.oilmod.spigot.util.OilSpigotUtil;
+
+
+//KEEPSYNC ItemSword
+public class RealSword extends RealTBBTool {
+    protected RealSword() {
+        super(TBBEnum.SWORD, 2, 1);
+    }
+
+    @Override
+    protected boolean canHarvestBlock(IToolBlockBreaking item, BlockState blockState, BlockType blockType) {
+
+        Block block = OilSpigotUtil.toNMS(blockState.getType());
+        Material material = (Material) blockType.getNmsBlockType();
+
+        //OilSpigot vanilla + added own check
+        return block == Blocks.WEB || (!block.isVanilla() && material.getOilBlockType().breakableBlade(OilSpigotUtil.toBukkit(block)));
+    }
+
+    @Override
+    protected float getDestroySpeed(IToolBlockBreaking item, OilItemStack itemStack, BlockState blockState, BlockType blockType) {
+        Block block = OilSpigotUtil.toNMS(blockState.getType());
+        Material material = (Material) blockType.getNmsBlockType();
+
+        if (block == Blocks.WEB) {
+            return item.getDestroySpeed(itemStack) *10;
+        }
+
+        boolean result = material == Material.PLANT || material == Material.REPLACEABLE_PLANT || material == Material.CORAL || material == Material.LEAVES || material == Material.PUMPKIN ||
+                (!block.isVanilla() && blockType.breakableBlade(OilSpigotUtil.toBukkit(block))) ||
+                ItemPickaxe.BLOCKS.contains(block);
+
+        return result? item.getDestroySpeed(itemStack) : 1;
+    }
+
+}
diff --git a/src/main/java/org/oilmod/spigot/items/itemtype/RealTBBHelper.java b/src/main/java/org/oilmod/spigot/items/itemtype/RealTBBHelper.java
new file mode 100644
index 00000000..3c1e914e
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/items/itemtype/RealTBBHelper.java
@@ -0,0 +1,43 @@
+package org.oilmod.spigot.items.itemtype;
+
+import net.minecraft.server.ItemSword;
+import org.oilmod.api.items.OilItem;
+import org.oilmod.api.items.type.IItemGeneric;
+import org.oilmod.api.items.type.IToolBlockBreaking;
+import org.oilmod.api.items.type.ItemTypeHelper;
+import org.oilmod.api.items.type.TBBType.TBBEnum;
+import org.oilmod.api.items.type.TBBType;
+
+import static org.oilmod.api.items.type.TBBType.TBBEnum.*;
+
+public class RealTBBHelper extends TBBType.TBBHelper {
+    @Override
+    protected void apiInit() {
+
+    }
+
+    @Override
+    protected void apiPostInit() {
+
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
+    protected TBBType getVanilla(TBBEnum itemType) {
+        switch (itemType) {
+
+            case PICKAXE:
+                return new RealPickaxe();
+            case AXE:
+                return new RealAxe();
+            case SHOVEL:
+                return new RealShovel();
+            case SHEARS:
+                return new RealShears();
+            case SWORD:
+                return new RealSword();
+            default:
+                throw new IllegalArgumentException("No vanilla implementation for " + itemType.toString() + " available");
+        }
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/items/itemtype/RealTBBTool.java b/src/main/java/org/oilmod/spigot/items/itemtype/RealTBBTool.java
new file mode 100644
index 00000000..f20614ac
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/items/itemtype/RealTBBTool.java
@@ -0,0 +1,52 @@
+package org.oilmod.spigot.items.itemtype;
+
+import org.bukkit.Location;
+import org.bukkit.block.BlockFace;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.entity.HumanEntity;
+import org.bukkit.entity.LivingEntity;
+import org.oilmod.api.blocks.IBlockState;
+import org.oilmod.api.items.OilItemStack;
+import org.oilmod.api.items.type.IDurable;
+import org.oilmod.api.items.type.IToolBlockBreaking;
+import org.oilmod.api.items.type.TBBType;
+import org.oilmod.api.util.InteractionResult;
+
+
+//KEEPSYNC ItemTool
+public abstract class RealTBBTool extends TBBType{
+    private final int blockToolDamage;
+    private final int entityToolDamage;
+
+
+    protected RealTBBTool(TBBEnum tbbEnum, int blockToolDamage, int entityToolDamage) {
+        super(tbbEnum);
+        this.blockToolDamage = blockToolDamage;
+        this.entityToolDamage = entityToolDamage;
+    }
+
+    @Override
+    protected boolean onEntityHit(IToolBlockBreaking item, OilItemStack stack, LivingEntity target, LivingEntity attacker) {
+        if (item instanceof IDurable) {
+            IDurable durable = (IDurable) item;
+            durable.damageItem(stack, entityToolDamage, attacker);
+        }
+        return true;
+    }
+
+    @Override
+    protected boolean onBlockDestroyed(IToolBlockBreaking item, OilItemStack stack, IBlockState blockState, Location pos, LivingEntity entityLiving) {
+        net.minecraft.server.World world = ((CraftWorld)pos.getWorld()).getHandle();
+
+        if (!world.isClientSide &&  item instanceof IDurable && blockState.getBlockHardness(pos) != 0) {
+            IDurable durable = (IDurable) item;
+            durable.damageItem(stack, blockToolDamage, entityLiving);
+        }
+        return true;
+    }
+
+    @Override
+    protected InteractionResult onItemUseOnBlock(IToolBlockBreaking item, OilItemStack stack, HumanEntity humanEntity, Location pos, boolean offhand, BlockFace facing, float hitX, float hitY, float hitZ) {
+        return InteractionResult.NONE;
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/ui/SlotState.java b/src/main/java/org/oilmod/spigot/ui/SlotState.java
new file mode 100644
index 00000000..2794c1e7
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/ui/SlotState.java
@@ -0,0 +1,43 @@
+package org.oilmod.spigot.ui;
+
+import net.minecraft.server.ItemStack;
+import org.oilmod.api.ui.ISlotState;
+import org.oilmod.api.ui.IUIInventory;
+import org.oilmod.spigot.util.OilSpigotUtil;
+
+public class SlotState implements ISlotState {
+    private IUIInventory uiInventory;
+    private ItemStack itemStackNMS;
+
+    public SlotState(IUIInventory uiInventory) {
+        this.uiInventory = uiInventory;
+    }
+
+    @Override
+    public void setItemStack(org.bukkit.inventory.ItemStack itemStack) {
+        this.setItemStackNMS(OilSpigotUtil.toNMS(itemStack));
+    }
+
+    @Override
+    public org.bukkit.inventory.ItemStack getItemStack() {
+        return OilSpigotUtil.toBukkit(itemStackNMS);
+    }
+
+    public ItemStack getItemStackNMS() {
+        return itemStackNMS;
+    }
+
+    public void setItemStackNMS(ItemStack itemStackNMS) {
+        this.itemStackNMS = itemStackNMS;
+    }
+
+    @Override
+    public Object getNMSSlotState() {
+        return this;
+    }
+
+    @Override
+    public IUIInventory getUIInventory() {
+        return uiInventory;
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/ui/StorageSlotBehaviour.java b/src/main/java/org/oilmod/spigot/ui/StorageSlotBehaviour.java
new file mode 100644
index 00000000..528b6486
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/ui/StorageSlotBehaviour.java
@@ -0,0 +1,5 @@
+package org.oilmod.spigot.ui;
+
+public class StorageSlotBehaviour {
+
+}
diff --git a/src/main/java/org/oilmod/spigot/ui/UIInventoryGenericBukkit.java b/src/main/java/org/oilmod/spigot/ui/UIInventoryGenericBukkit.java
new file mode 100644
index 00000000..b8e93264
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/ui/UIInventoryGenericBukkit.java
@@ -0,0 +1,37 @@
+package org.oilmod.spigot.ui;
+
+import org.bukkit.inventory.Inventory;
+import org.oilmod.api.inventory.ItemFilter;
+import org.oilmod.api.ui.ISlotInteraction;
+import org.oilmod.api.ui.ISlotState;
+import org.oilmod.api.ui.IUIInventory;
+
+import java.util.List;
+
+public class UIInventoryGenericBukkit implements IUIInventory {
+    private Inventory inventory;
+
+    public UIInventoryGenericBukkit(Inventory inventory) {
+        this.inventory = inventory;
+    }
+
+    @Override
+    public List<ISlotState> getInteractableSlots() {
+        return null;
+    }
+
+    @Override
+    public ItemFilter getItemFilter() {
+        return null;
+    }
+
+    @Override
+    public ISlotInteraction getInteraction() {
+        return null;
+    }
+
+    @Override
+    public int getMaxStackSize() {
+        return 0;
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/ui/UIManager.java b/src/main/java/org/oilmod/spigot/ui/UIManager.java
new file mode 100644
index 00000000..aadada86
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/ui/UIManager.java
@@ -0,0 +1,31 @@
+package org.oilmod.spigot.ui;
+
+import org.apache.commons.lang3.NotImplementedException;
+import org.bukkit.inventory.Inventory;
+import org.oilmod.api.inventory.ItemFilter;
+import org.oilmod.api.ui.ISlotInteraction;
+import org.oilmod.api.ui.ISlotState;
+import org.oilmod.api.ui.IUIInventory;
+import org.oilmod.api.ui.UI;
+
+public class UIManager extends UI.UIManagerHelper {
+    @Override
+    public ISlotState createSlot(IUIInventory uiInventory) {
+        return new SlotState(uiInventory);
+    }
+
+    @Override
+    public ISlotState[] createSlots(IUIInventory uiInventory, int size) {
+        throw new NotImplementedException("");
+    }
+
+    @Override
+    public IUIInventory createUIInventory(int size, ISlotInteraction interaction, ItemFilter filter, int maxstack) {
+        return null;
+    }
+
+    @Override
+    public IUIInventory createUIInventory(Inventory inventory) {
+        return null;
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/util/BetterNonNullList.java b/src/main/java/org/oilmod/spigot/util/BetterNonNullList.java
new file mode 100644
index 00000000..a6a2b895
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/util/BetterNonNullList.java
@@ -0,0 +1,32 @@
+package org.oilmod.spigot.util;
+
+import net.minecraft.server.NonNullList;
+import org.apache.commons.lang3.Validate;
+
+import javax.annotation.Nullable;
+import java.util.ArrayList;
+import java.util.List;
+
+public class BetterNonNullList<T> extends NonNullList<T> { //This one is not fixed size
+    private final List<T> list;
+    private final T empty;
+
+    public BetterNonNullList(@Nullable T empty) {
+        this(new ArrayList<>(), empty);
+    }
+
+    protected BetterNonNullList(List<T> list, @Nullable T empty) {
+        super(list, empty);
+        this.list = list;
+        this.empty = empty;
+    }
+
+    public boolean add(T item) {
+        Validate.notNull(item);
+        return this.list.add(item);
+    }
+
+    public T getEmpty() {
+        return empty;
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/util/OilSpigotUtil.java b/src/main/java/org/oilmod/spigot/util/OilSpigotUtil.java
new file mode 100644
index 00000000..1a15c350
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/util/OilSpigotUtil.java
@@ -0,0 +1,219 @@
+package org.oilmod.spigot.util;
+
+import net.minecraft.server.*;
+import org.apache.commons.lang3.NotImplementedException;
+import org.bukkit.Location;
+import org.bukkit.Material;
+import org.bukkit.block.BlockFace;
+import org.bukkit.craftbukkit.block.CraftBlock;
+import org.bukkit.craftbukkit.block.CraftBlockState;
+import org.bukkit.craftbukkit.util.CraftMagicNumbers;
+import org.oilmod.api.userinterface.ClickType;
+import org.oilmod.api.userinterface.IInteractableUIElement;
+import org.oilmod.api.userinterface.IUIElement;
+import org.oilmod.api.userinterface.UIPanel;
+import org.oilmod.api.userinterface.internal.NMSBasedUIPanel;
+import org.oilmod.api.userinterface.internal.NMSClickData;
+import org.oilmod.api.userinterface.internal.UserInterface;
+import org.oilmod.api.util.InteractionResult;
+import org.oilmod.spigot.inventory.custom.ClickExtraData;
+import org.oilmod.spigot.inventory.custom.api.OilElementWrapper;
+import org.oilmod.spigot.inventory.custom.api.OilInteractableElementWrapper;
+import org.oilmod.spigot.inventory.custom.api.OilPanelWrapper;
+import org.oilmod.spigot.inventory.custom.api.WrappedPanel;
+import org.oilmod.spigot.inventory.custom.nms.ViewContainer;
+import org.oilmod.spigot.inventory.custom.slot.IViewSlot;
+import org.oilmod.spigot.inventory.custom.view.ISlotView;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.entity.CraftHumanEntity;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
+import org.bukkit.entity.Player;
+
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * Created by sirati97 on 14.06.2016 for spigot.
+ */
+public final class OilSpigotUtil {
+    private final static Map<InventoryClickType, ClickType> clickTypeNMSToOilMap = new HashMap<>();
+    private final static Map<ClickType, InventoryClickType> clickTypeOilToNMSMap = new HashMap<>();
+
+    static {
+        clickTypeNMSToOilMap.put(InventoryClickType.PICKUP, ClickType.PICKUP);
+        clickTypeNMSToOilMap.put(InventoryClickType.PICKUP_ALL, ClickType.PICKUP_ALL);
+        clickTypeNMSToOilMap.put(InventoryClickType.THROW, ClickType.THROW);
+        clickTypeNMSToOilMap.put(InventoryClickType.QUICK_CRAFT, ClickType.QUICK_CRAFT);
+        clickTypeNMSToOilMap.put(InventoryClickType.QUICK_MOVE, ClickType.QUICK_MOVE);
+        clickTypeNMSToOilMap.put(InventoryClickType.SWAP, ClickType.SWAP);
+        clickTypeNMSToOilMap.put(InventoryClickType.CLONE, ClickType.CLONE);
+        for(Map.Entry<InventoryClickType, ClickType> entry:clickTypeNMSToOilMap.entrySet()) {
+            clickTypeOilToNMSMap.put(entry.getValue(), entry.getKey());
+        }
+    }
+
+
+    public static Player toBukkit(EntityHuman human) {
+        CraftHumanEntity bukkit = human.getBukkitEntity();
+        if (bukkit instanceof Player) {
+            return (Player) bukkit;
+        } else {
+            throw new IllegalStateException("Do not know how to convert " + human.getClass().getCanonicalName() + " to Player (Bukkit)");
+        }
+    }
+
+    public static EntityPlayer toNMS(Player player) {
+        if (player instanceof CraftPlayer) {
+            return ((CraftPlayer) player).getHandle();
+        } else {
+            throw new IllegalStateException("Do not know how to convert " + player.getClass().getCanonicalName() + " to EntityPlayer (NMS)");
+        }
+    }
+
+    public static ISlotView toNMS(UIPanel panel) {
+        if (panel == null) {
+            return null;
+        } else if (panel instanceof ISlotView) {
+            return (ISlotView) panel;
+        } else if (panel instanceof NMSBasedUIPanel) {
+            NMSBasedUIPanel nms = (NMSBasedUIPanel) panel;
+            if (nms.getNmsPanel() instanceof ISlotView) {
+                return (ISlotView) nms.getNmsPanel();
+            } else {
+                throw new IllegalStateException("Invalid implementation of NMSBasedUIPanel: " + nms.getClass().getName());
+            }
+        } else {
+            return new OilPanelWrapper(panel);
+        }
+    }
+
+    public static UIPanel toOil(ISlotView view) {
+        return view instanceof WrappedPanel?((WrappedPanel) view).getOilPanel():view;
+    }
+
+    public static ViewContainer toNMS(UserInterface userInterface) {
+        if (userInterface instanceof ViewContainer) {
+            return (ViewContainer) userInterface;
+        } else {
+            throw new IllegalStateException("Do use factory to obtain instance of UserInterface!");
+        }
+    }
+    public static ClickExtraData toNMS(NMSClickData data) {
+        if (data == null) {
+            throw new IllegalStateException("NMSClickData must not be null");
+        } else if (data instanceof ClickExtraData) {
+            return (ClickExtraData) data;
+        } else {
+            throw new IllegalStateException("Invalid implementation of NMSClickData: " + data.getClass().getName() + ". Obtain one with UIHelper.getInstance().createNMSClickData(...). Only do this if you know what you are doing!");
+        }
+    }
+
+    public static IViewSlot toNMS(IUIElement element) {
+        if (element == null) {
+            return null;
+        } else if (element instanceof IViewSlot) {
+            return (IViewSlot) element;
+        } else if (element.getNmsWrapper() == null) {
+            OilElementWrapper slotWrapper = element instanceof IInteractableUIElement?new OilInteractableElementWrapper((IInteractableUIElement) element):new OilElementWrapper(element);
+            element.setNmsWrapper(slotWrapper);
+            return slotWrapper;
+        } else {
+            return (IViewSlot) element.getNmsWrapper();
+        }
+    }
+
+    public static IUIElement toOil(IViewSlot slot) {
+        if (slot instanceof OilElementWrapper) {
+            return ((OilElementWrapper) slot).getElement();
+        } else {
+            return slot;
+        }
+    }
+
+    public static org.bukkit.inventory.ItemStack toBukkit(ItemStack itemStack) {
+        return CraftItemStack.asCraftMirror(itemStack);
+    }
+
+    public static ItemStack toNMS(org.bukkit.inventory.ItemStack itemStack) {
+        return CraftItemStack.asNMSCopy(itemStack);
+    }
+
+
+    public static World toNMS(org.bukkit.World world) {
+        if (world instanceof CraftWorld) {
+            return ((CraftWorld) world).getHandle();
+        } else {
+            throw new IllegalStateException("Do not know how to convert " + world.getClass().getCanonicalName() + " to World (NMS)");
+        }
+    }
+
+    public static InventoryClickType toNMS(ClickType type) {
+        return clickTypeOilToNMSMap.get(type);
+    }
+
+    public static ClickType toOil(InventoryClickType type) {
+        return clickTypeNMSToOilMap.get(type);
+    }
+
+    public static Material toBukkit(Item item) {
+        return CraftMagicNumbers.getMaterial(item);
+    }
+
+    public static Material toBukkit(Block block) {
+        return CraftMagicNumbers.getMaterial(block);
+    }
+    public static Block toNMS(Material material) {
+        return CraftMagicNumbers.getBlock(material);
+    }
+    public static BlockFace toBukkit(EnumDirection dir) {
+        return CraftBlock.notchToBlockFace(dir);
+    }
+    public static EnumDirection toNMS(BlockFace face) {
+        return CraftBlock.blockFaceToNotch(face);
+    }
+
+    public static BlockPosition toNMS(Location l) {
+        return new BlockPosition(l.getBlockX(), l.getBlockY(), l.getBlockZ());
+    }
+
+    public static Location toBukkit(World w, BlockPosition pos) {
+        return new Location(w.getWorld() , pos.getX(),  pos.getY(), pos.getZ());
+    }
+
+    public static org.bukkit.block.BlockState toBukkit(IBlockData state) {
+        return new CraftBlockState(CraftMagicNumbers.getMaterial(state.getBlock()));
+    }
+
+    public static InteractionResult toOil(net.minecraft.server.EnumInteractionResult nms) {
+        switch (nms) {
+            case SUCCESS:
+                return InteractionResult.SUCCESS;
+            case PASS:
+                return InteractionResult.PASS;
+            case FAIL:
+                return InteractionResult.FAIL;
+            default:
+                return InteractionResult.NONE;
+        }
+    }
+
+
+
+    public static net.minecraft.server.EnumInteractionResult toNMS(InteractionResult oil) {
+        switch (oil) {
+            case SUCCESS:
+                return net.minecraft.server.EnumInteractionResult.SUCCESS;
+            case FAIL:
+                return net.minecraft.server.EnumInteractionResult.FAIL;
+            case PASS:
+            case NONE:
+            default:
+                return net.minecraft.server.EnumInteractionResult.PASS;
+        }
+    }
+
+    public static NotImplementedException NotImplementedException() {
+        return new NotImplementedException("If you see that message sirati97 with an error log");
+    }
+}
diff --git a/src/main/java/org/oilmod/spigot/util/RealOilUtil.java b/src/main/java/org/oilmod/spigot/util/RealOilUtil.java
new file mode 100644
index 00000000..afed9b74
--- /dev/null
+++ b/src/main/java/org/oilmod/spigot/util/RealOilUtil.java
@@ -0,0 +1,470 @@
+package org.oilmod.spigot.util;
+
+import com.google.common.base.Predicate;
+import org.oilmod.api.util.NMSKey;
+import org.oilmod.api.util.OilKey;
+import org.oilmod.api.util.OilUtil;
+import gnu.trove.map.hash.THashMap;
+import net.minecraft.server.*;
+import net.minecraft.server.Item;
+import org.bukkit.Bukkit;
+import org.bukkit.Location;
+import org.bukkit.Material;
+import org.bukkit.World;
+import org.bukkit.block.BlockState;
+import org.bukkit.craftbukkit.CraftChunk;
+import org.bukkit.craftbukkit.block.CraftBlock;
+import org.bukkit.craftbukkit.entity.CraftHumanEntity;
+import org.bukkit.craftbukkit.entity.CraftLivingEntity;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
+import org.bukkit.entity.*;
+import org.bukkit.entity.Entity;
+import org.bukkit.entity.minecart.CommandMinecart;
+import org.bukkit.entity.minecart.ExplosiveMinecart;
+import org.bukkit.entity.minecart.HopperMinecart;
+import org.bukkit.entity.minecart.PoweredMinecart;
+import org.bukkit.entity.minecart.RideableMinecart;
+import org.bukkit.entity.minecart.SpawnerMinecart;
+import org.bukkit.entity.minecart.StorageMinecart;
+import org.bukkit.event.block.BlockBreakEvent;
+import org.bukkit.event.block.BlockMultiPlaceEvent;
+import org.bukkit.event.block.BlockPlaceEvent;
+
+import javax.annotation.Nullable;
+import java.util.List;
+import java.util.Map;
+import java.util.Random;
+
+/**
+ * Created by sirati97 on 12.03.2016.
+ */
+public class RealOilUtil extends OilUtil.UtilImpl {
+    private final Predicate<net.minecraft.server.Entity> entityPredicate = new Predicate<net.minecraft.server.Entity>() {
+        @Override
+        public boolean apply(@Nullable net.minecraft.server.Entity entity) {
+            return entity != null && (!(entity instanceof EntityLiving) || entity.isInteractable()) && (!(entity instanceof EntityHuman) || !((EntityHuman)entity).isSpectator());
+        }
+    };
+
+    @Override
+    protected org.bukkit.inventory.ItemStack[] getDrops(org.bukkit.block.Block block) {
+        return getDropsFortune(block, 0);
+    }
+
+    @Override
+    protected org.bukkit.inventory.ItemStack[] getDropsSilktouch(org.bukkit.block.Block block) {
+        Block nmsBlock = ((CraftBlock) block).getNMSBlock();
+        return new org.bukkit.inventory.ItemStack[]{CraftItemStack.asCraftMirror(nmsBlock.getDropSilktouch(nmsBlock.fromLegacyData(block.getData())))};
+    }
+
+    @Override
+    protected org.bukkit.inventory.ItemStack[] getDropsFortune(org.bukkit.block.Block block, int lv) {
+        CraftBlock craftBlock = (CraftBlock) block;
+        CraftChunk craftChunk = (CraftChunk) craftBlock.getChunk();
+        Block nmsBlock = craftBlock.getNMSBlock();
+        ItemStack[] resultNms = nmsBlock.getDrops(craftChunk.getHandle().getWorld(), toBlockPosition(block), nmsBlock.fromLegacyData(block.getData()), lv);
+        org.bukkit.inventory.ItemStack[] result = new org.bukkit.inventory.ItemStack[resultNms.length];
+        for (int i = 0; i < resultNms.length; i++) {
+            result[i] = CraftItemStack.asCraftMirror(resultNms[i]);
+        }
+        return result;
+    }
+
+    @Override
+    protected org.bukkit.inventory.ItemStack getRandomValidVariation(Material material, Random random) {
+        ItemStack itemStack = CraftItemStack.asNMSCopy(new org.bukkit.inventory.ItemStack(material));
+        Item item = itemStack.getItem();
+        int newData = 0;
+        if (item instanceof ItemBlock) {
+            Block block = ((ItemBlock) item).getBlock();
+            BlockStateList stateList = block.s();
+            newData = block.getDropData(stateList.a().get(random.nextInt(stateList.a().size())));
+        }
+        itemStack.setData(newData);
+        return CraftItemStack.asCraftMirror(itemStack);
+    }
+
+    @Override
+    protected boolean canBreak(Player player, org.bukkit.block.Block block) {
+        BlockBreakEvent event = new BlockBreakEvent(block, player);
+        Bukkit.getPluginManager().callEvent(event);
+        return !event.isCancelled();
+    }
+
+    @Override
+    protected boolean canPlace(Player player, org.bukkit.block.Block block, BlockState blockState, org.bukkit.block.Block block1, org.bukkit.inventory.ItemStack itemStack) {
+        BlockPlaceEvent event = new BlockPlaceEvent(block, blockState, block1, itemStack, player, true); //TODO: find hand
+        Bukkit.getPluginManager().callEvent(event);
+        return !event.isCancelled() && event.canBuild();
+    }
+
+
+    @Override
+    protected boolean canMultiPlace(Player player, List<BlockState> states, org.bukkit.block.Block clicked, org.bukkit.inventory.ItemStack itemInHand) {
+        BlockPlaceEvent event = new BlockMultiPlaceEvent(states, clicked, itemInHand, player, true);
+        Bukkit.getPluginManager().callEvent(event);
+        return !event.isCancelled() && event.canBuild();
+    }
+
+    @Override
+    protected <T extends Entity> List<T> getNearbyEntities(Location loc1, Location loc2, Class<T> entityClass) {
+        AxisAlignedBB box = new AxisAlignedBB(loc1.getX(), loc1.getY(), loc1.getZ(), loc2.getX(), loc2.getY(), loc2.getZ());
+        List<net.minecraft.server.Entity> notchEntityList = OilSpigotUtil.toNMS(loc1.getWorld()).a(getMappedNMSClass(entityClass), box, entityPredicate);
+        List<T> bukkitEntityList = new java.util.ArrayList<>(notchEntityList.size());
+
+        for (net.minecraft.server.Entity e : notchEntityList) {
+            Entity bukkitEntity = e.getBukkitEntity();
+            if (entityClass.isInstance(bukkitEntity)) {
+                //noinspection unchecked (is is checked via reflection...)
+                bukkitEntityList.add((T) bukkitEntity);
+            }
+        }
+        return bukkitEntityList;
+    }
+
+    @Override
+    protected void setLastDamager(LivingEntity entity, LivingEntity source) {
+        damageEntity(entity, 0, source);
+    }
+
+    @Override
+    protected boolean damageEntity(LivingEntity entity, double amount, LivingEntity source) {
+        DamageSource reason = DamageSource.GENERIC;
+
+        if (source instanceof HumanEntity) {
+            reason = DamageSource.playerAttack(((CraftHumanEntity) source).getHandle());
+        } else if (source != null) {
+            reason = DamageSource.mobAttack(((CraftLivingEntity) source).getHandle());
+        }
+        return ((CraftLivingEntity) entity).getHandle().damageEntity(reason, (float) amount);
+    }
+
+    @Override
+    protected long getWorldTicksPlayed(World world) {
+        net.minecraft.server.World nmsWorld = OilSpigotUtil.toNMS(world);
+        return nmsWorld.worldData.getTime();
+    }
+
+    private final Map<Class<? extends Entity>, Class<? extends net.minecraft.server.Entity>> entityBukkitNMSClassMapCache = new THashMap<>(50);
+    @Override //TODO: why is this cache a thing. shouldn't if be faster?! o well maybe its because of reflection. benchmark this
+    protected Class<? extends net.minecraft.server.Entity> getMappedNMSClass(Class<? extends Entity> bukkitClass) {
+        Class<? extends net.minecraft.server.Entity> result = entityBukkitNMSClassMapCache.get(bukkitClass);
+        if (result == null) {
+            result = mapToNMS(bukkitClass);
+            entityBukkitNMSClassMapCache.put(bukkitClass, result);
+        }
+        return result;
+    }
+
+    @Override
+    protected NMSKey registerOilKey(OilKey key) {
+        return new MinecraftKey(key.getMod().getInternalName(), key.getKeyString());
+    }
+
+    private BlockPosition toBlockPosition(org.bukkit.block.Block block) {
+        return new BlockPosition(block.getX(), block.getY(), block.getZ());
+    }
+
+    //OilSpigot KEEPSYNC public static CraftEntity.getEntity(CraftServer server, Entity entity);
+    public Class<? extends net.minecraft.server.Entity> mapToNMS(Class<? extends Entity> bukkitClass) {
+        /**
+         * Order is *EXTREMELY* important -- keep it right! =D
+         */
+        if (LivingEntity.class.isAssignableFrom(bukkitClass)) {
+            //Players
+            if (HumanEntity.class.isAssignableFrom(bukkitClass)) {
+                if (Player.class.isAssignableFrom(bukkitClass)) {
+                    return EntityPlayer.class;
+                }
+                return EntityHuman.class;
+            }
+            // Water Animals
+            else if (WaterMob.class.isAssignableFrom(bukkitClass)) {
+                if (Squid.class.isAssignableFrom(bukkitClass)) {
+                    return EntitySquid.class;
+                }
+                return EntityWaterAnimal.class;
+            } else if (Creature.class.isAssignableFrom(bukkitClass)) {
+                // Animals
+                if (Tameable.class.isAssignableFrom(bukkitClass)) { //in bukkit tameable and animal don't derive from each other
+                    if (Wolf.class.isAssignableFrom(bukkitClass)) {
+                        return EntityWolf.class;
+                    } else if (Ocelot.class.isAssignableFrom(bukkitClass)) {
+                        return EntityOcelot.class;
+                    }
+                    return EntityTameableAnimal.class;
+                } else if (Animals.class.isAssignableFrom(bukkitClass)) {
+                    if (Chicken.class.isAssignableFrom(bukkitClass)) {
+                        return EntityChicken.class;
+                    } else if (Cow.class.isAssignableFrom(bukkitClass)) {
+                        if (MushroomCow.class.isAssignableFrom(bukkitClass)) {
+                            return EntityMushroomCow.class;
+                        }
+                        return EntityCow.class;
+                    } else if (Pig.class.isAssignableFrom(bukkitClass)) {
+                        return EntityPig.class;
+                    } else if (Sheep.class.isAssignableFrom(bukkitClass)) {
+                        return EntitySheep.class;
+                    } else if (Horse.class.isAssignableFrom(bukkitClass)) {
+                        if (ChestedHorse.class.isAssignableFrom(bukkitClass)) {
+                            if (Donkey.class.isAssignableFrom(bukkitClass)) {
+                                return EntityHorseDonkey.class;
+                            } else if (Mule.class.isAssignableFrom(bukkitClass)) {
+                                return EntityHorseMule.class;
+                            } else if (Llama.class.isAssignableFrom(bukkitClass)) {
+                                return EntityLlama.class;
+                            } else if (Horse.class.isAssignableFrom(bukkitClass)) {
+                                return EntityHorse.class;
+                            }
+                            return EntityHorseChestedAbstract.class;
+                        } else if (SkeletonHorse.class.isAssignableFrom(bukkitClass)) {
+                            return EntityHorseSkeleton.class;
+                        } else if (ZombieHorse.class.isAssignableFrom(bukkitClass)) {
+                            return EntityHorseZombie.class;
+                        }
+                        return EntityHorseAbstract.class;
+                    } else if (Rabbit.class.isAssignableFrom(bukkitClass)) {
+                        return EntityRabbit.class;
+                    } else if (PolarBear.class.isAssignableFrom(bukkitClass)) {
+                        return EntityPolarBear.class;
+                    }
+                    return EntityAnimal.class;
+                }
+                // Monsters
+                else if (Monster.class.isAssignableFrom(bukkitClass)) {
+                    if (Zombie.class.isAssignableFrom(bukkitClass)) {
+                        if (PigZombie.class.isAssignableFrom(bukkitClass)) {
+                            return EntityPigZombie.class;
+                        } else if (Husk.class.isAssignableFrom(bukkitClass)) {
+                            return EntityZombieHusk.class;
+                        } else if (ZombieVillager.class.isAssignableFrom(bukkitClass)) {
+                            return EntityZombieVillager.class;
+                        }
+                        return EntityZombie.class;
+                    } else if (Creeper.class.isAssignableFrom(bukkitClass)) {
+                        return EntityCreeper.class;
+                    } else if (Enderman.class.isAssignableFrom(bukkitClass)) {
+                        return EntityEnderman.class;
+                    } else if (Silverfish.class.isAssignableFrom(bukkitClass)) {
+                        return EntitySilverfish.class;
+                    } else if (Giant.class.isAssignableFrom(bukkitClass)) {
+                        return EntityGiantZombie.class;
+                    } else if (Skeleton.class.isAssignableFrom(bukkitClass)) {
+                        if (Stray.class.isAssignableFrom(bukkitClass)) {
+                            return EntitySkeletonStray.class;
+                        } else if (WitherSkeleton.class.isAssignableFrom(bukkitClass)) {
+                            return EntitySkeletonWither.class;
+                        } else if (Skeleton.class.isAssignableFrom(bukkitClass)) {
+                            return EntitySkeleton.class;
+                        }
+                        return EntitySkeletonAbstract.class;
+                    } else if (Blaze.class.isAssignableFrom(bukkitClass)) {
+                        return EntityBlaze.class;
+                    } else if (Witch.class.isAssignableFrom(bukkitClass)) {
+                        return EntityWitch.class;
+                    } else if (Wither.class.isAssignableFrom(bukkitClass)) {
+                        return EntityWitch.class;
+                    } else if (Spider.class.isAssignableFrom(bukkitClass)) {
+                        if (CaveSpider.class.isAssignableFrom(bukkitClass)) {
+                            return EntityCaveSpider.class;
+                        }
+                        return EntitySpider.class;
+                    } else if (Endermite.class.isAssignableFrom(bukkitClass)) {
+                        return EntityEndermite.class;
+                    } else if (Guardian.class.isAssignableFrom(bukkitClass)) {
+                        if (ElderGuardian.class.isAssignableFrom(bukkitClass)) {
+                            return EntityGuardianElder.class;
+                        }
+                        return EntityGuardian.class;
+                    } else if (Vex.class.isAssignableFrom(bukkitClass)) {
+                        return EntityVex.class;
+                    } else if (Illager.class.isAssignableFrom(bukkitClass)) {
+                        if (Spellcaster.class.isAssignableFrom(bukkitClass)) {
+                            if (Evoker.class.isAssignableFrom(bukkitClass)) {
+                                return EntityEvoker.class;
+                            } else if (Illusioner.class.isAssignableFrom(bukkitClass)) {
+                                return EntityIllagerIllusioner.class;
+                            }
+                            return EntityIllagerWizard.class;
+                        } else if (Vindicator.class.isAssignableFrom(bukkitClass)) {
+                            return EntityVindicator.class;
+                        }
+                        return EntityIllagerAbstract.class;
+                    }
+                    return EntityMonster.class;
+                }
+                // Passive
+                else if (Golem.class.isAssignableFrom(bukkitClass)) {
+                    if (Snowman.class.isAssignableFrom(bukkitClass)) {
+                        return EntitySnowman.class;
+                    } else if (IronGolem.class.isAssignableFrom(bukkitClass)) {
+                        return EntityIronGolem.class;
+                    } else if (Shulker.class.isAssignableFrom(bukkitClass)) {
+                        return EntityShulker.class;
+                    }
+                    return EntityGolem.class;
+                } else if (Villager.class.isAssignableFrom(bukkitClass)) {
+                    return EntityVillager.class;
+                }
+                return EntityCreature.class;
+            }
+            // Slimes are a special (and broken) case
+            else if (Slime.class.isAssignableFrom(bukkitClass)) {
+                if (MagmaCube.class.isAssignableFrom(bukkitClass)) {
+                    return EntityMagmaCube.class;
+                }
+                return EntitySlime.class;
+            }
+            // Flying
+            else if (Flying.class.isAssignableFrom(bukkitClass)) {
+                if (Ghast.class.isAssignableFrom(bukkitClass)) {
+                    return EntityGhast.class;
+                }
+                return EntityFlying.class;
+            } else if (EnderDragon.class.isAssignableFrom(bukkitClass)) {
+                return EntityEnderDragon.class;
+            }
+            // Ambient
+            else if (Ambient.class.isAssignableFrom(bukkitClass)) {
+                if (Bat.class.isAssignableFrom(bukkitClass)) {
+                    return EntityBat.class;
+                }
+                return EntityAmbient.class;
+            } else if (ArmorStand.class.isAssignableFrom(bukkitClass)) {
+                return EntityArmorStand.class;
+            }
+            return EntityLiving.class;
+        }
+        //Complex Part
+        else if (ComplexEntityPart.class.isAssignableFrom(bukkitClass)) {
+            if (EnderDragonPart.class.isAssignableFrom(bukkitClass)) {
+                return EntityComplexPart.class; //same as default
+            }
+            return EntityComplexPart.class;
+        }
+        //XP
+        else if (ExperienceOrb.class.isAssignableFrom(bukkitClass)) {
+            return EntityExperienceOrb.class;
+        }
+        //Projectile
+        else if (Projectile.class.isAssignableFrom(bukkitClass)) {
+            if (Arrow.class.isAssignableFrom(bukkitClass)) {
+                if (TippedArrow.class.isAssignableFrom(bukkitClass)) {
+                    return EntityTippedArrow.class;
+                } else if (SpectralArrow.class.isAssignableFrom(bukkitClass)) {
+                    return EntitySpectralArrow.class;
+                }
+                return EntityArrow.class;
+            } else if (Egg.class.isAssignableFrom(bukkitClass)) {
+                return EntityEgg.class;
+            } else if (Snowball.class.isAssignableFrom(bukkitClass)) {
+                return EntitySnowball.class;
+            } else if (ThrownPotion.class.isAssignableFrom(bukkitClass)) {
+                if (SplashPotion.class.isAssignableFrom(bukkitClass)) {
+                    return EntityPotion.class; //same as default
+                } else if (LingeringPotion.class.isAssignableFrom(bukkitClass)) {
+                    return EntityPotion.class; //same as default
+                }
+                return EntityPotion.class;
+            } else if (EnderPearl.class.isAssignableFrom(bukkitClass)) {
+                return EntityEnderPearl.class;
+            } else if (ThrownExpBottle.class.isAssignableFrom(bukkitClass)) {
+                return EntityThrownExpBottle.class;
+            } else if (Fireball.class.isAssignableFrom(bukkitClass)) {
+                if (SmallFireball.class.isAssignableFrom(bukkitClass)) {
+                    return EntitySmallFireball.class;
+                } else if (LargeFireball.class.isAssignableFrom(bukkitClass)) {
+                    return EntityLargeFireball.class;
+                } else if (WitherSkull.class.isAssignableFrom(bukkitClass)) {
+                    return EntityWitherSkull.class;
+                } else if (DragonFireball.class.isAssignableFrom(bukkitClass)) {
+                    return EntityDragonFireball.class;
+                }
+                return EntityFireball.class;
+            }else if (ShulkerBullet.class.isAssignableFrom(bukkitClass)) {//ShulkerBullet is up here as it is a bukkit projectile
+                return EntityShulkerBullet.class;
+            } else if (LlamaSpit.class.isAssignableFrom(bukkitClass)) { //LamaSpit is up here as it is a bukkit projectile
+                return EntityLlamaSpit.class;
+            }
+            return EntityProjectile.class;
+        }
+        //Boat
+        else if (Boat.class.isAssignableFrom(bukkitClass)) {
+            return EntityBoat.class;
+        }
+        //Falling Block
+        else if (FallingBlock.class.isAssignableFrom(bukkitClass)) {
+            return EntityFallingBlock.class;
+        }
+        //EnderSignal
+        else if (EnderSignal.class.isAssignableFrom(bukkitClass)) {
+            return EntityEnderSignal.class;
+        }
+        //EnderCrystal
+        else if (EnderCrystal.class.isAssignableFrom(bukkitClass)) {
+            return EntityEnderCrystal.class;
+        }
+        //Item
+        else if (org.bukkit.entity.Item.class.isAssignableFrom(bukkitClass)) {
+            return EntityItem.class;
+        }
+        //Fishing Hook
+        else if (FishHook.class.isAssignableFrom(bukkitClass)) {
+            return EntityFishingHook.class;
+        }
+        //Weather
+        else if (Weather.class.isAssignableFrom(bukkitClass)) {
+            if (LightningStrike.class.isAssignableFrom(bukkitClass)) {
+                return EntityLightning.class;
+            }
+            return EntityWeather.class;
+        }
+        //Minecarts
+        else if (Minecart.class.isAssignableFrom(bukkitClass)) {
+            if (PoweredMinecart.class.isAssignableFrom(bukkitClass)) {
+                return EntityMinecartFurnace.class;
+            } else if (StorageMinecart.class.isAssignableFrom(bukkitClass)) {
+                return EntityMinecartChest.class;
+            } else if (ExplosiveMinecart.class.isAssignableFrom(bukkitClass)) {
+                return EntityMinecartTNT.class;
+            } else if (HopperMinecart.class.isAssignableFrom(bukkitClass)) {
+                return EntityMinecartHopper.class;
+            } else if (SpawnerMinecart.class.isAssignableFrom(bukkitClass)) {
+                return EntityMinecartMobSpawner.class;
+            } else if (RideableMinecart.class.isAssignableFrom(bukkitClass)) {
+                return EntityMinecartRideable.class;
+            } else if (CommandMinecart.class.isAssignableFrom(bukkitClass)) {
+                return EntityMinecartCommandBlock.class;
+            }
+            return EntityMinecartAbstract.class;
+        }
+        //Hanging
+        else if (Hanging.class.isAssignableFrom(bukkitClass)) {
+            if (Painting.class.isAssignableFrom(bukkitClass)) {
+                return EntityPainting.class;
+            } else if (ItemFrame.class.isAssignableFrom(bukkitClass)) {
+                return EntityItemFrame.class;
+            } else if (LeashHitch.class.isAssignableFrom(bukkitClass)) {
+                return EntityLeash.class;
+            }
+            return EntityHanging.class;
+        }
+        //Primed TNT
+        else if (TNTPrimed.class.isAssignableFrom(bukkitClass)) {
+            return EntityTNTPrimed.class;
+        }
+        //Fireworks
+        else if (Firework.class.isAssignableFrom(bukkitClass)) {
+            return EntityFireworks.class;
+        }
+        //AreaEffectCloud
+        else if (AreaEffectCloud.class.isAssignableFrom(bukkitClass)) {
+            return EntityAreaEffectCloud.class;
+        }
+        //EvokerFangs
+        else if (EvokerFangs.class.isAssignableFrom(bukkitClass)) {
+            return EntityEvokerFangs.class;
+        }
+        return net.minecraft.server.Entity.class;
+    }
+}
diff --git a/src/main/java/org/spigotmc/Metrics.java b/src/main/java/org/spigotmc/Metrics.java
index a5fd59d5..53cabe97 100644
--- a/src/main/java/org/spigotmc/Metrics.java
+++ b/src/main/java/org/spigotmc/Metrics.java
@@ -121,7 +121,9 @@ public class Metrics {
      */
     private volatile Timer task = null;
 
-    public Metrics() throws IOException {
+    private String pluginName;
+    public Metrics(String pluginName) throws IOException {
+        this.pluginName = pluginName;
         // load the config
         configurationFile = getConfigFile();
         configuration = YamlConfiguration.loadConfiguration(configurationFile);
@@ -214,7 +216,7 @@ public class Metrics {
             }
 
             // Begin hitting the server with glorious data
-            task = new Timer("Spigot Metrics Thread", true);
+            task = new Timer(pluginName + " Metrics Thread", true);
 
             task.scheduleAtFixedRate(new TimerTask() {
                 private boolean firstPost = true;
@@ -344,7 +346,6 @@ public class Metrics {
      */
     private void postPlugin(final boolean isPing) throws IOException {
         // Server software specific section
-        String pluginName = "Spigot";
         boolean onlineMode = Bukkit.getServer().getOnlineMode(); // TRUE if online mode is enabled
         String pluginVersion = (Metrics.class.getPackage().getImplementationVersion() != null) ? Metrics.class.getPackage().getImplementationVersion() : "unknown";
         String serverVersion = Bukkit.getVersion();
diff --git a/src/main/java/org/spigotmc/SpigotConfig.java b/src/main/java/org/spigotmc/SpigotConfig.java
index 2cdd9aaf..7ad4ab16 100644
--- a/src/main/java/org/spigotmc/SpigotConfig.java
+++ b/src/main/java/org/spigotmc/SpigotConfig.java
@@ -28,6 +28,10 @@ import org.bukkit.configuration.ConfigurationSection;
 import org.bukkit.configuration.InvalidConfigurationException;
 import org.bukkit.configuration.file.YamlConfiguration;
 
+//OilSpigot start
+import org.oilmod.spigot.OilMain;
+//OilSpigot end
+
 public class SpigotConfig
 {
 
@@ -88,8 +92,9 @@ public class SpigotConfig
         {
             try
             {
-                metrics = new Metrics();
+                metrics = new Metrics("Spigot");
                 metrics.start();
+                OilMain.initMetrics(); //OilSpigot also send metrics for OilMod and OilSpigot!
             } catch ( IOException ex )
             {
                 Bukkit.getServer().getLogger().log( Level.SEVERE, "Could not start metrics service", ex );
diff --git a/src/main/java/org/spigotmc/WatchdogThread.java b/src/main/java/org/spigotmc/WatchdogThread.java
index 93dc6983..13efd5a6 100644
--- a/src/main/java/org/spigotmc/WatchdogThread.java
+++ b/src/main/java/org/spigotmc/WatchdogThread.java
@@ -24,7 +24,7 @@ public class WatchdogThread extends Thread
 
     private WatchdogThread(long timeoutTime, boolean restart)
     {
-        super( "Paper Watchdog Thread" );
+        super( "OilyPaper Watchdog Thread" );
         this.timeoutTime = timeoutTime;
         this.restart = restart;
         earlyWarningEvery = Math.min(PaperConfig.watchdogPrintEarlyWarningEvery, timeoutTime); // Paper
@@ -75,7 +75,7 @@ public class WatchdogThread extends Thread
                 log.log( Level.SEVERE, "The server has stopped responding!" );
                 log.log( Level.SEVERE, "Please report this to https://github.com/PaperMC/Paper/issues" );
                 log.log( Level.SEVERE, "Be sure to include ALL relevant console errors and Minecraft crash reports" );
-                log.log( Level.SEVERE, "Paper version: " + Bukkit.getServer().getVersion() );
+                log.log( Level.SEVERE, "OilyPaper version: " + Bukkit.getServer().getVersion() );
                 //
                 if(net.minecraft.server.World.haveWeSilencedAPhysicsCrash)
                 {
@@ -103,7 +103,7 @@ public class WatchdogThread extends Thread
                 }
                 // Paper end - Different message for short timeout
                 log.log( Level.SEVERE, "------------------------------" );
-                log.log( Level.SEVERE, "Server thread dump (Look for plugins here before reporting to Paper!):" );
+                log.log( Level.SEVERE, "Server thread dump (Look for plugins here before reporting to OilyPaper!):" );
                 dumpThread( ManagementFactory.getThreadMXBean().getThreadInfo( MinecraftServer.getServer().primaryThread.getId(), Integer.MAX_VALUE ), log );
                 log.log( Level.SEVERE, "------------------------------" );
                 //
diff --git a/src/test/java/org/oilmod/spigot/blocks/MaterialToolTest.java b/src/test/java/org/oilmod/spigot/blocks/MaterialToolTest.java
new file mode 100644
index 00000000..c29120af
--- /dev/null
+++ b/src/test/java/org/oilmod/spigot/blocks/MaterialToolTest.java
@@ -0,0 +1,108 @@
+package org.oilmod.spigot.blocks;
+
+import com.google.common.collect.Lists;
+import net.minecraft.server.Block;
+import net.minecraft.server.Blocks;
+import net.minecraft.server.ItemAxe;
+import net.minecraft.server.ItemPickaxe;
+import net.minecraft.server.ItemSpade;
+import net.minecraft.server.Material;
+import org.bukkit.support.AbstractTestingBase;
+import org.bukkit.support.Util;
+import org.junit.Before;
+import org.junit.BeforeClass;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameter;
+import org.junit.runners.Parameterized.Parameters;
+import org.oilmod.api.blocks.BlockType;
+import org.oilmod.spigot.OilMain;
+import org.oilmod.spigot.block.RealBlockTypeHelper;
+import org.oilmod.spigot.bukkit.stubs.OilBlockStub;
+import org.oilmod.spigot.util.OilSpigotUtil;
+
+import java.util.List;
+import java.util.Set;
+
+import static org.junit.Assert.*;
+import static org.hamcrest.Matchers.*;
+
+
+@RunWith(Parameterized.class)
+public class MaterialToolTest extends AbstractTestingBase {
+
+
+    public static void init() {
+        setup();
+        OilMain.init();
+        pickaxe = ItemPickaxe.BLOCKS;
+        axe = ItemAxe.BLOCKS;
+        shovel = ItemSpade.BLOCKS;
+    }
+
+    @Parameters(name= "{index}: {0}")
+    public static List<Object[]> data() {
+        init(); //beforeclass not called before this rip
+        List<Object[]> list = Lists.newArrayList();
+
+        for (Block block : Block.REGISTRY) {
+            list.add(new Object[] {block});
+        }
+        return list;
+    }
+
+    @Parameter
+    public Block block;
+
+    private static Set<Block> pickaxe;
+    private static Set<Block> axe;
+    private static Set<Block> shovel;
+    private static Set<Block> shears;
+    private static Set<Block> sword;
+
+    private BlockType oil() {
+        return block.getBlockData().getMaterial().getOilBlockType();
+    }
+
+    //KEEPSYNC took from ItemPickaxe
+    private boolean vanillaPickaxe() {
+        Material material = block.getBlockData().getMaterial();
+        return material == Material.ORE || material == Material.HEAVY || material == Material.STONE || pickaxe.contains(block);
+    }
+
+    //KEEPSYNC took from ItemAxe
+    private boolean vanillaAxe() {
+        Material material = block.getBlockData().getMaterial();
+        return material == Material.WOOD || material == Material.PLANT || material == Material.REPLACEABLE_PLANT || axe.contains(block);
+
+    }
+
+    //KEEPSYNC took from ItemSpade
+    private boolean vanillaShovel() {
+        Material material = block.getBlockData().getMaterial();
+        return shovel.contains(block);
+
+    }
+
+    private String getMessage() {
+        return block.a()+ "->" + block.getBlockData().getMaterial().getOilBlockType().getBlockTypeEnum().toString();
+    }
+
+    @Test
+    public void breakablePickaxe() {
+        assertEquals(getMessage(), vanillaPickaxe(), oil().breakablePickaxe(OilSpigotUtil.toBukkit(block)));
+    }
+
+    @Test
+    public void breakableAxe() {
+        assertEquals(getMessage(), vanillaAxe(), oil().breakableAxe(OilSpigotUtil.toBukkit(block)));
+    }
+
+    @Test
+    public void breakableShovel() {
+        assertEquals(getMessage(), vanillaShovel(), oil().breakableShovel(OilSpigotUtil.toBukkit(block)));
+    }
+
+    //TODO test for sword and shears
+}
\ No newline at end of file
diff --git a/src/test/java/org/oilmod/spigot/config/yaml/NBTYamlTest.java b/src/test/java/org/oilmod/spigot/config/yaml/NBTYamlTest.java
new file mode 100644
index 00000000..a9d01d91
--- /dev/null
+++ b/src/test/java/org/oilmod/spigot/config/yaml/NBTYamlTest.java
@@ -0,0 +1,21 @@
+package org.oilmod.spigot.config.yaml;
+
+import nbt.YBase;
+import org.bukkit.support.DummyServer;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+public class NBTYamlTest {
+
+    @BeforeClass
+    public static void setup() {
+        DummyServer.setup();
+        YBase.registerYAMLClasses();
+    }
+
+    @Test
+    public void start() {
+        DummyServer.setup();
+        //todo: add test
+    }
+}
-- 
2.14.2.windows.3

