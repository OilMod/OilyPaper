From 5f0ddb4dc26015ec8348482dc29492a5b084aae5 Mon Sep 17 00:00:00 2001
From: sirati97 <TheSirati97@gmail.com>
Date: Tue, 12 Mar 2019 16:10:54 +0000
Subject: [PATCH] resolving merge conflicts from applied patches

---
 .../net/minecraft/server/BlockPiston.java     |   2 +-
 .../bukkit/craftbukkit/block/CraftSkull.java  |   2 +-
 .../craftbukkit/entity/CraftHumanEntity.java  |  23 +
 .../craftbukkit/entity/CraftPlayer.java       |  19 +-
 .../craftbukkit/event/CraftEventFactory.java  |   2 +-
 .../craftbukkit/inventory/CraftItemStack.java |   2 +-
 .../bukkit/block/RealOilBlockState.java       |   2 +-
 .../org/oilmod/bukkit/inv2/Behaviour.java     |   9 +
 .../oilmod/bukkit/inv2/ContainerState.java    |  83 ++++
 .../org/oilmod/bukkit/inv2/Interaction.java   |  11 +
 .../oilmod/bukkit/inv2/InteractionType.java   |   4 +
 .../org/oilmod/bukkit/inv2/RealContainer.java | 469 ++++++++++++++++++
 .../org/oilmod/bukkit/inv2/SetOnlyView.java   |  15 +
 .../oilmod/bukkit/inv2/VanillaBehavior.java   |   6 +
 .../oilmod/bukkit/inv2/VanillaSlotView.java   |  56 +++
 .../org/oilmod/bukkit/inv2/VanillaView.java   |  15 +
 .../org/oilmod/bukkit/items/RealItem.java     |   3 +-
 .../oilmod/bukkit/items/RealItemStack.java    |  10 +
 .../org/oilmod/bukkit/util/RealOilUtil.java   |   2 +-
 19 files changed, 709 insertions(+), 26 deletions(-)
 create mode 100644 src/main/java/org/oilmod/bukkit/inv2/Behaviour.java
 create mode 100644 src/main/java/org/oilmod/bukkit/inv2/ContainerState.java
 create mode 100644 src/main/java/org/oilmod/bukkit/inv2/Interaction.java
 create mode 100644 src/main/java/org/oilmod/bukkit/inv2/InteractionType.java
 create mode 100644 src/main/java/org/oilmod/bukkit/inv2/RealContainer.java
 create mode 100644 src/main/java/org/oilmod/bukkit/inv2/SetOnlyView.java
 create mode 100644 src/main/java/org/oilmod/bukkit/inv2/VanillaBehavior.java
 create mode 100644 src/main/java/org/oilmod/bukkit/inv2/VanillaSlotView.java
 create mode 100644 src/main/java/org/oilmod/bukkit/inv2/VanillaView.java

diff --git a/src/main/java/net/minecraft/server/BlockPiston.java b/src/main/java/net/minecraft/server/BlockPiston.java
index 0f90172f..bd8ffc2f 100644
--- a/src/main/java/net/minecraft/server/BlockPiston.java
+++ b/src/main/java/net/minecraft/server/BlockPiston.java
@@ -217,7 +217,7 @@ public class BlockPiston extends BlockDirectional {
                     }
                 }
 
-                if (!flag1 && a(iblockdata1, world, blockposition1, enumdirection.opposite(), false, enumdirection) && (iblockdata1.o() == EnumPistonReaction.NORMAL || block == Blocks.PISTON || block == Blocks.STICKY_PISTON)) { // CraftBukkit - remove 'block.getMaterial() != Material.AIR' condition
+                if (!flag1 && a(iblockdata1, world, blockposition1, enumdirection.opposite(), false, enumdirection) && (iblockdata1.o() == EnumPistonReaction.NORMAL || block == Blocks.PISTON || block == Blocks.STICKY_PISTON)) { // CraftBukkit - remove 'block.getBlock() != Material.AIR' condition
                     this.a(world, blockposition, enumdirection, false);
                 }
             } else {
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CraftSkull.java b/src/main/java/org/bukkit/craftbukkit/block/CraftSkull.java
index f2865688..39b3f39a 100644
--- a/src/main/java/org/bukkit/craftbukkit/block/CraftSkull.java
+++ b/src/main/java/org/bukkit/craftbukkit/block/CraftSkull.java
@@ -108,7 +108,7 @@ public class CraftSkull extends CraftBlockEntityState<TileEntitySkull> implement
             case NORTH_NORTH_WEST:
                 return 15;
             default:
-                throw new IllegalArgumentException("Invalid BlockFace rotation: " + rotation);
+                throw new IllegalArgumentException("Invalid BlockFaceRep rotation: " + rotation);
         }
     }
 
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftHumanEntity.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftHumanEntity.java
index 8cf375ed..16c3a1c9 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftHumanEntity.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftHumanEntity.java
@@ -543,4 +543,27 @@ public class CraftHumanEntity extends CraftLivingEntity implements HumanEntity {
         getHandle().openSign(teSign);
     }
     // Paper end
+
+    //OilyPaper - start
+    /* moved here from craftplayer */
+    @Override
+    public void setSneaking(boolean sneak) {
+        getHandle().setSneaking(sneak);
+    }
+
+    @Override
+    public boolean isSneaking() {
+        return getHandle().isSneaking();
+    }
+
+    @Override
+    public boolean isSprinting() {
+        return getHandle().isSprinting();
+    }
+
+    @Override
+    public void setSprinting(boolean sprinting) {
+        getHandle().setSprinting(sprinting);
+    }
+    //OilyPaper - end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index d59d86ef..cbaab36e 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -668,25 +668,8 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
     }
     // Paper end
 
-    @Override
-    public void setSneaking(boolean sneak) {
-        getHandle().setSneaking(sneak);
-    }
-
-    @Override
-    public boolean isSneaking() {
-        return getHandle().isSneaking();
-    }
+    //OilyPaper - move sneak, sprint methods to humanentity
 
-    @Override
-    public boolean isSprinting() {
-        return getHandle().isSprinting();
-    }
-
-    @Override
-    public void setSprinting(boolean sprinting) {
-        getHandle().setSprinting(sprinting);
-    }
 
     @Override
     public void loadData() {
diff --git a/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java b/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
index dd9af4c2..bdc1189c 100644
--- a/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
+++ b/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
@@ -912,7 +912,7 @@ public class CraftEventFactory {
             hitBlock = entity.getBukkitEntity().getWorld().getBlockAt(blockposition.getX(), blockposition.getY(), blockposition.getZ());
         }
 
-        ProjectileHitEvent event = new ProjectileHitEvent((Projectile) entity.getBukkitEntity(), position.entity == null ? null : position.entity.getBukkitEntity(), hitBlock, position.direction == null ? null : CraftBlock.notchToBlockFace(position.direction)); // Paper - add BlockFace parameter
+        ProjectileHitEvent event = new ProjectileHitEvent((Projectile) entity.getBukkitEntity(), position.entity == null ? null : position.entity.getBukkitEntity(), hitBlock, position.direction == null ? null : CraftBlock.notchToBlockFace(position.direction)); // Paper - add BlockFaceRep parameter
         entity.world.getServer().getPluginManager().callEvent(event);
         return event;
     }
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemStack.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemStack.java
index 5a6834be..41b019c1 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemStack.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemStack.java
@@ -66,7 +66,7 @@ public  class CraftItemStack extends ItemStack { //OilSpigot PAIL removed final
         if (original.isEmpty()) {
             return new ItemStack(Material.AIR);
         }
-        ItemStack stack = new ItemStack(CraftMagicNumbers.getMaterial(original.getItem()), original.getCount(), (short) original.getData());
+        ItemStack stack = new ItemStack(CraftMagicNumbers.getBlock(original.getItem()), original.getCount(), (short) original.getData());
         if (hasItemMeta(original)) {
             stack.setItemMeta(getItemMeta(original));
         }
diff --git a/src/main/java/org/oilmod/bukkit/block/RealOilBlockState.java b/src/main/java/org/oilmod/bukkit/block/RealOilBlockState.java
index 760e28df..7c162fea 100644
--- a/src/main/java/org/oilmod/bukkit/block/RealOilBlockState.java
+++ b/src/main/java/org/oilmod/bukkit/block/RealOilBlockState.java
@@ -22,7 +22,7 @@ public class RealOilBlockState implements IBlockState {
     }
 
     @Override
-    public Material getMaterial() {
+    public Material getBlock() {
         return OilSpigotUtil.toBukkit(nms.getBlock());
     }
 
diff --git a/src/main/java/org/oilmod/bukkit/inv2/Behaviour.java b/src/main/java/org/oilmod/bukkit/inv2/Behaviour.java
new file mode 100644
index 00000000..ced3365b
--- /dev/null
+++ b/src/main/java/org/oilmod/bukkit/inv2/Behaviour.java
@@ -0,0 +1,9 @@
+package org.oilmod.bukkit.inv2;
+
+public interface Behaviour {
+    void QuickMove(int vanillaSlot);
+    void DropCarried();
+    void Drop(int vanillaSlot);
+    void CreativeClone(int vanillaSlot);
+
+}
diff --git a/src/main/java/org/oilmod/bukkit/inv2/ContainerState.java b/src/main/java/org/oilmod/bukkit/inv2/ContainerState.java
new file mode 100644
index 00000000..9d26d2f1
--- /dev/null
+++ b/src/main/java/org/oilmod/bukkit/inv2/ContainerState.java
@@ -0,0 +1,83 @@
+package org.oilmod.bukkit.inv2;
+
+import net.minecraft.server.ItemStack;
+import org.apache.commons.lang3.Validate;
+
+public class ContainerState {
+    private final int[] newStackSizes;
+    private final boolean[] drop;
+    private final ItemStack[] newStacks;
+    private final int size;
+    
+    public ContainerState(int size) {
+        newStackSizes = new int[size+1];
+        for (int i = 0; i <= size; i++) {
+            newStackSizes[i] = -1;
+        }
+        newStacks = new ItemStack[size+1];
+        drop = new boolean[size+1];
+        this.size = size;
+    }
+    
+    private void checkUntouched(int vanillaSlot) {
+        Validate.isTrue(newStacks[vanillaSlot]==null,  "Cannot set twice");
+        Validate.isTrue(newStackSizes[vanillaSlot]==-1, "Cannot change size twice");
+        Validate.isTrue(!drop[vanillaSlot], "Slot already marked for dropping");
+    }
+
+    public void setStack(int vanillaSlot, ItemStack stack) {
+        Validate.notNull(stack, "Cannot set to null");
+        checkUntouched(vanillaSlot);
+        newStacks[vanillaSlot] = stack;
+    }
+    
+    public void markChangedSize(int vanillaSlot, int newSize) {
+        checkUntouched(vanillaSlot);
+        newStackSizes[vanillaSlot] = newSize;
+    }
+
+    public void setSplitStack(int vanillaSlot, ItemStack stack, int toSubAndSet) {
+        setStack(vanillaSlot, stack);
+        newStackSizes[vanillaSlot] = toSubAndSet;
+    }
+
+    public void setEmpty(int vanillaSlot) {
+        setStack(vanillaSlot, ItemStack.a);
+    }
+
+    public void drop(int vanillaSlot, int amount) {
+        checkUntouched(vanillaSlot);
+        drop[vanillaSlot] = true;
+        newStackSizes[vanillaSlot]=amount;
+    }
+
+    public void dropAll(int vanillaSlot) {
+        setStack(vanillaSlot, ItemStack.a);
+        drop[vanillaSlot] = true;
+    }
+
+    //basically index size is used for the carried stack
+    public void setCarriedStack(ItemStack stack) {
+        setStack(size, stack);
+    }
+
+    public void markCarriedChangedSize(int newSize) {
+        markChangedSize(size, newSize);
+    }
+
+    public void setCarriedSplitStack(ItemStack stack, int toSubAndSet) {
+        setSplitStack(size, stack, toSubAndSet);
+    }
+
+    public void setCarriedEmpty() {
+        setEmpty(size);
+    }
+
+    public void dropCarried(int amount) {
+        drop(size, amount);
+    }
+
+    public void dropAllCarried() {
+        dropAll(size);
+    }
+}
diff --git a/src/main/java/org/oilmod/bukkit/inv2/Interaction.java b/src/main/java/org/oilmod/bukkit/inv2/Interaction.java
new file mode 100644
index 00000000..340351b2
--- /dev/null
+++ b/src/main/java/org/oilmod/bukkit/inv2/Interaction.java
@@ -0,0 +1,11 @@
+package org.oilmod.bukkit.inv2;
+
+public interface Interaction {
+    void execute();
+
+    boolean compare(Interaction to);
+
+    InteractionType getType();
+
+    int getVanillaSlot();
+}
diff --git a/src/main/java/org/oilmod/bukkit/inv2/InteractionType.java b/src/main/java/org/oilmod/bukkit/inv2/InteractionType.java
new file mode 100644
index 00000000..b864c289
--- /dev/null
+++ b/src/main/java/org/oilmod/bukkit/inv2/InteractionType.java
@@ -0,0 +1,4 @@
+package org.oilmod.bukkit.inv2;
+
+public enum InteractionType {
+}
diff --git a/src/main/java/org/oilmod/bukkit/inv2/RealContainer.java b/src/main/java/org/oilmod/bukkit/inv2/RealContainer.java
new file mode 100644
index 00000000..db33ca8c
--- /dev/null
+++ b/src/main/java/org/oilmod/bukkit/inv2/RealContainer.java
@@ -0,0 +1,469 @@
+package org.oilmod.bukkit.inv2;
+
+import net.minecraft.server.Container;
+import net.minecraft.server.EntityHuman;
+import net.minecraft.server.EntityPlayer;
+import net.minecraft.server.InventoryClickType;
+import net.minecraft.server.ItemStack;
+import net.minecraft.server.PacketPlayOutSetSlot;
+import net.minecraft.server.PlayerInventory;
+import net.minecraft.server.Slot;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
+import org.bukkit.event.Event;
+import org.bukkit.event.inventory.InventoryDragEvent;
+import org.bukkit.event.inventory.InventoryType;
+import org.bukkit.inventory.InventoryView;
+
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+
+@SuppressWarnings("Duplicates")
+public class RealContainer extends Container {
+
+    public ItemStack shiftClick(EntityHuman entityhuman, int i) {
+        Slot slot = (Slot) this.slots.get(i);
+
+        return slot != null ? slot.getItem() : ItemStack.a;
+    }
+
+    public ItemStack a(int slotId, int dragType, InventoryClickType inventoryclicktype, EntityHuman entityhuman) {
+        ItemStack itemstack = ItemStack.a;
+        PlayerInventory playerinventory = entityhuman.inventory;
+        ItemStack itemstack1;
+        int k;
+        ItemStack itemstack2;
+        int l;
+
+
+        //##################################################
+        //##################QUICK-CRAFT#####################
+        //##################################################
+        if (inventoryclicktype == InventoryClickType.QUICK_CRAFT) {
+            processQuickCraft(slotId, dragType, entityhuman, playerinventory);
+        } else if (this.g != 0) {
+            this.d();
+
+
+        } else {
+            Slot slot2;
+            int k1;
+
+            if ((inventoryclicktype == InventoryClickType.PICKUP || inventoryclicktype == InventoryClickType.QUICK_MOVE) && (dragType == 0 || dragType == 1)) {
+
+
+                //##################################################
+                //#################Drop-Carried#####################
+                //##################################################
+                if (slotId == -999) {
+                    processDropCarried(dragType, entityhuman, playerinventory);
+                }
+
+
+                //##################################################
+                //##################Quick-Move######################
+                //##################################################
+                else if (inventoryclicktype == InventoryClickType.QUICK_MOVE) {
+                    if (slotId < 0) {
+                        return ItemStack.a;
+                    }
+
+                    slot2 = (Slot) this.slots.get(slotId);
+                    if (slot2 == null || !slot2.isAllowed(entityhuman)) {
+                        return ItemStack.a;
+                    }
+
+                    for (itemstack2 = this.shiftClick(entityhuman, slotId); !itemstack2.isEmpty() && ItemStack.c(slot2.getItem(), itemstack2); itemstack2 = this.shiftClick(entityhuman, slotId)) {
+                        itemstack = itemstack2.cloneItemStack();
+                    }
+                }
+
+
+                //##################################################
+                //##################Normal-Click####################
+                //##################################################
+                else {
+                    if (slotId < 0) {
+                        return ItemStack.a;
+                    }
+
+                    itemstack = processNormalClick(slotId, dragType, entityhuman, itemstack, playerinventory);
+                }
+
+
+                //##################################################
+                //##################Number-Swap#####################
+                //##################################################
+            } else if (inventoryclicktype == InventoryClickType.SWAP && dragType >= 0 && dragType < 9) {
+                processNumberSwap(slotId, dragType, entityhuman, playerinventory);
+            }
+
+
+            //##################################################
+            //#################Creative-Clone###################
+            //##################################################
+            else if (inventoryclicktype == InventoryClickType.CLONE && entityhuman.abilities.canInstantlyBuild && playerinventory.getCarried().isEmpty() && slotId >= 0) {
+                processCreativeClone(slotId, playerinventory);
+            }
+
+
+            //##################################################
+            //######################Throw#######################
+            //##################################################
+            else if (inventoryclicktype == InventoryClickType.THROW && playerinventory.getCarried().isEmpty() && slotId >= 0) {
+                processDropSlot(slotId, dragType, entityhuman);
+            }
+
+
+            //##################################################
+            //####################Pickup-All####################
+            //##################################################
+            else if (inventoryclicktype == InventoryClickType.PICKUP_ALL && slotId >= 0) {
+                processPickupAll(slotId, dragType, entityhuman, playerinventory);
+            }
+        }
+
+        return itemstack;
+    }
+
+    private void processNumberSwap(int i, int j, EntityHuman entityhuman, PlayerInventory playerinventory) {
+        Slot slot2;
+        ItemStack itemstack2;
+        ItemStack itemstack1;
+        int k1;
+        slot2 = (Slot) this.slots.get(i);
+        itemstack2 = playerinventory.getItem(j);
+        itemstack1 = slot2.getItem();
+
+        //OilSpigot start
+        boolean requiresUpdate = !slot2.isAllowed(entityhuman) || (itemstack2 != null && !slot2.isAllowed(itemstack2));
+        //OilSpigot end
+
+        if (!itemstack2.isEmpty() || !itemstack1.isEmpty()) {
+            if (itemstack2.isEmpty()) {
+                if (slot2.isAllowed(entityhuman)) {
+                    playerinventory.setItem(j, itemstack1);
+                    slot2.b(itemstack1.getCount());
+                    slot2.set(ItemStack.a);
+                    slot2.a(entityhuman, itemstack1);
+                }
+            } else if (itemstack1.isEmpty()) {
+                if (slot2.isAllowed(itemstack2)) {
+                    k1 = slot2.getMaxStackSize(itemstack2);
+                    if (itemstack2.getCount() > k1) {
+                        slot2.set(itemstack2.cloneAndSubtract(k1));
+                    } else {
+                        slot2.set(itemstack2);
+                        playerinventory.setItem(j, ItemStack.a);
+                    }
+                }
+            } else if (slot2.isAllowed(entityhuman) && slot2.isAllowed(itemstack2)) {
+                k1 = slot2.getMaxStackSize(itemstack2);
+                if (itemstack2.getCount() > k1) {
+                    slot2.set(itemstack2.cloneAndSubtract(k1));
+                    slot2.a(entityhuman, itemstack1);
+                    if (!playerinventory.pickup(itemstack1)) {
+                        entityhuman.drop(itemstack1, true);
+                    }
+                } else {
+                    slot2.set(itemstack2);
+                    playerinventory.setItem(j, itemstack1);
+                    slot2.a(entityhuman, itemstack1);
+                }
+            }
+        }
+        //OilSpigot start //TODO: this is done to avoid async - be sure that it works
+        if (requiresUpdate && entityhuman instanceof EntityPlayer) {
+            ItemStack slotUpdated = slot2.getItem();
+            ((EntityPlayer) entityhuman).playerConnection.sendPacket(new PacketPlayOutSetSlot(this.windowId, slot2.rawSlotIndex, slotUpdated==null||slotUpdated.getCount()<1?null:slotUpdated));
+            ItemStack slot2Updated = playerinventory.getItem(j);
+            ((EntityPlayer) entityhuman).playerConnection.sendPacket(new PacketPlayOutSetSlot(this.windowId, hotbarSlotToPacketSlot(j), slot2Updated==null||slot2Updated.getCount()<1?null:slot2Updated));
+        }
+        //OilSpigot end
+    }
+
+    private void processPickupAll(int i, int j, EntityHuman entityhuman, PlayerInventory playerinventory) {
+        Slot slot2;
+        ItemStack itemstack2;
+        int l;
+        int k1;
+        int k;
+        slot2 = (Slot) this.slots.get(i);
+        itemstack2 = playerinventory.getCarried();
+        if (!itemstack2.isEmpty() && (slot2 == null || !slot2.hasItem() || !slot2.isAllowed(entityhuman))) {
+            l = j == 0 ? 0 : this.slots.size() - 1;
+            k1 = j == 0 ? 1 : -1;
+
+            for (int l1 = 0; l1 < 2; ++l1) {
+                for (int i2 = l; i2 >= 0 && i2 < this.slots.size() && itemstack2.getCount() < itemstack2.getMaxStackSize(); i2 += k1) {
+                    Slot slot3 = (Slot) this.slots.get(i2);
+
+                    if (slot3.hasItem() && a(slot3, itemstack2, true) && slot3.isAllowed(entityhuman) && this.a(itemstack2, slot3)) {
+                        ItemStack itemstack5 = slot3.getItem();
+
+                        if (l1 != 0 || itemstack5.getCount() != itemstack5.getMaxStackSize()) {
+                            k = Math.min(itemstack2.getMaxStackSize() - itemstack2.getCount(), itemstack5.getCount());
+                            ItemStack itemstack6 = slot3.a(k);
+
+                            itemstack2.add(k);
+                            if (itemstack6.isEmpty()) {
+                                slot3.set(ItemStack.a);
+                            }
+
+                            slot3.a(entityhuman, itemstack6);
+                        }
+                    }
+                }
+            }
+        }
+
+        this.b();
+    }
+
+    private void processDropSlot(int i, int j, EntityHuman entityhuman) {
+        Slot slot2;
+        ItemStack itemstack2;
+        slot2 = (Slot) this.slots.get(i);
+        if (slot2 != null && slot2.hasItem() && slot2.isAllowed(entityhuman)) {
+            itemstack2 = slot2.a(j == 0 ? 1 : slot2.getItem().getCount());
+            slot2.a(entityhuman, itemstack2);
+            entityhuman.drop(itemstack2, true);
+        }
+    }
+
+    private void processCreativeClone(int i, PlayerInventory playerinventory) {
+        Slot slot2;
+        ItemStack itemstack2;
+        slot2 = (Slot) this.slots.get(i);
+        if (slot2 != null && slot2.hasItem()) {
+            itemstack2 = slot2.getItem().cloneItemStack();
+            itemstack2.setCount(itemstack2.getMaxStackSize());
+            playerinventory.setCarried(itemstack2);
+        }
+    }
+
+    private ItemStack processNormalClick(int i, int j, EntityHuman entityhuman, ItemStack itemstack, PlayerInventory playerinventory) {
+        Slot slot2;
+        ItemStack itemstack2;
+        ItemStack itemstack1;
+        int k1;
+        slot2 = (Slot) this.slots.get(i);
+        if (slot2 != null) {
+            itemstack2 = slot2.getItem();
+            itemstack1 = playerinventory.getCarried();
+            if (!itemstack2.isEmpty()) {
+                itemstack = itemstack2.cloneItemStack();
+            }
+
+            //OilSpigot start
+            boolean requiresUpdate = itemstack1 != null && !slot2.isAllowed(itemstack1);
+            //OilSpigot end
+
+            if (itemstack2.isEmpty()) {
+                if (!itemstack1.isEmpty() && slot2.isAllowed(itemstack1)) {
+                    k1 = j == 0 ? itemstack1.getCount() : 1;
+                    if (k1 > slot2.getMaxStackSize(itemstack1)) {
+                        k1 = slot2.getMaxStackSize(itemstack1);
+                    }
+
+                    slot2.set(itemstack1.cloneAndSubtract(k1));
+                }
+            } else if (slot2.isAllowed(entityhuman)) {
+                if (itemstack1.isEmpty()) {
+                    if (itemstack2.isEmpty()) {
+                        slot2.set(ItemStack.a);
+                        playerinventory.setCarried(ItemStack.a);
+                    } else {
+                        k1 = j == 0 ? itemstack2.getCount() : (itemstack2.getCount() + 1) / 2;
+                        playerinventory.setCarried(slot2.a(k1));
+                        if (itemstack2.isEmpty()) {
+                            slot2.set(ItemStack.a);
+                        }
+
+                        slot2.a(entityhuman, playerinventory.getCarried());
+                    }
+                } else if (slot2.isAllowed(itemstack1)) {
+                    if (itemstack2.getItem() == itemstack1.getItem() && itemstack2.getData() == itemstack1.getData() && ItemStack.equals(itemstack2, itemstack1)) {
+                        k1 = j == 0 ? itemstack1.getCount() : 1;
+                        if (k1 > slot2.getMaxStackSize(itemstack1) - itemstack2.getCount()) {
+                            k1 = slot2.getMaxStackSize(itemstack1) - itemstack2.getCount();
+                        }
+
+                        if (k1 > itemstack1.getMaxStackSize() - itemstack2.getCount()) {
+                            k1 = itemstack1.getMaxStackSize() - itemstack2.getCount();
+                        }
+
+                        itemstack1.subtract(k1);
+                        itemstack2.add(k1);
+                    } else if (itemstack1.getCount() <= slot2.getMaxStackSize(itemstack1)) {
+                        slot2.set(itemstack1);
+                        playerinventory.setCarried(itemstack2);
+                    }
+                } else if (itemstack2.getItem() == itemstack1.getItem() && itemstack1.getMaxStackSize() > 1 && (!itemstack2.usesData() || itemstack2.getData() == itemstack1.getData()) && ItemStack.equals(itemstack2, itemstack1) && !itemstack2.isEmpty()) {
+                    k1 = itemstack2.getCount();
+                    if (k1 + itemstack1.getCount() <= itemstack1.getMaxStackSize()) {
+                        itemstack1.add(k1);
+                        itemstack2 = slot2.a(k1);
+                        if (itemstack2.isEmpty()) {
+                            slot2.set(ItemStack.a);
+                        }
+
+                        slot2.a(entityhuman, playerinventory.getCarried());
+                    }
+                }
+            }
+
+            slot2.f();
+
+            //OilSpigot start //TODO: this is done to avoid async - be sure that it works
+            if (requiresUpdate && entityhuman instanceof EntityPlayer) {
+                ItemStack slotUpdated = slot2.getItem();
+                ((EntityPlayer) entityhuman).playerConnection.sendPacket(new PacketPlayOutSetSlot(this.windowId, slot2.rawSlotIndex, slotUpdated.isEmpty()?ItemStack.a:slotUpdated));
+                ItemStack carriedUpdated = playerinventory.getCarried();
+                ((EntityPlayer) entityhuman).playerConnection.sendPacket(new PacketPlayOutSetSlot(-1, -1, carriedUpdated.isEmpty()?ItemStack.a:carriedUpdated));
+            }
+            //OilSpigot end
+
+            // CraftBukkit start - Make sure the client has the right slot contents
+            if (entityhuman instanceof EntityPlayer && slot2.getMaxStackSize() != 64) {
+                ((EntityPlayer) entityhuman).playerConnection.sendPacket(new PacketPlayOutSetSlot(this.windowId, slot2.rawSlotIndex, slot2.getItem()));
+                // Updating a crafting inventory makes the client reset the result slot, have to send it again
+                if (this.getBukkitView().getType() == InventoryType.WORKBENCH || this.getBukkitView().getType() == InventoryType.CRAFTING) {
+                    ((EntityPlayer) entityhuman).playerConnection.sendPacket(new PacketPlayOutSetSlot(this.windowId, 0, this.getSlot(0).getItem()));
+                }
+            }
+            // CraftBukkit end
+        }
+        return itemstack;
+    }
+
+    private void processDropCarried(int j, EntityHuman entityhuman, PlayerInventory playerinventory) {
+        if (!playerinventory.getCarried().isEmpty()) {
+            if (j == 0) {
+                // CraftBukkit start
+                ItemStack carried = playerinventory.getCarried();
+                playerinventory.setCarried(ItemStack.a);
+                entityhuman.drop(carried, true);
+                // CraftBukkit start
+            }
+
+            if (j == 1) {
+                entityhuman.drop(playerinventory.getCarried().cloneAndSubtract(1), true);
+            }
+        }
+    }
+
+    private void processQuickCraft(int i, int j, EntityHuman entityhuman, PlayerInventory playerinventory) {
+        ItemStack itemstack1;
+        ItemStack itemstack2;
+        int l;
+        int k;
+        int i1 = this.g;
+
+        this.g = c(j);
+        if ((i1 != 1 || this.g != 2) && i1 != this.g) {
+            this.d();
+        } else if (playerinventory.getCarried().isEmpty()) {
+            this.d();
+        } else if (this.g == 0) {
+            this.dragType = b(j);
+            if (a(this.dragType, entityhuman)) {
+                this.g = 1;
+                this.h.clear();
+            } else {
+                this.d();
+            }
+        } else if (this.g == 1) {
+            Slot slot = i < this.slots.size() ? this.slots.get(i) : null; // Paper - Ensure drag in bounds
+
+            itemstack1 = playerinventory.getCarried();
+            if (slot != null && a(slot, itemstack1, true) && slot.isAllowed(itemstack1) && (this.dragType == 2 || itemstack1.getCount() > this.h.size()) && this.b(slot)) {
+                this.h.add(slot);
+            }
+        } else if (this.g == 2) {
+            if (!this.h.isEmpty()) {
+                itemstack2 = playerinventory.getCarried().cloneItemStack();
+                l = playerinventory.getCarried().getCount();
+                Iterator iterator = this.h.iterator();
+
+                Map<Integer, ItemStack> draggedSlots = new HashMap<Integer, ItemStack>(); // CraftBukkit - Store slots from drag in map (raw slot id -> new stack)
+                while (iterator.hasNext()) {
+                    Slot slot1 = (Slot) iterator.next();
+                    ItemStack itemstack3 = playerinventory.getCarried();
+
+                    if (slot1 != null && a(slot1, itemstack3, true) && slot1.isAllowed(itemstack3) && (this.dragType == 2 || itemstack3.getCount() >= this.h.size()) && this.b(slot1)) {
+                        ItemStack itemstack4 = itemstack2.cloneItemStack();
+                        int j1 = slot1.hasItem() ? slot1.getItem().getCount() : 0;
+
+                        a(this.h, this.dragType, itemstack4, j1);
+                        k = Math.min(itemstack4.getMaxStackSize(), slot1.getMaxStackSize(itemstack4));
+                        if (itemstack4.getCount() > k) {
+                            itemstack4.setCount(k);
+                        }
+
+                        l -= itemstack4.getCount() - j1;
+                        // slot1.set(itemstack4);
+                        draggedSlots.put(slot1.rawSlotIndex, itemstack4); // CraftBukkit - Put in map instead of setting
+                    }
+                }
+
+                // CraftBukkit start - InventoryDragEvent
+                InventoryView view = getBukkitView();
+                org.bukkit.inventory.ItemStack newcursor = CraftItemStack.asCraftMirror(itemstack2);
+                newcursor.setAmount(l);
+                Map<Integer, org.bukkit.inventory.ItemStack> eventmap = new HashMap<Integer, org.bukkit.inventory.ItemStack>();
+                for (Map.Entry<Integer, ItemStack> ditem : draggedSlots.entrySet()) {
+                    //OilSpigot - use asCraftMirror and clone
+                    eventmap.put(ditem.getKey(), CraftItemStack.asCraftMirror(ditem.getValue()).clone());
+                }
+
+                // It's essential that we set the cursor to the new value here to prevent item duplication if a plugin closes the inventory.
+                ItemStack oldCursor = playerinventory.getCarried();
+                playerinventory.setCarried(CraftItemStack.asNMSCopy(newcursor));
+
+                //OilSpigot - use asCraftMirror and clone
+                InventoryDragEvent event = new InventoryDragEvent(view, (newcursor.getType() != org.bukkit.Material.AIR ? newcursor : null), CraftItemStack.asCraftMirror(oldCursor).clone(), this.dragType == 1, eventmap);
+                entityhuman.world.getServer().getPluginManager().callEvent(event);
+
+                // Whether or not a change was made to the inventory that requires an update.
+                boolean needsUpdate = event.getResult() != Event.Result.DEFAULT;
+
+                if (event.getResult() != Event.Result.DENY) {
+                    for (Map.Entry<Integer, ItemStack> dslot : draggedSlots.entrySet()) {
+
+                        //OilSpigot - use asCraftMirror and clone
+                        view.setItem(dslot.getKey(), CraftItemStack.asCraftMirror(dslot.getValue()).clone());
+                    }
+                    // The only time the carried item will be set to null is if the inventory is closed by the server.
+                    // If the inventory is closed by the server, then the cursor items are dropped.  This is why we change the cursor early.
+                    if (playerinventory.getCarried() != null) {
+                        playerinventory.setCarried(CraftItemStack.asNMSCopy(event.getCursor()));
+                        needsUpdate = true;
+                    }
+                } else {
+                    playerinventory.setCarried(oldCursor);
+                }
+
+                if (needsUpdate && entityhuman instanceof EntityPlayer) {
+                    ((EntityPlayer) entityhuman).updateInventory(this);
+                }
+                // CraftBukkit end
+            }
+
+            this.d();
+        } else {
+            this.d();
+        }
+    }
+
+
+    @Override
+    public InventoryView getBukkitView() {
+        return null;
+    }
+
+    @Override
+    public boolean canUse(EntityHuman entityhuman) {
+        return false;
+    }
+}
diff --git a/src/main/java/org/oilmod/bukkit/inv2/SetOnlyView.java b/src/main/java/org/oilmod/bukkit/inv2/SetOnlyView.java
new file mode 100644
index 00000000..84a795fe
--- /dev/null
+++ b/src/main/java/org/oilmod/bukkit/inv2/SetOnlyView.java
@@ -0,0 +1,15 @@
+package org.oilmod.bukkit.inv2;
+
+import net.minecraft.server.EntityHuman;
+import net.minecraft.server.ItemStack;
+
+public interface SetOnlyView {
+    ItemStack getStack(int vanillaSlot);
+    ItemStack splitStack(int vanillaSlot, int toSubtract);
+    void setStack(int vanillaSlot, ItemStack stack);
+    boolean isEmpty(int vanillaSlot);
+    boolean isAccessible(int vanillaSlot, EntityHuman human);
+    boolean isSettable(int vanillaSlot, ItemStack stack);
+    int getMaxStackSize(int vanillaSlot);
+    int getMaxStackSize(int vanillaSlot, ItemStack stack);
+}
diff --git a/src/main/java/org/oilmod/bukkit/inv2/VanillaBehavior.java b/src/main/java/org/oilmod/bukkit/inv2/VanillaBehavior.java
new file mode 100644
index 00000000..1aa0942e
--- /dev/null
+++ b/src/main/java/org/oilmod/bukkit/inv2/VanillaBehavior.java
@@ -0,0 +1,6 @@
+package org.oilmod.bukkit.inv2;
+
+public class VanillaBehavior {
+
+
+}
diff --git a/src/main/java/org/oilmod/bukkit/inv2/VanillaSlotView.java b/src/main/java/org/oilmod/bukkit/inv2/VanillaSlotView.java
new file mode 100644
index 00000000..74d7a271
--- /dev/null
+++ b/src/main/java/org/oilmod/bukkit/inv2/VanillaSlotView.java
@@ -0,0 +1,56 @@
+package org.oilmod.bukkit.inv2;
+
+import net.minecraft.server.EntityHuman;
+import net.minecraft.server.ItemStack;
+import net.minecraft.server.Slot;
+import org.bukkit.entity.HumanEntity;
+
+import java.util.List;
+
+public class VanillaSlotView implements VanillaView {
+    private final List<Slot> slots;
+
+    public VanillaSlotView(List<Slot> slots) {
+        this.slots = slots;
+    }
+
+    @Override
+    public ItemStack getStack(int vanillaSlot) {
+        return slots.get(vanillaSlot).getItem();
+    }
+
+    @Override
+    public ItemStack splitStack(int vanillaSlot, int newSplitSize) {
+        return slots.get(vanillaSlot).a(newSplitSize);
+    }
+
+    @Override
+    public void setStack(int vanillaSlot, ItemStack stack) {
+        slots.get(vanillaSlot).set(stack);
+    }
+
+    @Override
+    public boolean isEmpty(int vanillaSlot) {
+        return !slots.get(vanillaSlot).hasItem();
+    }
+
+    @Override
+    public boolean isAccessible(int vanillaSlot, EntityHuman human) {
+        return slots.get(vanillaSlot).isAllowed(human);
+    }
+
+    @Override
+    public boolean isSettable(int vanillaSlot, ItemStack stack) {
+        return slots.get(vanillaSlot).isAllowed(stack);
+    }
+
+    @Override
+    public int getMaxStackSize(int vanillaSlot) {
+        return slots.get(vanillaSlot).getMaxStackSize();
+    }
+
+    @Override
+    public int getMaxStackSize(int vanillaSlot, ItemStack stack) {
+        return slots.get(vanillaSlot).getMaxStackSize(stack);
+    }
+}
diff --git a/src/main/java/org/oilmod/bukkit/inv2/VanillaView.java b/src/main/java/org/oilmod/bukkit/inv2/VanillaView.java
new file mode 100644
index 00000000..0b2f7ec4
--- /dev/null
+++ b/src/main/java/org/oilmod/bukkit/inv2/VanillaView.java
@@ -0,0 +1,15 @@
+package org.oilmod.bukkit.inv2;
+
+import net.minecraft.server.EntityHuman;
+import net.minecraft.server.ItemStack;
+
+public interface VanillaView {
+    ItemStack getStack(int vanillaSlot);
+    ItemStack splitStack(int vanillaSlot, int newSplitSize);
+    void setStack(int vanillaSlot, ItemStack stack);
+    boolean isEmpty(int vanillaSlot);
+    boolean isAccessible(int vanillaSlot, EntityHuman human);
+    boolean isSettable(int vanillaSlot, ItemStack stack);
+    int getMaxStackSize(int vanillaSlot);
+    int getMaxStackSize(int vanillaSlot, ItemStack stack);
+}
diff --git a/src/main/java/org/oilmod/bukkit/items/RealItem.java b/src/main/java/org/oilmod/bukkit/items/RealItem.java
index ef03d11a..0cb24e74 100644
--- a/src/main/java/org/oilmod/bukkit/items/RealItem.java
+++ b/src/main/java/org/oilmod/bukkit/items/RealItem.java
@@ -7,7 +7,6 @@ import org.bukkit.craftbukkit.inventory.CraftItemStack;
 import org.bukkit.craftbukkit.util.CraftMagicNumbers;
 import org.bukkit.entity.LivingEntity;
 import org.oilmod.api.items.ItemInteractionResult;
-import org.oilmod.api.items.NMSItem;
 import org.oilmod.api.items.OilItem;
 import org.oilmod.api.items.type.IDurable;
 import org.oilmod.api.items.type.IToolBlockBreaking;
@@ -39,7 +38,7 @@ public class RealItem extends Item {
     //OilAPI
     public Item getVanillaFakeItem(RealItemStack stack) {
         //noinspection unchecked
-        return CraftMagicNumbers.getItem(apiItem.getVanillaMaterial(stack.getOilItemStack()));
+        return CraftMagicNumbers.getItem(apiItem.getVanillaItem(stack.getOilItemStack()));
     }
 
     public int getVanillaFakeData(RealItemStack stack) {
diff --git a/src/main/java/org/oilmod/bukkit/items/RealItemStack.java b/src/main/java/org/oilmod/bukkit/items/RealItemStack.java
index 7e53be95..6e73946e 100644
--- a/src/main/java/org/oilmod/bukkit/items/RealItemStack.java
+++ b/src/main/java/org/oilmod/bukkit/items/RealItemStack.java
@@ -151,6 +151,16 @@ public class RealItemStack extends ItemStack implements NMSItemStack {
         return hasName()?getName():null;
     }
 
+    @Override
+    public void setRenameNMS(String name) {
+        setDisplayName(name);
+    }
+
+    @Override
+    public boolean isRenamedNMS() {
+        return hasName();
+    }
+
 
 
     //Anvils
diff --git a/src/main/java/org/oilmod/bukkit/util/RealOilUtil.java b/src/main/java/org/oilmod/bukkit/util/RealOilUtil.java
index 70ca50b5..d5553f80 100644
--- a/src/main/java/org/oilmod/bukkit/util/RealOilUtil.java
+++ b/src/main/java/org/oilmod/bukkit/util/RealOilUtil.java
@@ -169,7 +169,7 @@ public class RealOilUtil extends OilUtil.UtilImpl {
     public Class<? extends net.minecraft.server.Entity> mapToNMS(Class<? extends Entity> bukkitClass) {
         /**
          * Order is *EXTREMELY* important -- keep it right! =D
-         */
+         */ //todo updated to 1.12?
         if (LivingEntity.class.isAssignableFrom(bukkitClass)) {
             //Players
             if (HumanEntity.class.isAssignableFrom(bukkitClass)) {
-- 
2.20.1.windows.1

